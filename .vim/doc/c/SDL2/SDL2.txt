
===============================================================================
                                                              *SDL_ActiveEvent*


NAME
       SDL_ActiveEvent - Application visibility event structure

STRUCTURE DEFINITION
       typedef struct{
         Uint8 type;
         Uint8 gain;
         Uint8 state;
       } SDL_ActiveEvent;

STRUCTURE DATA
       type                SDL_ACTIVEEVENT.

       gain                0 if the event is a loss or 1 if it is a gain.

       state               SDL_APPMOUSEFOCUS  if  mouse  focus  was  gained  or lost,
                           SDL_APPINPUTFOCUS if input focus was gained  or  lost,  or
                           SDL_APPACTIVE if the application was iconified (gain=0) or
                           restored(gain=1).

DESCRIPTION
       SDL_ActiveEvent is a member of the SDL_Event union and is used when  an  event
       of type SDL_ACTIVEEVENT is reported.

       When the mouse leaves or enters the window area a SDL_APPMOUSEFOCUS type acti‐
       vation event occurs, if the mouse entered the window then gain will be 1, oth‐
       erwise  gain  will be 0. A SDL_APPINPUTFOCUS type activation event occurs when
       the application loses or gains keyboard focus. This usually  occurs  when  an‐
       other  application  is made active. Finally, a SDL_APPACTIVE type event occurs
       when the application is either minimised/iconified (gain=0) or restored.

              Note:

              This event does not occur when an application window is first created.

SEE ALSO
       |SDL_Event|, |SDL_GetAppState|

===============================================================================
                                                            *SDL_AddEventWatch*


NAME
       SDL_AddEventWatch -- Function

SYNOPSIS
       Use this function to add a callback to triggered when an event is added to the
       event queue.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ void SDL_AddEventWatch(SDL_EventFilter filter,    │
       │                        void*           userData)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ filter    │ the function to call when an │
       │           │ event  happens;  see Remarks │
       │           │ for details                  │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ a pointer that is passed  to │
       │           │ filer                        │
       └───────────┴──────────────────────────────┘

REMARKS
       The function prototype for filter is:

       ┌────────────────────────────────────────┐
       │ int YourEventFilter(void* userdata,    │
       │                     SDL_Event* event)  │
       └────────────────────────────────────────┘

       where YourEventFilter is the name of your function and its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ what  was passed as userdata │
       │           │ to SDL_AddEventWatch()       │
       ├───────────┼──────────────────────────────┤
       │ event     │ the event that triggered the │
       │           │ callback                     │
       └───────────┴──────────────────────────────┘

       filter will be called when an event happens, and its return value is ignored.

       WARNING:  Be  very  careful of what you do in the event filter function, as it
       may run in a different thread!

       If the quit event is generated by a signal (e.g. SIGINT), it will  bypass  the
       internal  queue and be delivered to the watch callback immediately, and arrive
       at the next event poll.

       Note: the callback is called for events posted by  the  user  through  SDL_Pu‐
       shEvent(),  but  not  for disabled events, nor for events by a filter callback
       set with SDL_SetEventFilter(), nor for  events  posted  by  the  user  through
       SDL_PeepEvent().

RELATED FUNCTIONS
       SDL_DelEventWatch
       SDL_SetEventWatch

===============================================================================
                                                          *SDL_AddHintCallback*


NAME
       SDL_AddHintCallback -- Function

SYNOPSIS
       Use this function to add a function to watch a particular hint.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ void SDL_AddHintCallback(const char*       name,      │
       │                          SDL_HintCallback  callback,  │
       │                          void*             userdata)  │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ name      │ the hint to watch            │
       ├───────────┼──────────────────────────────┤
       │ callback  │ the  function  to  call when │
       │           │ the hint value changes       │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ a pointer  to  pass  to  the │
       │           │ callback function            │
       └───────────┴──────────────────────────────┘

REMARKS
       The function prototype for callback is:

       ┌───────────────────────────────────────────────┐
       │ void SDL_HintCallback(void*        userdata,  │
       │                       const char*  name,      │
       │                       const char*  oldValue,  │
       │                       const char*  newValue)  │
       └───────────────────────────────────────────────┘

       where its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ what  was passed as userdata │
       │           │ to SDL_AddHintCallback()     │
       ├───────────┼──────────────────────────────┤
       │ name      │ what was passed as  name  to │
       │           │ SDL_AddHintCallback()        │
       ├───────────┼──────────────────────────────┤
       │ oldValue  │ the old value                │
       ├───────────┼──────────────────────────────┤
       │ newValue  │ the new value                │
       └───────────┴──────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_DelHintCallback

===============================================================================
                                                                 *SDL_AddTimer*


NAME
       SDL_AddTimer -- Function

SYNOPSIS
       Use this function to set up a callback function to be run on a separate thread
       after the specified number of milliseconds has elapsed.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ SDL_TimerID SDL_AddTimer(Uint32            interval,  │
       │                          SDL_TimerCallback callback,  │
       │                          void*             param)     │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ interval  │ the timer delay (ms)  passed │
       │           │ to callback                  │
       ├───────────┼──────────────────────────────┤
       │ callback  │ the  function  to  call when │
       │           │ the    specified    interval │
       │           │ elapses; see Remarks for de‐ │
       │           │ tails                        │
       ├───────────┼──────────────────────────────┤
       │ param     │ a pointer that is passed  to │
       │           │ callback                     │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  a  timer ID or 0 if an error occurs; call SDL_GetError() for more in‐
       formation.

CODE EXAMPLES
       /* Start the timer; the callback below will be executed after the delay */

       Uint32 delay = (33 / 10) * 10;/* To round it down to the nearest 10 ms */
       SDL_TimerID my_timer_id = SDL_AddTimer(delay, my_callbackfunc, my_callback_param);

       Uint32 my_callbackfunc(Uint32 interval, void *param)
       {
         SDL_Event event;
         SDL_UserEvent userevent;

         /* In this example, our callback pushes an SDL_USEREVENT event
         into the queue, and causes our callback to be called again at the
         same interval: */

         userevent.type = SDL_USEREVENT;
         userevent.code = 0;
         userevent.data1 = NULL;
         userevent.data2 = NULL;

         event.type = SDL_USEREVENT;
         event.user = userevent;

         SDL_PushEvent(&event);
         return interval;
       }

REMARKS
       The function prototype for callback is:

       ┌─────────────────────────────────┐
       │ void SDL_YourCallbackHere(...)  │
       └─────────────────────────────────┘
       where its parameters are:

       ┌───────┬───────┐
       │ name  │ first │
       └───────┴───────┘

REMARKS
       The function ...

RELATED FUNCTIONS
===============================================================================
                                                              *SDL_AllocFormat*


NAME
       SDL_AllocFormat -- Function

SYNOPSIS
       Use  this  function  to create an SDL_PixelFormat structure corresponding to a
       pixel format.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ SDL_PixelFormat* SDL_AllocFormat(Uint32 pixel_format)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ pixel_format  │ one  of  the   SDL_PixelFor‐ │
       │               │ matEnum  values; see Remarks │
       │               │ for details                  │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the new SDL_PixelFormat structure or NULL on failure; call  SDL_GetEr‐
       ror() for more information.

REMARKS
       pixel_format may be one of the following:

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar  mode:  Y  + V + U (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar mode: Y + U  +  V  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packet  mode: Y0 + U0 + Y1 + │
       │                              │ V0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed mode: U0 + Y0 + V0  + │
       │                              │ Y1 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed  mode: Y0 + V0 + Y1 + │
       │                              │ U0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar mode: Y + U/V  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar mode: Y + V/U  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

       Returned structure may come from a shared global cache (i.e. not  newly  allo‐
       cated), and hence should not be modified, especially the palette. Weird errors
       such as Blit combination not supported may occur.

RELATED FUNCTIONS
       SDL_FreeFormat

===============================================================================
                                                             *SDL_AllocPalette*


NAME
       SDL_AllocPalette -- Function

SYNOPSIS
       Use  this  function to create a palette structure with the specified number of
       color entries.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ SDL_Palette* SDL_AllocPalette(int ncolors)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ ncolors  │ represents  the  number   of │
       │          │ color  entries  in the color │
       │          │ palette                      │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns a new SDL_Palette structure on success or NULL  on  failure  (e.g.  if
       there wasn't enough memory); call SDL_GetError() for more information.

REMARKS
       The palette entries are initialized to white.

RELATED FUNCTIONS
       SDL_FreePalette

===============================================================================
                                                                  *SDL_AllocRW*


NAME
       SDL_AllocRW -- Function

SYNOPSIS
       Use this function to allocate an empty, unpopulated SDL_RWops structure.

SYNTAX
       ┌───────────────────────────────┐
       │ SDL_RWops* SDL_AllocRW(void)  │
       └───────────────────────────────┘

RETURN VALUE
       Returns a pointer to the allocated memory on success, or NULL on failure; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "stdlib.h"                                                                      │
       │ #include "SDL.h"                                                                         │
       │                                                                                          │
       │ /* These functions should not be used except from pointers in an SDL_RWops */            │
       │ static Sint64 mysizefunc(SDL_RWops *context)                                             │
       │ {                                                                                        │
       │   return -1;                                                                             │
       │ }                                                                                        │
       │                                                                                          │
       │ static Sint64 myseekfunc(SDL_RWops *context, Sint64 offset, int whence)                  │
       │ {                                                                                        │
       │   return SDL_SetError("Can't seek in this kind of SDL_RWops");                           │
       │ }                                                                                        │
       │                                                                                          │
       │ static size_t myreadfunc(SDL_RWops *context, void *ptr, size_t size, size_t maxnum)      │
       │ {                                                                                        │
       │   SDL_memset(ptr, 0, size*maxnum);                                                       │
       │   return maxnum;                                                                         │
       │ }                                                                                        │
       │                                                                                          │
       │ static size_t mywritefunc(SDL_RWops *context, const void *ptr, size_t size, size_t num)  │
       │ {                                                                                        │
       │   return num;                                                                            │
       │ }                                                                                        │
       │                                                                                          │
       │ static int myclosefunc(SDL_RWops *context)                                               │
       │ {                                                                                        │
       │   if (context->type != 0xdeadbeef)                                                       │
       │   {                                                                                      │
       │     return SDL_SetError("Wrong kind of SDL_RWops for myclosefunc()");                    │
       │   }                                                                                      │
       │                                                                                          │
       │   free(context->hidden.unknown.data1);                                                   │
       │   SDL_FreeRW(context);                                                                   │
       │   return 0;                                                                              │
       │ }                                                                                        │
       │                                                                                          │
       │ SDL_RWops *MyCustomRWop()                                                                │
       │ {                                                                                        │
       │   SDL_RWops *c = SDL_AllocRW();                                                          │
       │   if (c == NULL) return NULL;                                                            │
       │                                                                                          │
       │   c->size = mysizefunc;                                                                  │
       │   c->seek = myseekfunc;                                                                  │
       │   c->read = myreadfunc;                                                                  │
       │   c->write = mywritefunc;                                                                │
       │   c->close = myclosefunc;                                                                │
       │   c->type = 0xdeadbeef;                                                                  │
       │   c->hidden.unknown.data1 = malloc(256);                                                 │
       │   return c;                                                                              │
       │ }                                                                                        │
       └──────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       Applications do not need to use this function unless they are providing  their
       own  SDL_RWops  implementation.  If  you just need a SDL_RWops to read/write a
       common data source, you should use the built-in implementation  in  SDL,  like
       SDL_RWFromFile() or SDL_RWFromMem(), etc.

       You  must free the returned pointer with SDL_FreeRW(). Depending on your oper‐
       ating system and compiler, there may be a difference between the malloc()  and
       free()  your program uses and the versions SDL calls internally. Trying to mix
       the two can cause crashing such as segmentation faults.  Since  all  SDL_RWops
       must  free themselves when their close method is called, all SDL_RWops must be
       allocated through this function, so they  can  all  be  freed  correctly  with
       SDL_FreeRW().

RELATED FUNCTIONS
       SDL_FreeRW

===============================================================================
                                                       *SDL_AndroidGetActivity*


NAME
       SDL_AndroidGetActivity -- Function

SYNOPSIS
       Use  this  function  to retrieve the Java instance of the activity class in an
       Android application.

SYNTAX
       ┌─────────────────────────────────┐
       │ void* SDL_AndroidGetActivity()  │
       └─────────────────────────────────┘

RETURN VALUE
       Returns the jobject representing the instance of the Activity class of the An‐
       droid application, or NULL on error.

       The jobject returned by the function is a local reference and must be released
       by the caller. See the PushLocalFrame() and  PopLocalFrame()  or  DeleteLocal‐
       Ref()   functions   of   the   Java  native  interface  (see  http://docs.ora‐
       cle.com/javase/1.5.0/docs/guide/jni/spec/functions.html).

CODE EXAMPLES
       The first example uses C to work with JNI.

       ┌──────────────────────────────────────────────────────────────────────────────────────────┐
       │ // This example uses C and a custom Java method name "void showHome()"                   │
       │                                                                                          │
       │ // Calls the void showHome() method of the Java instance of the activity.                │
       │ void showHome(void)                                                                      │
       │ {                                                                                        │
       │   // retrieve the JNI environment                                                        │
       │   JNIEnv* env = (JNIEnv*)SDL_AndroidGetJNIEnv();                                         │
       │                                                                                          │
       │   // retrieve the Java instance of the SDLActivity                                       │
       │   jobject activity = (jobject)SDL_AndroidGetActivity();                                  │
       │                                                                                          │
       │   // find the Java class of the activity. It should be SDLActivity or a subclass of it.  │
       │   jclass clazz = (*env)->GetObjectClass(env, activity);                                  │
       │                                                                                          │
       │   // find the identifier of the method to call                                           │
       │   // testMethod() will print "Print from testMethod() from Java code" in console         │
       │   jmethodID method_id (*env)->GetMethodID(env, clazz, "testMethod", "()V");              │
       │                                                                                          │
       │   // effectively call the Java method                                                    │
       │   (*env)->CallVoidMethod(env, activity, method_id);                                      │
       │                                                                                          │
       │   // clean up the local references                                                       │
       │   (*env)->DeleteLocalRef(env, activity);                                                 │
       │   (*env)->DeleteLocalRef(env, clazz);                                                    │
       │                                                                                          │
       │   // Warning (and discussion of implmentation details of SDL for Android):               │
       │   // Local references are automatically deleted if a native function called              │
       │   // from Java side returns. For SDL this native function is main() itself.              │
       │   // Therefore references need to be manually deleted because otherwise the              │
       │   // references will first be cleaned if main() returns (application exit).              │
       │ }                                                                                        │
       └──────────────────────────────────────────────────────────────────────────────────────────┘

       The second example requires C++ to work with JNI.

       ┌──────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                         │
       │ #include <jni.h>                                                                         │
       │                                                                                          │
       │ // This example requires C++ and a custom Java method named "void showHome()"            │
       │                                                                                          │
       │ // Calls the void showHome() method of the Java instance of the activity.                │
       │ void showHome(void)                                                                      │
       │ {                                                                                        │
       │   // retrieve the JNI environment.                                                       │
       │   JNIEnv* env = (JNIEnv*)SDL_AndroidGetJNIEnv();                                         │
       │                                                                                          │
       │   // retrieve the Java interface of the SDLActivity                                      │
       │   jobject activity = (jobject)SDL_AndroidGetActivity();                                  │
       │                                                                                          │
       │   // find the Java class of the activity. It should be SDLActivity or a subclass of it.  │
       │   jclass clazz(env->GetObjectClass(activity));                                           │
       │                                                                                          │
       │   // find the identifier of the method to call                                           │
       │   jmethodID method_id = env->GetMethodID(clazz, "showHome", "()V");                      │
       │                                                                                          │
       │   // effectively call the Java method                                                    │
       │   env->CallVoidMethod(activity, method_id);                                              │
       │                                                                                          │
       │   // clean up the local references                                                       │
       │   env->DeleteLocalRef(activity);                                                         │
       │   env->DeleteLocalRef(clazz);                                                            │
       │                                                                                          │
       │   // Warning (and discussion of implmentation details of SDL for Android):               │
       │   // Local references are automatically deleted if a native function called              │
       │   // from Java side returns. For SDL this native function is main() itself.              │
       │   // Therefore references need to be manually deleted because otherwise the              │
       │   // references will first be cleaned if main() returns (application exit).              │
       │ }                                                                                        │
       └──────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The prototype of the function is SDL's code actually declares a  void*  return
       type,  even  if the implementation returns a jobject. The rationale being that
       it allows not to include jni.h in the headers of the SDL.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AndroidGetJNIEnv

===============================================================================
                                            *SDL_AndroidGetExternalStoragePath*


NAME
       SDL_AndroidGetExternalStoragePath -- Function

SYNOPSIS
       Use  this function to get the path used for external storage for this applica‐
       tion.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ const char* SDL_AndroidGetExternalStoragePath()  │
       └──────────────────────────────────────────────────┘

REMARKS
       This path is unique to your application, but is public and can be  written  to
       by other applications.

       Your    external    storage    path    is    typically:   /storage/sdcard0/An‐
       droid/data/your.app.package/files.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AndroidGetExternalStorageState

===============================================================================
                                           *SDL_AndroidGetExternalStorageState*


NAME
       SDL_AndroidGetExternalStorageState -- Function

SYNOPSIS
       Use this function to get the current state of external storage.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ int SDL_AndroidGetExternalStorageState()  │
       └───────────────────────────────────────────┘

RETURN VALUE
       Returns the current state of external storage on success or 0 on failure; call
       SDL_GetError() for more information.

REMARKS
       The current state of external storage, a bitmask of these values:

       SDL_ANDROID_EXTERNAL_STORAGE_READ, SDL_ANDROID_EXTERNAL_STORAGE_WRITE

       If external storage is currently unavailable, this will return 0.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AndroidGetExternalStoragePath

===============================================================================
                                            *SDL_AndroidGetInternalStoragePath*


NAME
       SDL_AndroidGetInternalStoragePath -- Function

SYNOPSIS
       Use  this function to get the path used for internal storage for this applica‐
       tion.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ const char* SDL_AndroidGetInternalStoragePath()  │
       └──────────────────────────────────────────────────┘

RETURN VALUE
       Returns the path used for internal storage or NULL on failure; call SDL_GetEr‐
       ror() for more information.

REMARKS
       This  path is unique to your application and cannot be written to by other ap‐
       plications.

       Your internal storage path is typically: /data/data/your.app.package/files.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AndroidGetExternalStorageState

===============================================================================
                                                         *SDL_AndroidGetJNIEnv*


NAME
       SDL_AndroidGetJNIEnv -- Function

SYNOPSIS
       Use this function to retrieve the Java native interface object (JNIEnv) of the
       current thread on Android builds.

SYNTAX
       ┌───────────────────────────────┐
       │ void* SDL_AndroidGetJNIEnv()  │
       └───────────────────────────────┘

RETURN VALUE
       Returns a pointer to Java native interface object (JNIEnv) to which  the  cur‐
       rent thread is attached, or 0 on error.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                         │
       │ #include <jni.h>                                                                         │
       │                                                                                          │
       │ // This example requires C++ and a custom Java method named "void showHome()"            │
       │                                                                                          │
       │ // Calls the void showHome() method of the Java instance of the activity.                │
       │ void showHome(void)                                                                      │
       │ {                                                                                        │
       │   // retrieve the JNI environment                                                        │
       │   JNIEnv* env = (JNIEnv*)SDL_AndroidGetJNIEnv();                                         │
       │                                                                                          │
       │   // retrieve the Java instance of the SDLActivity                                       │
       │   jobject activity = (jobject)SDL_AndroidGetActivity();                                  │
       │                                                                                          │
       │   // find the Java class of the activity. It should be SDLActivity or a subclass of it.  │
       │   jclass clazz(env->GetObjectClass(activity));                                           │
       │                                                                                          │
       │   // find the identifier of the method to call                                           │
       │   jmethodID method_id = env->GetMethodID(clazz, "showHome", "()V");                      │
       │                                                                                          │
       │   // effectively call the Java method                                                    │
       │   env->CallVoidMethod(activity, method_id);                                              │
       │                                                                                          │
       │   // clean up the local references                                                       │
       │   env->DeleteLocalRef(activity);                                                         │
       │   env->DeleteLocalRef(clazz);                                                            │
       │                                                                                          │
       │   // Warning (and discussion of implementation details of SDL for Android):              │
       │   // Local references are automatically deleted if a native function called              │
       │   // from Java side returns. For SDL, this native function is main() itself.             │
       │   // Therefore references need to be manually deleted because otherwise the              │
       │   // references will first be cleaned if main() returns (application exit).              │
       │ }                                                                                        │
       └──────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The  prototype  of  the function in SDL's code actually declare a void* return
       type, even if the implementation returns a pointer to a JNIEnv. The  rationale
       being that it allows not to include jni.h in the headers of the SDL.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AndroidGetActivity

===============================================================================
                                                              *SDL_AssertState*


NAME
       SDL_AssertState -- Enumerations

SYNOPSIS
       An enumeration of assertion handling states.

DESCRIPTION
       Values

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_ASSERTION_RETRY          │  retry  the  assert immedi‐  │
       │                              │  ately                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_ASSERTION_BREAK          │  trigger a breakpoint under  │
       │                              │  the debugger                │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_ASSERTION_ABORT          │  terminate the program       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_ASSERTION_IGNORE         │  ignore the assert           │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_ASSERTION_ALWAYS_IGNORE  │  ignore the assert from now  │
       │                              │  on                          │
       └──────────────────────────────┴──────────────────────────────┘

REMARKS
       This enumeration is returned by the callback function in  SDL_SetAssertionHan‐
       dler() to determine the response to failed assertions.

SEE ALSO
       SDL_SetAssertionHandler

===============================================================================
                                                                *SDL_AtomicAdd*


NAME
       SDL_AtomicAdd -- Function

SYNOPSIS
       Use this function to add to an atomic variable.

SYNTAX
       ┌─────────────────────────────────────┐
       │ int SDL_AtomicAdd(SDL_atomic_t* a,  │
       │                   int           v)  │
       └─────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ a  │ a pointer to an SDL_atomic_t │
       │    │ variable to be modified      │
       ├────┼──────────────────────────────┤
       │ v  │ the desired value to add     │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns the previous value of the atomic variable.

REMARKS
       This function also acts as a full memory barrier.

RELATED FUNCTIONS
       SDL_AtomicDecRef
       SDL_AtomicIncRef

===============================================================================
                                                                *SDL_AtomicCAS*


NAME
       SDL_AtomicCAS -- Function

SYNOPSIS
       Use  this function to set an atomic variable to a new value if it is currently
       an old value.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ SDL_bool SDL_AtomicCAS(SDL_atomic_t*  a,       │
       │                        int            oldval,  │
       │                        int            newval)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ a       │ a pointer to an SDL_atomic_t │
       │         │ variable to be modified      │
       ├─────────┼──────────────────────────────┤
       │ oldval  │ the old value                │
       ├─────────┼──────────────────────────────┤
       │ newval  │ the new value                │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.

REMARKS
       Note: If you don't know what this function is for, you shouldn't use it!

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AtomicCASPtr
       SDL_AtomicGet
       SDL_AtomicSet

===============================================================================
                                                             *SDL_AtomicCASPtr*


NAME
       SDL_AtomicCASPtr -- Function

SYNOPSIS
       Use  this  function  to set a pointer to a new value if it is currently an old
       value.

SYNTAX
       ┌──────────────────────────────────────────┐
       │ SDL_bool SDL_AtomicCASPtr(void** a,      │
       │                           void* oldval,  │
       │                           void* newval)  │
       └──────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬────────────────────────┐
       │ a       │ a pointer to a pointer │
       ├─────────┼────────────────────────┤
       │ oldval  │ the old pointer value  │
       ├─────────┼────────────────────────┤
       │ newval  │ the new pointer value  │
       └─────────┴────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise.

REMARKS
       Note: If you don't know what this function is for, you shouldn't use it!

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AtomicCAS
       SDL_AtomicGetPtr
       SDL_AtomicSetPtr

===============================================================================
                                                             *SDL_AtomicDecRef*


NAME
       SDL_AtomicDecRef -- Function

SYNOPSIS
       Use this function to decrement an atomic variable used as a reference count.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ SDL_bool SDL_AtomicDecRef(SDL_atomic_t* a)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ a  │ a pointer to an SDL_atomic_t │
       │    │ variable to be modified      │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the variable reached zero  after  decrementing,  SDL_FALSE
       otherwise.

RELATED FUNCTIONS
       SDL_AtomicAdd
       SDL_AtomicIncRef

===============================================================================
                                                                *SDL_AtomicGet*


NAME
       SDL_AtomicGet -- Function

SYNOPSIS
       Use this function to get the value of an atomic variable.

SYNTAX
       ┌─────────────────────────────────────┐
       │ int SDL_AtomicGet(SDL_atomic_t* a)  │
       └─────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ a  │ a pointer to an SDL_atomic_t │
       │    │ varible                      │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns the current value of an atomic variable.

RELATED FUNCTIONS
       SDL_AtomicSet

===============================================================================
                                                             *SDL_AtomicGetPtr*


NAME
       SDL_AtomicGetPtr -- Function

SYNOPSIS
       Use this function to get the value of a pointer atomically.

SYNTAX
       ┌───────────────────────────────────┐
       │ void* SDL_AtomicGetPtr(void** a)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬────────────────────────┐
       │ a  │ a pointer to a pointer │
       └────┴────────────────────────┘

RETURN VALUE
       Returns the current value of a pointer.

RELATED FUNCTIONS
       SDL_AtomicCASPtr
       SDL_AtomicSetPtr

===============================================================================
                                                             *SDL_AtomicIncRef*


NAME
       SDL_AtomicIncRef -- Function

SYNOPSIS
       Use this function to increment an atomic variable used as a reference count.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ void SDL_AtomicIncRef(SDL_atomic_t* a)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ a  │ a pointer to an SDL_atomic_t │
       │    │ variable to be modified      │
       └────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_AtomicAdd
       SDL_AtomicDecRef

===============================================================================
                                                               *SDL_AtomicLock*


NAME
       SDL_AtomicLock -- Function

SYNOPSIS
       Use this function to lock a spin lock by setting it to a non-zero value.

SYNTAX
       ┌──────────────────────────────────────────┐
       │ void SDL_AtomicLock(SDL_SpinLock* lock)  │
       └──────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ lock  │ a pointer to a lock variable │
       └───────┴──────────────────────────────┘

REMARKS
       The  atomic locks are efficient spinlocks using CPU instructions, but are vul‐
       nerable to starvation and can spin forever if a thread holding a lock has been
       terminated.  For  this  reason you should minimize the code executed inside an
       atomic lock and never do expensive things like API or system calls while hold‐
       ing them.

       The atomic locks are not safe to lock recursively.

RELATED FUNCTIONS
       SDL_AtomicTryLock
       SDL_AtomicUnlock

===============================================================================
                                                                *SDL_AtomicSet*


NAME
       SDL_AtomicSet -- Function

SYNOPSIS
       Use this function to set an atomic variable to a value.

SYNTAX
       ┌─────────────────────────────────────┐
       │ int SDL_AtomicSet(SDL_atomic_t* a,  │
       │                   int           v)  │
       └─────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ a  │ a pointer to an SDL_atomic_t │
       │    │ variable to be modified      │
       ├────┼──────────────────────────────┤
       │ v  │ the desired value            │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns the previous value of the atomic variable.

REMARKS
       This function also acts as a full memory barrier.

RELATED FUNCTIONS
       SDL_AtomicGet

===============================================================================
                                                             *SDL_AtomicSetPtr*


NAME
       SDL_AtomicSetPtr -- Function

SYNOPSIS
       Use this function to set a pointer to a value atomically.

SYNTAX
       ┌───────────────────────────────────┐
       │ void* SDL_AtomicSetPtr(void** a,  │
       │                        void* v)   │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬───────────────────────────┐
       │ a  │ a pointer to a pointer    │
       ├────┼───────────────────────────┤
       │ v  │ the desired pointer value │
       └────┴───────────────────────────┘

RETURN VALUE
       Returns the previous value of the pointer.

RELATED FUNCTIONS
       SDL_AtomicCASPtr
       SDL_AtomicGetPtr

===============================================================================
                                                            *SDL_AtomicTryLock*


NAME
       SDL_AtomicTryLock -- Function

SYNOPSIS
       Use  this  function  to  try  to  lock a spin lock by setting it to a non-zero
       value.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ SDL_bool SDL_AtomicTryLock(SDL_SpinLock* lock)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ lock  │ a pointer to a lock variable │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held.

REMARKS
       The atomic locks are efficient spinlocks using CPU instructions, but are  vul‐
       nerable  to  starvation and can spin forever if a threshold holding a lock has
       been terminated. For this reason you should minimize the code executed  inside
       an  atomic  lock  and never do expensive things like API or system calls while
       holding them.

       The atomic locks are not safe to lock recursively.

RELATED FUNCTIONS
       SDL_AtomicLock
       SDL_AtomicUnlock

===============================================================================
                                                             *SDL_AtomicUnlock*


NAME
       SDL_AtomicUnlock -- Function

SYNOPSIS
       Use this function to unlock a spin lock by setting it to 0.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_AtomicUnlock(SDL_SpinLock* lock)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ lock  │ a pointer to a lock variable │
       └───────┴──────────────────────────────┘

REMARKS
       Always return immediately.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AtomicLock
       SDL_AtomicTryLock

===============================================================================
                                                                 *SDL_AudioCVT*


NAME
       SDL_AudioCVT -- Structure

SYNOPSIS
       A structure that contains audio data conversion information.

DATA FIELDS
       ┌──────────────────────┬──────────────┬───────────────────────┐
       │ int                  │ needed       │ set  to  1 if conver‐ │
       │                      │              │ sion possible         │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ SDL_AudioFormat      │ src_format   │ source audio format   │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ SDL_AudioFormat      │ dst_format   │ target audio format   │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ double               │ rate_incr    │ rate  conversion  in‐ │
       │                      │              │ crement               │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ Uint8*               │ buf          │ the  buffer  to  hold │
       │                      │              │ entire  audio   data; │
       │                      │              │ see  Remarks  for de‐ │
       │                      │              │ tails                 │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ int                  │ len          │ length  of   original │
       │                      │              │ audio buffer; see Re‐ │
       │                      │              │ marks for details     │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ int                  │ len_cvt      │ length  of  converted │
       │                      │              │ audio buffer          │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ int                  │ len_mult     │ buf      must      be │
       │                      │              │ len*len_mult big; see │
       │                      │              │ Remarks for details   │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ double               │ len_ratio    │ given len, final size │
       │                      │              │ is len*len_ratio; see │
       │                      │              │ Remarks for details   │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ SDL_AudioFilter[10]  │ filters      │ filter list (internal │
       │                      │              │ use)                  │
       ├──────────────────────┼──────────────┼───────────────────────┤
       │ int                  │ filter_index │ current audio conver‐ │
       │                      │              │ sion function (inter‐ │
       │                      │              │ nal use)              │
       └──────────────────────┴──────────────┴───────────────────────┘

CODE EXAMPLES
       // Change 1024 stereo sample frames at 48000Hz from float32 to int16.
       SDL_AudioCVT cvt;
       SDL_BuildAudioCVT(&cvt, AUDIO_F32, 2, 48000, AUDIO_S16, 2, 48000);
       SDL_assert(cvt.needed);              // obviously, this one is always needed.
       cvt.len = 1024 * 2 * 4; // 1024 stereo float32 sample frames.
       cvt.buf = (Uint8 *)SDL_malloc(cvt.len * cvt.len_mult);
       // read your float32 data into cvt.buf here.
       SDL_ConvertAudio(&cvt);
       // cvt.buf has cvt.len_cvt bytes of converted data now.

REMARKS
       The SDL_AudioCVT structure is used to convert  audio  data  between  different
       formats. An SDL_AudioCVT structure is initialized with the SDL_BuildAudioCVT()
       function, while the actual conversion is done by the SDL_ConvertAudio()  func‐
       tion,  once  the  application  has  set up appropriately-sized buffers between
       these two function calls.

       bufpoints to the audio data that will be used in the conversion.  It  is  both
       the  source  and  the  destination, which means the converted audio data over‐
       writes the original data. It also means that the converted data may be  larger
       than  the  original data (if you were converting from 8-bit to 16-bit, for in‐
       stance), so you must ensure buf is large enough for any stage of  the  conver‐
       sion,  regardless  of  the final converted data's size. See len_mult below for
       more info.

       len is the length of the original audio data in bytes.

       len_mult is the length multiplier for determining the size  of  the  converted
       data.  The  audio buffer may need to be larger than either the orignal data or
       the converted data. The allocated size of buf should be len*len_mult.

       len_ratio is the length ratio of the converted data to the original data. When
       you  have  finished  converting  your audio data, you need to know how much of
       your audio buffer is valid. len*len_ratio is the size of the  converted  audio
       data  in  bytes.  This is very similar to len_mult, however when the converted
       audio data is shorter than the original, len_mult would be  1.  len_ratio,  on
       the other hand, would be a fractional number between 0 and 1.

RELATED FUNCTIONS
       SDL_BuildAudioCVT
       SDL_ConvertAudio

===============================================================================
                                                         *SDL_AudioDeviceEvent*


NAME
       SDL_AudioDeviceEvent -- Structure

SYNOPSIS
       A structure that containsa Audio device event information.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ SDL_AUDIODEVICEDDED,  │
       │         │           │ or SDL_AUDIODEVICERE‐ │
       │         │           │ MOVED                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ the  timestamp of the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ which     │ the audio device  in‐ │
       │         │           │ dex  for  the SDL_AU‐ │
       │         │           │ DIODEVICEADDED  event │
       │         │           │ (valid   until   next │
       │         │           │ SDL_GetNumAudioDe‐    │
       │         │           │ vices()        call), │
       │         │           │ SDL_AudioDeviceID for │
       │         │           │ the SDL_AUDIODEVICER‐ │
       │         │           │ EMOVED event          │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint8   │ iscapture │ zero if an audio out‐ │
       │         │           │ put  device, non-zero │
       │         │           │ if an  audio  capture │
       │         │           │ device                │
       └─────────┴───────────┴───────────────────────┘

VERSIONS
       This structure is available since SDL 2.0.4.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

RELATED FUNCTIONS
       SDL_GetNumAudioDevices

===============================================================================
                                                              *SDL_AudioFormat*


NAME
       SDL_AudioFormat -- Enumerations

SYNOPSIS
       An enumeration of audio formats.

DESCRIPTION
       Bit Meanings

       These are what the 16 bits in SDL_AudioFormat currently mean:

       ┌──────────────────────────────────────────────────┐
       │  +----------------------sample is signed if set  │
       │  |                                               │
       │  |        +----------sample is bigendian if set  │
       │  |        |                                      │
       │  |        |           +--sample is float if set  │
       │  |        |           |                          │
       │  |        |           |  +--sample bit size---+  │
       │  |        |           |  |                    |  │
       │ 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0  │
       └──────────────────────────────────────────────────┘

       Unspecified  bits  are  always zero, but may be used in later versions of SDL.
       There are macros to query the specified bits.

       Audio Format Macros

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_AUDIO_MASK_BITSIZE       │  (0xFF)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_MASK_DATATYPE      │  (1<<8)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_MASK_ENDIAN        │  (1<<12)                     │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_MASK_SIGNED        │  (1<<15)                     │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_BITSIZE(x)         │  (x        &        SDL_AU‐  │
       │                              │  DIO_MASK_BIT_SIZE)          │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_ISFLOAT(x)         │  (x        &        SDL_AU‐  │
       │                              │  DIO_MASK_DATATYPE)          │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_ISBIGENDIAN(x)     │  (x  &   SDL_AUDIO_MASK_EN‐  │
       │                              │  DIAN)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_ISSIGNED(x)        │  (x        &        SDL_AU‐  │
       │                              │  DIO_MASK_SIGNED)            │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_ISINT(x)           │  (!SDL_AUDIO_ISFLOAT(x))     │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_ISLITTLEENDIAN(x)  │  (!SDL_AUDIO_ISBIGEN‐        │
       │                              │  DIAN(x))                    │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIO_ISUNSIGNED(x)      │  (!SDL_AUDIO_ISSIGNED(x))    │
       └──────────────────────────────┴──────────────────────────────┘

       Audio Format Values

       8-bit support

       ┌───────────┬──────────────────────────┐
       │ AUDIO_S8  │  signed 8-bit samples    │
       ├───────────┼──────────────────────────┤
       │ AUDIO_U8  │  unsigned 8-bit samples  │
       └───────────┴──────────────────────────┘

       16-bit support

       ┌───────────────┬──────────────────────────────┐
       │ AUDIO_S16LSB  │  signed  16-bit  samples in  │
       │               │  little-endian byte order    │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_S16MSB  │  signed 16-bit  samples  in  │
       │               │  big-endian byte order       │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_S16SYS  │  signed  16-bit  samples in  │
       │               │  native byte order           │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_S16     │  AUDIO_S16LSB                │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_U16LSB  │  unsigned 16-bit samples in  │
       │               │  little-endian byte order    │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_U16MSB  │  unsigned 16-bit samples in  │
       │               │  big-endian byte order       │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_U16SYS  │  unsigned 16-bit samples in  │
       │               │  native byte order           │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_U16     │  AUDIO_U16LSB                │
       └───────────────┴──────────────────────────────┘

       32-bit support (new to SDL 2.0)

       ┌───────────────┬──────────────────────────────┐
       │ AUDIO_S32LSB  │  32-bit  integer samples in  │
       │               │  little-endian byte order    │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_S32MSB  │  32-bit integer samples  in  │
       │               │  big-indian byte order       │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_S32SYS  │  32-bit  integer samples in  │
       │               │  native byte order           │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_S32     │  AUDIO_S32LSB                │
       └───────────────┴──────────────────────────────┘

       float support (new to SDL 2.0)

       ┌───────────────┬──────────────────────────────┐
       │ AUDIO_F32LSB  │  32-bit floating point sam‐  │
       │               │  ples in little-endian byte  │
       │               │  order                       │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_F32MSB  │  32-bit floating point sam‐  │
       │               │  ples  in  big-endian  byte  │
       │               │  order                       │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_F32SYS  │  32-bit floating point sam‐  │
       │               │  ples in native byte order   │
       ├───────────────┼──────────────────────────────┤
       │ AUDIO_F32     │  AUDIO_F32LSB                │
       └───────────────┴──────────────────────────────┘

CODE EXAMPLES
       extern SDL_AudioFormat fmt;
       if (SDL_AUDIO_ISFLOAT(fmt)) {
           printf("floating point data\n");
       } else {
           printf("integer data\n");
       }
       printf("%d bits per sample\n", (int) SDL_AUDIO_BITSIZE(fmt));

REMARKS
       Be  careful about assuming details of a data format. If you only check SDL_AU‐
       DIO_ISFLOAT(), you might be surprised to find a  later  version  of  SDL  adds
       Float64 support when you expected there to be only 32-bit data, for example.

RELATED STRUCTURES
       SDL_AudioCVT, SDL_AudioSpec

RELATED FUNCTIONS
       SDL_BuildAudioCVT, SDL_MixAudioFormat

===============================================================================
                                                                *SDL_AudioInit*


NAME
       SDL_AudioInit -- Function

SYNOPSIS
       Use this function to initialize a particular audio driver.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ int SDL_AudionInit(const char* driver_name)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────────┬──────────────────────────────┐
       │ driver_name  │ the  name of the desired au‐ │
       │              │ dio driver                   │
       └──────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────┐
       │ int i;                                                             │
       │                                                                    │
       │ for (i = 0; i < SDL_GetNumAudioDrivers(); ++i) {                   │
       │   const char* driver_name = SDL_GetAudioDriver(i);                 │
       │   if (SDL_AudioInit(driver_name)) {                                │
       │     printf("Audio driver failed to initialize: %s0, driver_name);  │
       │     continue;                                                      │
       │   }                                                                │
       │   SDL_AudioQuit();                                                 │
       │ }                                                                  │
       └────────────────────────────────────────────────────────────────────┘

REMARKS
       This  function  is  used  internally, and should not be used unless you have a
       specific need to designate the audio driver you want to use.  You should  nor‐
       mally use SDL_Init() or SDL_InitSubSystem().

RELATED FUNCTIONS
       SDL_AudioQuit

===============================================================================
                                                                *SDL_AudioQuit*


NAME
       SDL_AudioQuit -- Function

SYNOPSIS
       Use  this  function  to  shut  down  audio  if you initialized it with SDL_Au‐
       dioInit().

SYNTAX
       ┌───────────────────────────┐
       │ void SDL_AudioQuit(void)  │
       └───────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────┐
       │ int i;                                                             │
       │                                                                    │
       │ for (i = 0; i < SDL_GetNumAudioDrivers(); ++i) {                   │
       │   const char* driver_name = SDL_GetAudioDriver(i);                 │
       │   if (SDL_AudioInit(driver_name)) {                                │
       │     printf("Audio driver failed to initialize: %s0, driver_name);  │
       │     continue;                                                      │
       │   }                                                                │
       │   SDL_AudioQuit();                                                 │
       │ }                                                                  │
       └────────────────────────────────────────────────────────────────────┘

REMARKS
       This function is used internally, and should not be used  unless  you  have  a
       specific need to specify the audio driver you want to use. You should normally
       use SDL_Quit() or SDL_QuitSubSystem().

RELATED FUNCTIONS
       SDL_AudioInit

===============================================================================
                                                                *SDL_AudioSpec*


NAME
       SDL_AudioSpec -- Structure

SYNOPSIS
       A structure that contains the audio output format. It also contains a callback
       that is called when the audio device needs more data.

DATA FIELDS
       ┌────────────────────┬──────────┬───────────────────────┐
       │ int                │ freq     │ DSP  frequency  (sam‐ │
       │                    │          │ ples per second); see │
       │                    │          │ Remarks for details   │
       ├────────────────────┼──────────┼───────────────────────┤
       │ SDL_AudioFormat    │ format   │ audio  data   format; │
       │                    │          │ see  Remarks  for de‐ │
       │                    │          │ tails                 │
       ├────────────────────┼──────────┼───────────────────────┤
       │ Uint8              │ channels │ number  of   separate │
       │                    │          │ sound  channels;  see │
       │                    │          │ Remarks for details   │
       ├────────────────────┼──────────┼───────────────────────┤
       │ Uint8              │ silence  │ audio buffer  silence │
       │                    │          │ value (calculated)    │
       ├────────────────────┼──────────┼───────────────────────┤
       │ Uint16             │ samples  │ audio  buffer size in │
       │                    │          │ samples (power of 2); │
       │                    │          │ see  Remarks  for de‐ │
       │                    │          │ tails                 │
       ├────────────────────┼──────────┼───────────────────────┤
       │ Uint32             │ size     │ audio buffer size  in │
       │                    │          │ bytes (calculated)    │
       ├────────────────────┼──────────┼───────────────────────┤
       │ SDL_AudioCallback  │ callback │ the  function to call │
       │                    │          │ when the audio device │
       │                    │          │ needs  more data; see │
       │                    │          │ Remarks for details   │
       ├────────────────────┼──────────┼───────────────────────┤
       │ void*              │ userdata │ a  pointer  that   is │
       │                    │          │ passed   to  callback │
       │                    │          │ (otherwise ignroed by │
       │                    │          │ SDL)                  │
       └────────────────────┴──────────┴───────────────────────┘

CODE EXAMPLES
       SDL_AudioSpec want, have;
       SDL_AudioDeviceID dev;

       SDL_memset(&want, 0, sizeof(want));/* or SDL_zero(want) */
       want.freq = 48000;
       want.format = AUDIO_F32;
       want.channels = 2;
       want.samples = 4096;
       want.callback = MyAudioCallback;// you wrote this function elsewhere.
       dev = SDL_OpenAudioDevice(NULL, 0, &want, &have, SDL_AUDIO_ALLOW_FORMAT_CHANGE);

REMARKS
       This  structure  is used by SDL_OpenAudioDevice() and SDL_LoadWav(). While all
       fields are used by SDL_OpenAudioDevice(), only  freq,  format,  channels,  and
       samples are used by SDL_LoadWAV().

       freq  specifies  the number of sample frames sent to the sound device per sec‐
       ond. Common values are 11025, 22050, 44100 and 48000.  Larger  values  produce
       cleaner  audio,  in  much the same way that larger resolutions produce cleaner
       graphics.

       format specifies the size and type of each sample element and may  be  one  of
       the following.

       ┌─────────────────────────────────────────────────────┐
       │ 8-bit support                                       │
       ├───────────────────────┬─────────────────────────────┤
       │      AUDIO_S8         │signed 8-bit samples         │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_U8          │unsigned 8-bit samples       │
       ├───────────────────────┴─────────────────────────────┤
       │                   16-bit support                    │
       ├───────────────────────┬─────────────────────────────┤
       │     AUDIO_S16LSB      │signed   16-bit  samples  in │
       │                       │little-endian byte order     │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_S16MSB      │signed  16-bit  samples   in │
       │                       │big-endian byte order        │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_S16SYS      │signed 16-bit samples in na‐ │
       │                       │tive byte order              │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_S16         │AUDIO_S16LSB                 │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_U16LSB      │unsigned 16-bit  samples  in │
       │                       │little-endian byte order     │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_U16MSB      │unsigned  16-bit  samples in │
       │                       │big-endian byte order        │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_U16SYS      │unsigned 16-bit  samples  in │
       │                       │native byte order            │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_U16         │AUDIO_U16LSB                 │
       ├───────────────────────┴─────────────────────────────┤
       │ 32-bit support (new to SDL 2.0)                     │
       ├───────────────────────┬─────────────────────────────┤
       │     AUDIO_S32LSB      │32-bit  integer  samples  in │
       │                       │little-endian byte order     │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_S32MSB      │32-bit  integer  samples  in │
       │                       │big-endian byte order        │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_S32SYS      │32-bit  integer  samples  in │
       │                       │native byte order            │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_S32         │AUDIO_S32LSB                 │
       ├───────────────────────┴─────────────────────────────┤
       │ float support (new to SDL 2.0)                      │
       ├───────────────────────┬─────────────────────────────┤
       │     AUDIO_F32LSB      │32-bit floating  point  sam‐ │
       │                       │ples  in  little-endian byte │
       │                       │order                        │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_F32MSB      │32-bit floating  point  sam‐ │
       │                       │ples  in big-endian byte or‐ │
       │                       │der                          │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_F32SYS      │32-bit floating  point  sam‐ │
       │                       │ples in native byte order    │
       ├───────────────────────┼─────────────────────────────┤
       │     AUDIO_F32         │AUDIO_F32LSB                 │
       └───────────────────────┴─────────────────────────────┘
       See SDL_AudioFormat for more info.

       channels  specifies  the  number  of output channels. As of SDL 2.0, supported
       values are 1 (mono), 2 (stereo), 4 (quad), and 6 (5.1).

       samples specifies a unit of audio data. When used  with  SDL_OpenAudioDevice()
       this  refers  to the size of the audio buffer in sample frames. A sample frame
       is a chunk of audio data of the size specified in  format  multiplied  by  the
       number  of channels. When the SDL_AudioSpec is used with SDL_LoadWAV() samples
       is set to 4096. This field's value must be a power of two.

       The values silence and size are calculated by SDL_OpenAudioDevice().

       Channel data is interleaved. Stereo samples are stored in left/right ordering.
       Quad  is  stored  in front-left/front-right/rear-left/rear-right order. 5.1 is
       stored in front-left/front-right/center/low-freq/rear-left/rear-right ordering
       ("low-freq" is the ".1" speaker).

       The function prototype for callback is:

       ┌──────────────────────────────────────────┐
       │ void SDL_AudioCallback(void*  userdata,  │
       │                       Uint8* stream,     │
       │                       int len)           │
       └──────────────────────────────────────────┘
       where its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ an  application-specific pa‐ │
       │           │ rameter saved in the SDL_Au‐ │
       │           │ dioSpec structure's userdata │
       │           │ field.                       │
       ├───────────┼──────────────────────────────┤
       │ stream    │ a pointer to the audio  data │
       │           │ buffer  filled in by SDL_Au‐ │
       │           │ dioCallback()                │
       ├───────────┼──────────────────────────────┤
       │ len       │ the length of that buffer in │
       │           │ bytes                        │
       └───────────┴──────────────────────────────┘
       Once  the callback returns, the buffer will no longer be valid. Stereo samples
       are stored in a LRLRLR ordering.

       The callback must completely initialize the buffer; as of SDL 2.0, this buffer
       is not initialized before the callback is called. If there is nothing to play,
       the callback should fill the buffer with silence.

       With SDL >= 2.0.4 you can choose to avoid callbacks and  use  SDL_QueueAudio()
       instead, if you like. Just open your audio device with a NULL callback.

RELATED FUNCTIONS
       SDL_LoadWAV
       SDL_LoadWAV_RW
       SDL_OpenAudioDevice

===============================================================================
                                                              *SDL_AudioStatus*


NAME
       SDL_AudioStatus -- Enumerations

SYNOPSIS
       An enumeration of audio device status.

DESCRIPTION
       Values

       ┌────────────────────┬───────────────────────────┐
       │ SDL_AUDIO_STOPPED  │  audio device is stopped  │
       ├────────────────────┼───────────────────────────┤
       │ SDL_AUDIO_PLAYING  │  audio device is playing  │
       ├────────────────────┼───────────────────────────┤
       │ SDL_AUDIO_PAUSED   │  audio device is paused   │
       └────────────────────┴───────────────────────────┘

CODE EXAMPLES
       void printStatus(SDL_AudioDeviceID dev)
       {
           switch (SDL_GetAudioDeviceStatus(dev))
           {
               case SDL_AUDIO_STOPPED: printf("stopped\n"); break;
               case SDL_AUDIO_PLAYING: printf("playing\n"); break;
               case SDL_AUDIO_PUSED: printf("paused\n"); break;
               default: printf("???"); break;
           }
       }

       // device status paused
       SDL_AudioDeviceID dev;
       dev = SDL_OpenAudioDevice(NULL, 0, &desired, &obtained, 0);
       if (dev != 0)
       {
           printStatus(dev);    // prints "paused"
           SDL_PauseAudioDevice(dev, 0);
           printStatus(dev);    // prints "playing"
           SDL_PauseAudioDevice(dev, 1);
           printStatus(dev);    // prints "paused"
           SDL_CloseAudioDevice(dev);
           printStatus(dev);    // prints "stopped"
       }

REMARKS
       Opened devices are always PLAYING or PAUSED in normal circumstances. A failing
       device may change its status to STOPPED at any time, and closing a device will
       progress  to  STOPPED, too. Asking for the state on an unopened or unknown de‐
       vice ID will report STOPPED.

RELATED FUNCTIONS
       SDL_GetAudioDeviceStatus

===============================================================================
                                                              *SDL_AudioStream*


NAME
       SDL_AudioStream -- Structure

SYNOPSIS
       An  opaque  structure that buffers, converts, resamples, and generally streams
       audio data.

REMARKS
       The SDL_AudioStream structure is used to convert audio data between  different
       formats  in  arbitrarily-sized blocks. It is meant to be a replacement for the
       SDL_AudioCVT-related interfaces.

       A   tutorial   on   using   audio   stream   is    at    Tutorials/AudioStream
       (https://wiki.libsdl.org/Tutorials/AudioStream).

       (this page should be fleshed out more, too).

RELATED FUNCTIONS
       SDL_NewAudioStream
       SDL_AudioStreamPut
       SDL_AudioStreamAvailable
       SDL_AudioStreamGet
       SDL_AudioStreamFlush
       SDL_AudioStreamClear
       SDL_FreeAudioStream

===============================================================================
                                                              *SDL_BlendFactor*


NAME
       SDL_BlendFactor -- Enumerations

SYNOPSIS
       An  enumeration  of  blend factors used when creating a custom blend mode with
       SDL_ComposeCustomBlendMode().

DESCRIPTION
       Values

       ┌──────────────────────────────────────┬──────────────────────────────────┐
       │ SDL_BLENDFACTOR_ZERO                 │  0, 0, 0, 0                      │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_ONE                  │  1, 1, 1, 1                      │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_SRC_COLOR            │  srcR, srcG, srcB, srcA          │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR  │  1-srcR, 1-srcG, 1-srcB, 1-srcA  │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_SRC_ALPHA            │  srcA, srcA, srcA, srcA          │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA  │  1-srcA, 1-srcA, 1-srcA, 1-srcA  │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_DST_COLOR            │  dstR, dstG, dstB, dstA          │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR  │  1-dstR, 1-dstG, 1-dstB, 1-dstA  │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_DST_ALPHA            │  dstA, dstA, dstA, dstA          │
       ├──────────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA  │  1-dstA, 1-dstA, 1-dstA, 1-dstA  │
       └──────────────────────────────────────┴──────────────────────────────────┘

REMARKS
       The blend factors are multiplied with the  pixels  from  a  drawing  operation
       (src)  and the pixels from the render target (dst) before the blend operation.
       The comma-separated factors listed above are always applied in  the  component
       order red, green, blue, and alpha.

       Some  renderers  may not support all factors. See SDL_ComposeCustomBlendMode()
       for a list of what the current renderers support.

VERSION
       This enumeration is available since SDL 2.0.6

RELATED ENUMERATIONS
       SDL_BlendOperation

RELATED FUNCTIONS
       SDL_ComposeCustomBlendMode,  SDL_SetRenderDrawBlendMode,  SDL_SetTextureBlend‐
       Mode

===============================================================================
                                                                *SDL_BlendMode*


NAME
       SDL_BlendMode -- Enumerations

SYNOPSIS
       An enumeration of blend modes used in SDL_RenderCopy() and drawing operations.

DESCRIPTION
       Values

       ┌──────────────────────┬──────────────────────────────────────────────────┐
       │ SDL_BLENDMODE_NONE   │  no blending                                     │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │  dstRGBA = srcRGBA                               │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_BLEND  │  alpha blending                                  │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │  dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))  │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │  dstA = srcA + (dstA * (1-srcA))                 │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_ADD    │  additive blending                               │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │  dstRGB = (srcRGB * srcA) + dstRGB               │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │  dstA = dstA                                     │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_MOD    │  color modulate                                  │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │  dstRGB = srcRGB * dstRGB                        │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │  dstA = dstA                                     │
       └──────────────────────┴──────────────────────────────────────────────────┘

RELATED STRUCTURES
       SDL_RenderInfo

RELATED FUNCTIONS
       SDL_GetRenderDrawBlendMode,  SDL_GetSurfaceBlendMode, SDL_GetTextureBlendMode,
       SDL_RenderCopy, SDL_SetRenderDrawBlendMode, SDL_SetSurfaceBlendMode,  SDL_Set‐
       TextureBlendMode

===============================================================================
                                                           *SDL_BlendOperation*


NAME
       SDL_BlendOperation -- Enumerations

SYNOPSIS
       An enumeration of blend operations used when creating a custom blend mode with
       SDL_ComposeCustomBlendMode().

DESCRIPTION
       Values

       ┌──────────────────────────────────┬──────────────────────────────────┐
       │ SDL_BLENDOPERATION_ADD           │  additive operation              │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │                                  │  dst + src                       │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDOPERATION_SUBTRACT      │  subtractive operation           │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │                                  │  dst - src                       │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDOPERATION_REV_SUBTRACT  │  reversed subtractive operation  │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │                                  │  src - dst                       │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDOPERATION_MINIMUM       │  minimum operation               │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │                                  │  min(dst, src)                   │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │ SDL_BLENDOPERATION_MAXIMUM       │  maximum operation               │
       ├──────────────────────────────────┼──────────────────────────────────┤
       │                                  │  max(dst, src)                   │
       └──────────────────────────────────┴──────────────────────────────────┘

REMARKS
       The blend operation takes place when the calculated pixels from a drawing  op‐
       eration  (src)  and the pixels from the render target (dst) get combined. Each
       component (red, green, blue, and alpha) is calcuated separately. The result is
       then stored in the render target.

       Some  renderers  may  not  support all operations. See SDL_ComposeCustomBlend‐
       Mode() for a list of what the current renderers support.

VERSION
       This enumeration is available since SDL 2.0.6.

RELATED ENUMERATIONS
       SDL_BlendFactor

RELATED FUNCTIONS
       SDL_ComposeCustomBlendMode,  SDL_SetRenderDrawBlendMode,  SDL_SetTextureBlend‐
       Mode

===============================================================================
                                                               *SDL_BlitScaled*


NAME
       SDL_BlitScaled -- Function

SYNOPSIS
       Use this function to perform a scaled surface copy to a destination surface.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ int SDL_BlitScaled(SDL_Surface*    src,      │
       │                    const SDL_Rect* srcrect,  │
       │                    SDL_Surface*    dst,      │
       │                    SDL_Rect*       dstrect)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ src      │ the SDL_Surface structure to │
       │          │ be copied from               │
       ├──────────┼──────────────────────────────┤
       │ srcrect  │ the SDL_Rect structure  rep‐ │
       │          │ resenting  the  rectangle to │
       │          │ be copied, or NULL  to  copy │
       │          │ the entire surface           │
       ├──────────┼──────────────────────────────┤
       │ dst      │ the   SDL_Surface  structure │
       │          │ that is the blit target      │
       ├──────────┼──────────────────────────────┤
       │ dstrect  │ the SDL_Rect structure  rep‐ │
       │          │ resenting the rectangle that │
       │          │ is copied into, or  NULL  to │
       │          │ copy into the entire surface │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       This   is   the   public   scaled   blit   funciton.   This   function   calls
       SDL_LowerBlitScaled() internally.

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_LowerBlitScaled

===============================================================================
                                                              *SDL_BlitSurface*


NAME
       SDL_BlitSurface -- Function

SYNOPSIS
       Use this function to perform a fast surface copy to a destination surface.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_BlitSurface(SDL_Surface*    src,      │
       │                     const SDL_Rect* srcrect,  │
       │                     SDL_Surface*    dst,      │
       │                     SDL_Rect*       dstrect)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ src      │ the SDL_Surface structure to │
       │          │ be copied from               │
       ├──────────┼──────────────────────────────┤
       │ srcrect  │ the SDL_Rect structure  rep‐ │
       │          │ resenting  the  rectangle to │
       │          │ be copied, or NULL  to  copy │
       │          │ the entire surface           │
       ├──────────┼──────────────────────────────┤
       │ dst      │ the   SDL_Surface  structure │
       │          │ that is the blit target      │
       ├──────────┼──────────────────────────────┤
       │ dstrect  │ the SDL_Rect structure  rep‐ │
       │          │ resenting the rectangle that │
       │          │ is copied into, or  NULL  to │
       │          │ copy into the entire surface │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 if the blit is successful or a negative error code on failure; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────┐
       │ SDL_BlitSurface(surface, &source_rect, temp_surface, NULL)  │
       └─────────────────────────────────────────────────────────────┘

REMARKS
       You should call SDL_BlitSurface() unless you know  exactly  how  SDL  blitting
       works internally and how to use the other blit functions.

       This  is  the  public  blit function, and it performs rectangle validation and
       clipping before passing it to SDL_LowerBlit().

       The blit function should not be called on a locked surface.

       The width and height in srcrect determine the size of  the  copied  rectangle.
       Only  the  position is used in the dstrect (the width and height are ignored).
       Blits with negative dstrect coordinates will be clipped properly.

       If srcrect is NULL, the entire surface is copied. If dstrect is NULL, then the
       destination position (upper left corner) is (0, 0).

       The  final  blit rectangle is saved in dstrect after all clipping is performed
       (srcrect is not modified).

       The blit semantics for surfaces with and without blending and colorkey are de‐
       fined as follows.

   RGBA->RGB:
       Source surface blend mode set to SDL_BLENDMODE_BLEND:

              alpha-blend  (using  the  source  alpha-channel  and per-surface alpha)
              SDL_SRCCOLORKEY ignored.

       Source surface blend mode set to SDL_BLENDMODE_NONE:

              copy RGB. if SDL_SRCCOLORKEY set, only copy the pixels matching the RGB
              values of the source color key, ignoring alpha in the comparison.

   RGB->RGBA:
       Source surface blend mode set to SDL_BLENDMODE_BLEND:

              alpha-blend (using the source per-surface alpha)

       Source surface blend mode set to SDL_BLENDMODE_NONE:

              copy RGB, set destination alpha to source per-surface alpha value.

       both:

              if  SDL_SRCCOLORKEY set, only copy the pixels matching the source color
              key.

   RGBA->RGBA:
       Source surface blend mode set to SDL_BLENDMODE_BLEND:

              alpha-blend (using the  source  alpha-channel  and  per-surface  alpha)
              SDL_SRCCOLORKEY ignroed.

       Source surface blend mode set to SDL_BLENDMODE_NONE:

              copy  all of RGBA to the destination. If SDL_SRCCOLORKEY set, only copy
              the pixels matching the RGB values of the source  color  key,  ignoring
              alpha in the comparison.

   RGB->RGB:
       Source surface blend mode set to SDL_BLENDMODE_BLEND:

              alpha-blend (using the source per-surface alpha)

       Source surface blend mode set to SDL_BLENDMODE_NONE:

              copy RGB.

       both:

              if  SDL_SRCCOLORKEY set, only copy the pixels matching the source color
              key.

RELATED FUNCTIONS
       SDL_BlitScaled
       SDL_LowerBlit

===============================================================================
                                                            *SDL_BuildAudioCVT*


NAME
       SDL_BuildAudioCVT -- Function

SYNOPSIS
       Use this function to initialize an SDL_AudioCVT structure for conversion.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_BuildAudioCVT(SDL_AudioCVT*   cvt,           │
       │                       SDL_AudioFormat src_format,    │
       │                       Uint8           src_channels,  │
       │                       int             src_rate,      │
       │                       SDL_AudioFormat dst_format,    │
       │                       Uint8           dst_channels,  │
       │                       int             dst_rate)      │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ cvt           │ an   SDL_AudioCVT  structure │
       │               │ filled in with audio conver‐ │
       │               │ sion information             │
       ├───────────────┼──────────────────────────────┤
       │ src_format    │ the source format of the au‐ │
       │               │ dio data; for more info  see │
       │               │ SDL_AudioFormat              │
       ├───────────────┼──────────────────────────────┤
       │ src_channels  │ the  number  of  channels in │
       │               │ the source                   │
       ├───────────────┼──────────────────────────────┤
       │ src_rate      │ the   frequency    (samples- │
       │               │ frames-per-second)   of  the │
       │               │ source                       │
       ├───────────────┼──────────────────────────────┤
       │ dst_format    │ the  destination  format  of │
       │               │ the  audio  data;  for  more │
       │               │ info see SDL_AudioFormat     │
       ├───────────────┼──────────────────────────────┤
       │ dst_channels  │ the number  of  channels  in │
       │               │ the destination              │
       ├───────────────┼──────────────────────────────┤
       │ dst_rate      │ the    frequency   (samples- │
       │               │ frames-per-second)  of   the │
       │               │ destination                  │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  1 if the audio filter is prepared, 0 if no conversion is needed, or a
       negative error code on failure; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────┐
       │ // Change 1024 stereo sample frames at 48000Hz from float32 to int16  │
       │ SDL_AudioCVT cvt;                                                     │
       │ SDL_BuildAudioCVT(&cvt, AUDIO_F32, 2, 48000, AUDIO_S16, 2, 48000);    │
       │ SDL_assert(cvt.needed);  // obviously, this one is always needed      │
       │ cvt.len = 1024 * 2 * 4;  // 1024 stereo float32 sample frames.        │
       │ cvt.buf = (Uint8 *)SDL_malloc(cvt.len * cvt.len_mult);                │
       │ // read your float32 data into cvt.buf here.                          │
       │ SDL_ConvertAudio(&cvt);                                               │
       │ // cvt.buf has cvt.len_cvt bytes of converted data now.               │
       └───────────────────────────────────────────────────────────────────────┘

REMARKS
       Before an SDL_AudioCVT structure can be used to convert audio data it must  be
       initialized with source and destination information.

       This  function  will  zero  out every field of the SDL_AudioCVT, so it must be
       called before the application fills in the final buffer information.

       Once this function has returned successfully, and reported that  a  conversion
       is necessary, the application fills in the rest of the fields in SDL_AudioCVT,
       now that it knows how large a buffer if needs to allocate, and then  can  call
       SDL_ConvertAudio() to complete the conversion.

RELATED FUNCTIONS
       SDL_ConvertAudio

===============================================================================
                                                                       *SDL_CD*


NAME
       SDL_CD - CDROM Drive Information

STRUCTURE DEFINITION
       typedef struct{
         int id;
         CDstatus status;
         int numtracks;
         int cur_track;
         int cur_frame;
         SDL_CDtrack track[SDL_MAX_TRACKS+1];
       } SDL_CD;

STRUCTURE DATA
       id                  Private drive identifier

       status              Drive status

       numtracks           Number of tracks on the CD

       cur_track           Current track

       cur_frame           Current frame offset within the track

       track[SDL_MAX_TRACKS+1]
                           Array of track descriptions. (see SDL_CDtrack)

DESCRIPTION
       An  SDL_CD  structure is returned by SDL_CDOpen. It represents an opened CDROM
       device and stores information on the layout of the tracks on the disc.

       A frame is the base data unit of a CD. CD_FPS frames is equal to 1  second  of
       music.  SDL  provides  two  macros  for  converting  between  time and frames:
       FRAMES_TO_MSF(f, M,S,F) and MSF_TO_FRAMES.

EXAMPLES
       int min, sec, frame;
       int frame_offset;

       FRAMES_TO_MSF(cdrom->cur_frame, &min, &sec, &frame);
       printf("Current Position: %d minutes, %d seconds, %d frames
       ", min, sec, frame);

       frame_offset=MSF_TO_FRAMES(min, sec, frame);

SEE ALSO
       SDL_CDOpen, SDL_CDtrack

===============================================================================
                                                                  *SDL_CDClose*


NAME
       SDL_CDClose - Closes a SDL_CD handle

SYNOPSIS
       #include "SDL.h"

       void SDL_CDClose(SDL_CD *cdrom);

DESCRIPTION
       Closes the given cdrom handle.

SEE ALSO
       SDL_CDOpen, SDL_CD

===============================================================================
                                                                  *SDL_CDEject*


NAME
       SDL_CDEject - Ejects a CDROM

SYNOPSIS
       #include "SDL.h"

       int SDL_CDEject(SDL_CD *cdrom);

DESCRIPTION
       Ejects the given cdrom.

RETURN VALUE
       Returns 0 on success, or -1 on an error.

SEE ALSO
       SDL_CD

===============================================================================
                                                                   *SDL_CDName*


NAME
       SDL_CDName - Returns a human-readable, system-dependent identifier for the CD-
       ROM.

SYNOPSIS
       #include "SDL.h"

       const char *SDL_CDName(int drive);

DESCRIPTION
       Returns a human-readable, system-dependent identifier for the CD-ROM. drive is
       the  index  of  the  drive.  Drive  indices  start  to 0 and end at SDL_CDNum‐
       Drives()-1.

EXAMPLES
          •  "/dev/cdrom"

          •  "E:"

          •  "/dev/disk/ide/1/master"

SEE ALSO
       SDL_CDNumDrives

===============================================================================
                                                              *SDL_CDNumDrives*


NAME
       SDL_CDNumDrives - Returns the number of CD-ROM drives on the system.

SYNOPSIS
       #include "SDL.h"

       int SDL_CDNumDrives(void)

DESCRIPTION
       Returns the number of CD-ROM drives on the system.

SEE ALSO
       SDL_CDOpen

===============================================================================
                                                                   *SDL_CDOpen*


NAME
       SDL_CDOpen - Opens a CD-ROM drive for access.

SYNOPSIS
       #include "SDL.h"

       SDL_CD *SDL_CDOpen(int drive);

DESCRIPTION
       Opens  a CD-ROM drive for access. It returns a SDL_CD structure on success, or
       NULL if the drive was invalid or busy. This newly opened  CD-ROM  becomes  the
       default CD used when other CD functions are passed a NULL CD-ROM handle.

       Drives are numbered starting with 0. Drive 0 is the system default CD-ROM.

EXAMPLES
       SDL_CD *cdrom;
       int cur_track;
       int min, sec, frame;
       SDL_Init(SDL_INIT_CDROM);
       atexit(SDL_Quit);

       /* Check for CD drives */
       if(!SDL_CDNumDrives()){
         /* None found */
         fprintf(stderr, "No CDROM devices available
       ");
         exit(-1);
       }

       /* Open the default drive */
       cdrom=SDL_CDOpen(0);

       /* Did if open? Check if cdrom is NULL */
       if(!cdrom){
         fprintf(stderr, "Couldn't open drive: %s
       ", SDL_GetError());
         exit(-1);
       }

       /* Print Volume info */
       printf("Name: %s
       ", SDL_CDName(0));
       printf("Tracks: %d
       ", cdrom->numtracks);
       for(cur_track=0;cur_track < cdrom->numtracks; cur_track++){
         FRAMES_TO_MSF(cdrom->track[cur_track].length, &min, &sec, &frame);
         printf("     Track %d: Length %d:%d
       ", cur_track, min, sec);
       }

       SDL_CDClose(cdrom);

SEE ALSO
       SDL_CD, SDL_CDtrack, SDL_CDClose

===============================================================================
                                                                  *SDL_CDPause*


NAME
       SDL_CDPause - Pauses a CDROM

SYNOPSIS
       #include "SDL.h"

       int SDL_CDPause(SDL_CD *cdrom);

DESCRIPTION
       Pauses play on the given cdrom.

RETURN VALUE
       Returns 0 on success, or -1 on an error.

SEE ALSO
       SDL_CDPlay, SDL_CDResume

===============================================================================
                                                                   *SDL_CDPlay*


NAME
       SDL_CDPlay - Play a CD

SYNOPSIS
       #include "SDL.h"

       int SDL_CDPlay(SDL_CD *cdrom, int start, int length);

DESCRIPTION
       Plays the given cdrom, starting a frame start for length frames.

RETURN VALUES
       Returns 0 on success, or -1 on an error.

SEE ALSO
       SDL_CDPlayTracks, SDL_CDStop

===============================================================================
                                                             *SDL_CDPlayTracks*


NAME
       SDL_CDPlayTracks - Play the given CD track(s)

SYNOPSIS
       #include "SDL.h"

       int  SDL_CDPlayTracks(SDL_CD  *cdrom,  int  start_track,  int start_frame, int
       ntracks, int nframes));

DESCRIPTION
       SDL_CDPlayTracks plays the given CD starting at track start_track, for ntracks
       tracks.

       start_frame  is  the  frame  offset, from the beginning of the start_track, at
       which to start. nframes is the frame offset, from the beginning  of  the  last
       track (start_track+ntracks), at which to end playing.

       SDL_CDPlayTracks should only be called after calling SDL_CDStatus to get track
       information about the CD.

              Note:

              Data tracks are ignored.

RETURN VALUE
       Returns 0, or -1 if there was an error.

EXAMPLES
       /* assuming cdrom is a previously opened device */
       /* Play the entire CD */
       if(CD_INDRIVE(SDL_CDStatus(cdrom)))
         SDL_CDPlayTracks(cdrom, 0, 0, 0, 0);

       /* Play the first track */
       if(CD_INDRIVE(SDL_CDStatus(cdrom)))
         SDL_CDPlayTracks(cdrom, 0, 0, 1, 0);

       /* Play first 15 seconds of the 2nd track */
       if(CD_INDRIVE(SDL_CDStatus(cdrom)))
         SDL_CDPlayTracks(cdrom, 1, 0, 0, CD_FPS*15);

SEE ALSO
       SDL_CDPlay, SDL_CDStatus, SDL_CD

===============================================================================
                                                                 *SDL_CDResume*


NAME
       SDL_CDResume - Resumes a CDROM

SYNOPSIS
       #include "SDL.h"

       int SDL_CDResume(SDL_CD *cdrom);

DESCRIPTION
       Resumes play on the given cdrom.

RETURN VALUE
       Returns 0 on success, or -1 on an error.

SEE ALSO
       SDL_CDPlay, SDL_CDPause

===============================================================================
                                                                 *SDL_CDStatus*


NAME
       SDL_CDStatus - Returns the current status of the given drive.

SYNOPSIS
       #include "SDL.h"

       CDstatus  SDL_CDStatus(SDL_CD  *cdrom);  /*  Given  a  status, returns true if
       there's a disk in the drive */ #define CD_INDRIVE(status)      ((int)status  >
       0)

DESCRIPTION
       This  function  returns  the  current status of the given drive. Status is de‐
       scribed like so:

       typedef enum {
         CD_TRAYEMPTY,
         CD_STOPPED,
         CD_PLAYING,
         CD_PAUSED,
         CD_ERROR = -1
       } CDstatus;

       If the drive has a CD in it, the table of contents of the CD and current  play
       position of the CD will be stored in the SDL_CD structure.

       The  macro  CD_INDRIVE is provided for convenience, and given a status returns
       true if there's a disk in the drive.

              Note:

              SDL_CDStatus also updates the SDL_CD structure passed to it.

EXAMPLE
       int playTrack(int track)
       {
         int playing = 0;

         if ( CD_INDRIVE(SDL_CDStatus(cdrom)) ) {
         /* clamp to the actual number of tracks on the CD */
           if (track >= cdrom->numtracks) {
             track = cdrom->numtracks-1;
           }

           if ( SDL_CDPlayTracks(cdrom, track, 0, 1, 0) == 0 ) {
             playing = 1;
           }
         }
         return playing;
       }

SEE ALSO
       SDL_CD

===============================================================================
                                                                   *SDL_CDStop*


NAME
       SDL_CDStop - Stops a CDROM

SYNOPSIS
       #include "SDL.h"

       int SDL_CDStop(SDL_CD *cdrom);

DESCRIPTION
       Stops play on the given cdrom.

RETURN VALUE
       Returns 0 on success, or -1 on an error.

SEE ALSO
       SDL_CDPlay,

===============================================================================
                                                                  *SDL_CDtrack*


NAME
       SDL_CDtrack - CD Track Information Structure

STRUCTURE DEFINITION
       typedef struct{
         Uint8 id;
         Uint8 type;
         Uint32 length;
         Uint32 offset;
       } SDL_CDtrack;

STRUCTURE DATA
       id                  Track number (0-99)

       type                SDL_AUDIO_TRACK or SDL_DATA_TRACK

       length              Length, in frames, of this track

       offset              Frame offset to the beginning of this track

DESCRIPTION
       SDL_CDtrack  stores  data  on  each track on a CD, its fields should be pretty
       self explainatory. It is a member a the SDL_CD structure.

              Note:

              Frames can be converted to standard timings. There  are  CD_FPS  frames
              per second, so SDL_CDtrack.length/CD_FPS=length_in_seconds.

SEE ALSO
       SDL_CD

===============================================================================
                                                          *SDL_COMPILEDVERSION*


NAME
       SDL_COMPILEDVERSION -- Macro

SYNOPSIS
       Use this macro to get the SDL version number that you compiled against.

SYNTAX
       ┌──────────────────────┐
       │ SDL_COMPILEDVERSION  │
       └──────────────────────┘

RELATED MACROS
       SDL_VERSIONNUM

===============================================================================
                                                       *SDL_CalculateGammaRamp*


NAME
       SDL_CalculateGammaRamp -- Function

SYNOPSIS
       Use this function to calculate a 256 entry gamma ramp for a gamma value.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ void SDL_CalculateGammaRamp(float   gamma,  │
       │                             Uint16* ramp)   │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ gamma  │ a  gamma  value where 0.0 is │
       │        │ black and 1.0 is identity    │
       ├────────┼──────────────────────────────┤
       │ ramp   │ an  array  of   256   values │
       │        │ filled  in  with  the  gamma │
       │        │ ramp                         │
       └────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_SetWindowGammaRamp

===============================================================================
                                                             *SDL_CaptureMouse*


NAME
       SDL_CaptureMouse -- Function

SYNOPSIS
       Use this function to capture the mouse and to track input outside and SDL win‐
       dow.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ int SDL_CaptureMouse(SDL_bool enabled)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ enabled  │ whether  or  not  to  enable │
       │          │ capturing                    │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or -1 if not supported; call SDL_GetError() for more in‐
       formation.

REMARKS
       Capturing enables your app to obtain mouse events globally,  instead  of  just
       within your window. Not all video targets support this function.  When captur‐
       ing is enabled, the current window will get all mouse events, but unlike rela‐
       tive  mode,  no  change is made to the cursor and it is not restrained to your
       window.

       This function may also deny mouse input to other windows--both those  in  your
       application  and  others  on the system--so you should use this function spar‐
       ingly, and in small bursts.  For example, you might want to  track  the  mouse
       while  the user is dragging something, until the user releases a mouse button.
       It is not recommended that you capture the mouse for  long  periods  of  time,
       such as the entire time your app is running.

       While  captured, mouse events still report coordinates relative to the current
       (foreground) window, but those coordinates may be outside the  bounds  of  the
       window  (including  negative  values). Capturing is only allowed for the fore‐
       ground window. If the window loses focus while capturing, the capture will  be
       disabled automatically.

       While  capturing  is  enabled,  the  current  window  will  have  the SDL_WIN‐
       DOW_MOUSE_CAPTURE flag set.

VERSION
       This function is available since SDL 2.0.4.

RELATED FUNCTIONS
       SDL_GetGlobalMouseState

===============================================================================
                                                               *SDL_ClearError*


NAME
       SDL_ClearError -- Function

SYNOPSIS
       Use this function to clear any previous error message.

SYNTAX
       ┌────────────────────────────┐
       │ void SDL_ClearError(void)  │
       └────────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────┐
       │ const char *error = SDL_GetError();  │
       │ if (*error) {                        │
       │   SDL_Log("SDL error: %s", error);   │
       │   SDL_ClearError();                  │
       │ }                                    │
       └──────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetError
       SDL_SetError

===============================================================================
                                                               *SDL_ClearHints*


NAME
       SDL_ClearHints -- Function

SYNOPSIS
       Use this function to clear all hints.

SYNTAX
       ┌────────────────────────────┐
       │ void SDL_ClearHints(void)  │
       └────────────────────────────┘

REMARKS
       This function is automatically called during SDL_Quit().

===============================================================================
                                                         *SDL_ClearQueuedAudio*


NAME
       SDL_ClearQueuedAudio -- Function

SYNOPSIS
       Use  this  function  to  drop  any queued audio data waiting to be sent to the
       hardware.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ void SDL_ClearQueuedAudio(SDL_AudioDeviceID dev)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ dev  │ the device ID  of  which  to │
       │      │ clear the audio queue        │
       └──────┴──────────────────────────────┘

REMARKS
       Immediately  after  this  call, SDL_GetQueuedAudioSize() will return 0 and the
       hardware will start playing silence if more audio isn't queued.

       This will not prevent playback of queued audio that's already been sent to the
       hardware,  as  we  cannot  undo that, so expect there to be some fraction of a
       second of audio that might still be heard. This can be useful if you want  to,
       say, drop any pending music during a level change in your game.

       You  may  not  queue  audio  on a device that is using an application-supplied
       callback; calling this function on such a device is always a no-op.  You  have
       to use the audio callback or queue audio with SDL_QueueAudio(), but not both.

       You  should  not call SDL_LockAudio() on the device before clearing the queue;
       SDL handles locking internally for this function.

       This function always succeeds and thus returns void.

VERSION
       This function is available since SDL 2.0.4.

RELATED FUNCTIONS
       SDL_GetQueuedAudioSize
       SDL_QueueAudio

===============================================================================
                                                               *SDL_CloseAudio*


NAME
       SDL_CloseAudio -- Function

SYNOPSIS
       This  function  is  a  legacy  means of closing the audio device. New programs
       might want to use SDL_CloseAudioDevice() instead.

SYNTAX
       ┌────────────────────────────┐
       │ void SDL_CloseAudio(void)  │
       └────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────┐
       │ extern SDL_AudioSpec want;                                    │
       │ if (SDL_OpenAudio(&want, NULL) == 0) {                        │
       │   SDL_PauseAudio(0);                                          │
       │   SDL_Delay(5000);  // let audio callback run for 5 seconds.  │
       │   SDL_CloseAudio();                                           │
       │ }                                                             │
       └───────────────────────────────────────────────────────────────┘

REMARKS
       This function is equivalent to calling

       ┌───────────────────────────┐
       │ SDL_CloseAudioDevice(1);  │
       └───────────────────────────┘
       and is only useful if you used the legacy SDL_OpenAudio() function.

RELATED FUNCTIONS
       SDL_OpenAudio

===============================================================================
                                                         *SDL_CloseAudioDevice*


NAME
       SDL_CloseAudioDevice -- Function

SYNOPSIS
       Use this function to shutdown audio processing and close the audio device.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ void SDL_CloseAudioDevice(SDL_AudioDeviceID dev)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────────────────────────────────────┐
       │ dev  │ an audio device previously opened with SDL_OpenAudioDevice() │
       └──────┴──────────────────────────────────────────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────┐
       │ extern SDL_AudioSpec want;                                               │
       │ SDL_AudioDeviceID devid = SDL_OpenAudioDevice(NULL, 0, &want, NULL, 0);  │
       │ if (devid > 0)                                                           │
       │ {                                                                        │
       │   SDL_PauseAudioDevice(devid, 0);                                        │
       │   SDL_Delay(5000);  // let audio callback run for 5 seconds              │
       │   SDL_CloseAudioDevice(devid);                                           │
       │ }                                                                        │
       └──────────────────────────────────────────────────────────────────────────┘

REMARKS
       The  application  should  close  open  audio  devices  once they are no longer
       needed. Calling this function will wait until the device's audio  callback  is
       not  running,  release the audio hardware and then clean up internal state. No
       further audio will play from this device once this function returns.

       The device ID is invalid as soon as the device is closed, and is eligible  for
       reuse in a new SDL_OpenAudioDevice() call immediately.

RELATED FUNCTIONS
       SDL_OpenAudioDevice

===============================================================================
                                                                    *SDL_Color*


NAME
       SDL_Color -- Structure

SYNOPSIS
       A structure that represents a color.

DATA FIELDS
       ┌────────┬───┬───────────────────────┐
       │ Uint8  │ r │ the  red component in │
       │        │   │ the range 0-255       │
       ├────────┼───┼───────────────────────┤
       │ Uint8  │ g │ the  green  component │
       │        │   │ in the range 0-255    │
       ├────────┼───┼───────────────────────┤
       │ Uint8  │ b │ the blue component in │
       │        │   │ the range 0-255       │
       ├────────┼───┼───────────────────────┤
       │ Uint8  │ a │ the  alpha  component │
       │        │   │ in the range 0-255    │
       └────────┴───┴───────────────────────┘

REMARKS
       SDL_Color and SDL_Colour are interchangeable.

       If you have RGB color values you would use decimal values in this struct.
               Examples: orange = 255, 165, 0 so set r=255, g=165, b=0, a=255.

       If you have HTML color codes you would use hexadecimal values in this struct.
               Examples: orange = #FFA500 so set r=0xFF, g=0xA5, b=0x00, a=0xFF.

       SDL_Color  describes  a  color in a format independent way. You can convert an
       SDL_Color to a pixel value for a certain pixel format using SDL_MapRGB().

RELATED STRUCTURES
       SDL_Palette

RELATED FUNCTIONS
       SDL_SetPaletteColors

===============================================================================
                                                          *SDL_CompilerBarrier*


NAME
       SDL_CompilerBarrier -- Function

SYNOPSIS
       Use  this function to prevent the compiler from reordering reads and writes to
       globally visible variable across the call.

SYNTAX
       ┌─────────────────────────────────┐
       │ void SDL_CompilerBarrier(void)  │
       └─────────────────────────────────┘

REMARKS
       This function only prevents the compiler from reodering reads and  writes,  it
       does not prevent the CPU from reordering reads and writes. However, all of the
       atomic operations that modify memory. However, all of  the  atomic  operations
       that modify memory are full memory barriers.

       This function is used in SDL_AtomicGet() and SDL_AtomicGetPtr().

RELATED FUNCTIONS
       SDL_AtomicGet
       SDL_AtomicGetPtr

===============================================================================
                                                   *SDL_ComposeCustomBlendMode*


NAME
       SDL_ComposeCustomBlendMode -- Function

SYNOPSIS
       Use this function to compose a custom blend mode for renderers.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor, SDL_BlendFactor dstColorFactor, SDL_BlendOperation colorOperation, SDL_BlendFactor srcAlphaFactor, SDL_BlendFactor dstAlphaFactor, SDL_BlendOperation alphaOperation)  │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ srcColorFactor  │ the SDL_BlendFactor applied to the red, green and blue components of the source pixels                          │
       ├─────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ dstColorFactor  │ the SDL_BlendFactor appli3d to the red, green, and blue components of the destination pixels                    │
       ├─────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ colorOperation  │ the DL_BlendOperation used to combined the red, green, and blue components of the source and destination pixels │
       ├─────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ srcAlphaFactor  │ the DL_BlendFactor applied to the alpha component of the source pixels                                          │
       ├─────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ dstAlphaFactor  │ the SDL_BlendFactor applied to the alpha component of the destination pixels                                    │
       ├─────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ alphaOperation  │  the SDL_BlendOperation used to combine the alpha component of the source and destination pixels                │
       └─────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns and SDL_BlendMode tha represents the chosen factors and operations.

REMARKS
       The  functions  SDL_SetRenderDrawBlendMode  and SDL_SetTextureBlendMode accept
       the SDL_BlendMode returned by this function if the renderer supports it.

       A blend mode controls how the pixels from a  drawing  operation  (source)  get
       combined with the pixels from the render target (destination). First, the com‐
       ponents of the source and destination pixerls get multiplied with their  blend
       factor. Then, the blend operation takes the two products and calcuates the re‐
       sult that will get stored in the render target.

       Expressed in pseudocode, it would look like this:

       ┌────────────────────────────────────────────────────────────────────────────┐
       │ dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor)  │
       │ dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor)        │
       └────────────────────────────────────────────────────────────────────────────┘

       Where the functions colorOperations(src, dst) and alphaOperation(src, dst) can
       return  on  of  the following: src + dst, src - dst, dst - src, min(src, dst),
       max(src, dst).

       The red, green, and blue components are always multiplied with the first, sec‐
       ond,  and  theird  components of the SDL_BlendFactor, respectively. The fourth
       component is not used.

       The alpha component is always multiplied with  the  fourth  component  of  the
       SDL_BlendFactor. The other components are not usd in the alhpa calculation.

       Support for these blend modes varies for each renderer. To check if a specific
       SDL_BlendMode is supported, create a renderer and pass it  to  either  SDL_Se‐
       tRenderDrawBlendMode  or SDL_SetTextureBlendMode. They will return with an er‐
       ror if the blend mode is not supported.

       This list describes the support of the custom blend modes for each renderer in
       SDL2.0.6.  All renderers support the four blend modes listed in the SDL_Blend‐
       Mode enumeration.

       ┌─────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ direct3d    │  Supports SDL_BLENDOPERATION_ADD with all factors.                                                                                                          │
       ├─────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ direct3d11  │  Supports all operations with all factors. However, some factors produce unexpected results with SDL_BLENDOPERATION_MINIMUM and SDL_BLENDOPERATION_MAXIMUM. │
       ├─────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ opengl      │  Supports the SDL_BLENDOPERATION_ADD operation with all factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL2.0.6.                     │
       ├─────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ opengles    │  Supports the SDL_BLENDOPERATION_ADD operation with all factors. Color and alpha factors need to be the same. OpenGL ES 1 implementaiton specific           │
       ├─────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ opengles2   │  Supports the SDL_BLENDOPERATION_ADD, SDL_BLENDOPERATION_SUBTRACT, SDL_BLENDOPERATION_REV_SUBTRACT operations with all factors.                             │
       ├─────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ psp         │  No custom blend mode support                                                                                                                               │
       ├─────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
       │ software    │  No custom blend mode support                                                                                                                               │
       └─────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

       Some renderers do not provide an alpha component for the default  render  tar‐
       get.  The  SDL_BLENDFACTOR_DST_ALPHA  and  SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA
       factors do not have an effect in this case.

VERSION
       This function is available in SDL2.0.6.

RELATED FUNCTIONS
       SDL_SetRenderDrawBlendMode
       SDL_GetRenderDrawBlendMode
       SDL_SetTextureBlendMode
       SDL_GetTextureBlendMode

===============================================================================
                                                            *SDL_CondBroadcast*


NAME
       SDL_CondBroadcast -- Function

SYNOPSIS
       Use  this  function  to restarst all threads that are waiting on the condition
       variable.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ void SDL_CondBroadcast(SDL_cond* cond)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────────┐
       │ cond  │ the condition variable to signal │
       └───────┴──────────────────────────────────┘

RETURN VALUE
       Return 0 on success or a negative error code on failure;  call  SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌──────────────────────────────────┐
       │ SDL_bool condition = SDL_False;  │
       │ SDL_mutex* lock;                 │
       │ SDL_cond* cond;                  │
       │                                  │
       │ lock = SDL_CreateMutex();        │
       │ cond = SDL_CreateCond();         │
       │ Thread A:                        │
       │   SDL_LockMutex(lock);           │
       │   while (!condition)             │
       │   {                              │
       │     SDL_CondWait(cond, lock);    │
       │   }                              │
       │   SDL_UnlockMutex(lock);         │
       │                                  │
       │ Thread B:                        │
       │   SDL_LockMutex(lock);           │
       │   while (!condition)             │
       │   {                              │
       │     SDL_CondWait(cond, lock);    │
       │   }                              │
       │   SDL_UnlockMutex(lock);         │
       │                                  │
       │ Thread C:                        │
       │   SDL_LockMutex(lock);           │
       │   ...                            │
       │   condition = SDL_TRUE;          │
       │   ...                            │
       │   SDL_CondBroadcast(cond);       │
       │   SDL_UnlockMutex(lock);         │
       │ SDL_DestroyCond(cond);           │
       │ SDL_DestroyMutex(lock);          │
       └──────────────────────────────────┘

RELATED FUNCTIONS
       SDL_CondSignal
       SDL_CondWait
       SDL_CondWaitTimeout
       SDL_CreateCond
       SDL_DestroyCond

===============================================================================
                                                               *SDL_CondSignal*


NAME
       SDL_CondSignal -- Function

SYNOPSIS
       Use this function to restart one of the threads that are waiting on the condi‐
       tion variable.

SYNTAX
       ┌──────────────────────────────────────┐
       │ void SDL_CondSignal(SDL_cond* cond)  │
       └──────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────────┐
       │ cond  │ the condition variable to signal │
       └───────┴──────────────────────────────────┘

REMARKS
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       Typical use of condition variables:

       ┌──────────────────────────────────┐
       │ SDL_bool condition = SDL_FALSE;  │
       │ SDL_mutex* lock;                 │
       │ SDL_cond* cond;                  │
       │                                  │
       │ lock = SDL_CreateMutex();        │
       │ cond = SDL_CreateCond();         │
       │ Thread A:                        │
       │   SDL_LockMutex(lock);           │
       │   while (!condition)             │
       │   {                              │
       │     SDL_CondWait(cond, lock);    │
       │   }                              │
       │   SDL_UnlockMutex(lock);         │
       │                                  │
       │ Thread B:                        │
       │   SDL_LockMutex(lock);           │
       │   ...                            │
       │   condition = SDL_TRUE;          │
       │   ...                            │
       │   SDL_CondSignal(cond);          │
       │   SDL_UnlockMutex(lock);         │
       │ SDL_DestroyCond(cond);           │
       │ SDL_DestoryMutex(lock);          │
       └──────────────────────────────────┘

RELATED FUNCTIONS
       SDL_CondBroadcast
       SDL_CondWait
       SDL_CondWaitTimeout
       SDL_CreateCond
       SDL_DestroyCond

===============================================================================
                                                                 *SDL_CondWait*


NAME
       SDL_CondWait -- Function

SYNOPSIS
       Use this function to wait until a condition variable is signaled.

SYNTAX
       ┌──────────────────────────────────────┐
       │ void SDL_CondWait(SDL_cond* cond,    │
       │                   SDL_mutex* mutex)  │
       └──────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬────────────────────────────────────────────┐
       │ cond   │ the condition variable to wait on          │
       ├────────┼────────────────────────────────────────────┤
       │ mutex  │ the mutex used to coordinate thread access │
       └────────┴────────────────────────────────────────────┘

RETURN VALUE
       Returns  0  when  it  is  signaled  or  a negative error code on failure; call
       SDL_GetError() for more information.

CODE EXAMPLES
       Typical use of condition variables:

       ┌──────────────────────────────────┐
       │ SDL_bool condition = SDL_False;  │
       │ SDL_mutex* lock;                 │
       │ SDL_cond* cond;                  │
       │                                  │
       │ lock = SDL_CreateMutex();        │
       │ cond = SDL_CreateCond();         │
       │ Thread A:                        │
       │   SDL_LockMutex(lock);           │
       │   while (!condition)             │
       │   {                              │
       │     SDL_CondWait(cond, lock);    │
       │   }                              │
       │   SDL_UnlockMutex(lock);         │
       │                                  │
       │ Thread B:                        │
       │   SDL_LockMutex(lock);           │
       │   ...                            │
       │   condition = SDL_TRUE;          │
       │   ...                            │
       │   SDL_CondSignal(cond);          │
       │   SDL_UnlockMutex(lock);         │
       │ SDL_DestroyCond(cond);           │
       │ SDL_DestroyMutex(lock);          │
       └──────────────────────────────────┘

REMARKS
       This function unlocks the specified mutex and waits for another thread to call
       SDL_CondSignal()  or  SDL_CondBroadcast() on the condition variable cond. Once
       the condition variable is signaled, the mutex is re-locked  and  the  function
       returns.

       The mutex must be locked before calling this function.

       This  function  is the equivalent of calling SDL_CondWaitTimeout() with a time
       length of SDL_MUTEX_MAXWAIT.

RELATED FUNCTIONS
       SDL_CondBroadcast
       SDL_CondSignal
       SDL_CondWaitTimeout
       SDL_CreateCond
       SDL_DestroyCond

===============================================================================
                                                          *SDL_CondWaitTimeout*


NAME
       SDL_CondWaitTimeout -- Function

SYNOPSIS
       Use  this  function to wait untio a condition variable is signaled or a speci‐
       fied amount of time has passed.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ void SDL_CondWaitTimeout(SDL_cond* cond,    │
       │                          SDL_mutex* mutex,  │
       │                          Uint32 ms)         │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬─────────────────────────────────────────────────────────────────────────────────────┐
       │ cond   │ the condition variable to wait on                                                   │
       ├────────┼─────────────────────────────────────────────────────────────────────────────────────┤
       │ mutex  │ the mutex used to coordinate thread access                                          │
       ├────────┼─────────────────────────────────────────────────────────────────────────────────────┤
       │ ms     │ the maximum time to wait in millseconds, or SDL_MUTEX_WAITWAIT to wait indefinitely │
       └────────┴─────────────────────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns 0 if the condition variable is  signaled,  SDL_MUTEX_TIMEDOUT  if  the
       condition  is  not  signaled  in the alloted time, or a negative error code on
       failure; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_bool condition = SDL_FALSE;                                                           │
       │ SDL_mutex* lock;                                                                          │
       │ SDL_cond* cond;                                                                           │
       │                                                                                           │
       │ lock = SDL_CreateMutex();                                                                 │
       │ cond = SDL_CreateCond();                                                                  │
       │ Thread A:                                                                                 │
       │   const Uint32 timeout = 1000;  /* wake up every second */                                │
       │   while (!done)                                                                           │
       │   {                                                                                       │
       │     SDL_LockMutex(lock);                                                                  │
       │     while (!condition && SDL_CondWaitTimeout(cond, lock, timeout) != SDL_MUTEX_TIMEDOUT)  │
       │     {                                                                                     │
       │       continue;                                                                           │
       │     }                                                                                     │
       │                                                                                           │
       │     if (condition)                                                                        │
       │     {                                                                                     │
       │       ...                                                                                 │
       │     }                                                                                     │
       │                                                                                           │
       │     ... do some periodic work                                                             │
       │   }                                                                                       │
       │                                                                                           │
       │ Thread B:                                                                                 │
       │   SDL_LockMutex(lock);                                                                    │
       │   ...                                                                                     │
       │   condition = SDL_TRUE;                                                                   │
       │   ...                                                                                     │
       │   SDL_CondSignal(cond);                                                                   │
       │   SDL_UnlockMutex(lock);                                                                  │
       │ SDL_DestroyCond(cond);                                                                    │
       │ SDL_DestroyMutex(lock);                                                                   │
       └───────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This function unlocks the specified mutex and waits for another thread to call
       SDL_CondSignal() or SDL_CondBroadcast() on the condition variable cond, or for
       the specified time to elapse. Once the condition variable is signaled  or  the
       time elapsed, the mutex is re-locked and the function returns.

       The mutex must be locked before calling this function.

RELATED FUNCTIONS
       SDL_CondBroadcast
       SDL_CondSignal
       SDL_CondWait
       SDL_CreateCond
       SDL_DestroyCond

===============================================================================
                                                      *SDL_ControllerAxisEvent*


NAME
       SDL_ControllerAxisEvent -- Structure

SYNOPSIS
       A structure that contains game controller axis motion event information.

DATA FIELDS
       ┌─────────────────┬───────────┬───────────────────────┐
       │ Uint32          │ type      │ SDL_CONTROLLERAXISMO‐ │
       │                 │           │ TION                  │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint32          │ timestamp │ the timestamp of  the │
       │                 │           │ event                 │
       ├─────────────────┼───────────┼───────────────────────┤
       │ SDL_JoystickID  │ which     │ the joystick instance │
       │                 │           │ id                    │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ axis      │ the  controller  axis │
       │                 │           │ (SDL_GameController‐  │
       │                 │           │ Axis)                 │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Sint16          │ value     │ the    axis     value │
       │                 │           │ (range:   -32768   to │
       │                 │           │ 32767)                │
       └─────────────────┴───────────┴───────────────────────┘

REMARKS
       The direction "down" and "right" have positive values here.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

RELATED FUNCTIONS
       SDL_GameControllerEventState

===============================================================================
                                                    *SDL_ControllerButtonEvent*


NAME
       SDL_ControllerButtonEvent -- Structure

SYNOPSIS
       A structure that contains game controller button event information.

DATA FIELDS
       ┌─────────────────┬───────────┬───────────────────────┐
       │ Uint32          │ type      │ SDL_CONTROLLERBUTTON‐ │
       │                 │           │ DOWN   or    SDL_CON‐ │
       │                 │           │ TROLLERBUTTONUP       │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint32          │ timestamp │ the  timestamp of the │
       │                 │           │ event                 │
       ├─────────────────┼───────────┼───────────────────────┤
       │ SDL_JoystickID  │ which     │ the joystick instance │
       │                 │           │ id                    │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ button    │ the controller button │
       │                 │           │ (SDL_GameController‐  │
       │                 │           │ Button)               │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ state     │ SDL_PRESSED        or │
       │                 │           │ SDL_RELEASED          │
       └─────────────────┴───────────┴───────────────────────┘

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

RELATED FUNCTIONS
       SDL_GameControllerEventState

===============================================================================
                                                    *SDL_ControllerDeviceEvent*


NAME
       SDL_ControllerDeviceEvent -- Structure

SYNOPSIS
       A structure that contains controller device event information.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ SDL_CONTROLLERDE‐     │
       │         │           │ VICEADDED,   SDL_CON‐ │
       │         │           │ TROLLERDEVICEREMOVED  │
       │         │           │ or  SDL_CONTROLLERDE‐ │
       │         │           │ VICEREMAPPED          │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ the  timestamp of the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ which     │ the  joystick  device │
       │         │           │ index     for     the │
       │         │           │ SDL_CONTROLLERDE‐     │
       │         │           │ VICEDADDED  event  or │
       │         │           │ instance id  for  the │
       │         │           │ SDL_CONTROLLERDE‐     │
       │         │           │ VICEREMOVED        or │
       │         │           │ SDL_CONTROLLERDE‐     │
       │         │           │ VICEREMAPPED event    │
       └─────────┴───────────┴───────────────────────┘

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

RELATED FUNCTIONS
       SDL_GameControllerEventState

===============================================================================
                                                             *SDL_ConvertAudio*


NAME
       SDL_ConvertAudio -- Function

SYNOPSIS
       Use this function to convert audio data to a desired audio format.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ void SDL_ConvertAudio(SDL_AudioCVT* cvt)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────────────────────────────────────────────────────┐
       │ cvt  │ an SDL_AudioCVT structure that was previously setup; see Remarks for details │
       └──────┴──────────────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  0  if  the  conversion was completed successfully or a negative error
       code on failure; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────┐
       │ // Change 1024 stereo sample frames at 48000Hz from Float32 to Int16.  │
       │ SDL_AudioCVT cvt;                                                      │
       │ SDL_BuildAudioCVT(&cvt, AUDIO_F32, 2, 48000, AUDIO_S16, 2, 48000);     │
       │ SDL_assert(cvt.needed); // obviously, this one is always needed        │
       │ cvt.len = 1024 * 2 * 4; // 1024 stereo float32 sampe frames            │
       │ cvt.buf = (Uint8*)SDL_malloc(cvt.len * cvt.len_mult);                  │
       │ // read your float32 data into cvt.buf here.                           │
       │ SDL_ConvertAudio(&cvt);                                                │
       │ // cvt.buf has cvt.len_cvt bytes of converted data now.                │
       └────────────────────────────────────────────────────────────────────────┘

REMARKS
       This function does the actual audio dat conversion, afer the  application  has
       called  SDL_BuildAudioCVT()  to  prepare  the  conversion information and then
       filled in the buffer details.

       Once the application has initialized  the  cvt  structure  using  SDL_BuildAu‐
       dioCVT(), allocated an audio buffer and filled it with audio data inthe source
       format, this function will convert the buffer, in-place to the desired format.

       The data conversion may go through several passes; any given pass may possibly
       temporarily  increase  the  size  oaf  the data. For example, SDL might expand
       16-bit data to 32 bits before resampling to a lower frequency, buffer will  be
       both  the source and destination, converting as necessary in-place, the appli‐
       cation must allocate a buffer tha  will  fuly  contain  the  data  during  its
       largest  conversion  pass.  After SDL_BuildAudioCVT() returns, the application
       should set the cvt structure's len field to the size, in bytes, of the  source
       data,  and  allocate  a  buffer  that is len * len_mult bytes long for the buf
       field.

       The source data should be copied into this buffer before the call to  SDL_Con‐
       vertAudio().  Upon  successful  return, this buffer will contain the converted
       audio, and the cvt structure's len_cvt field will be the size of the converted
       data,  in byteds. Any bytes in the buffer past len_cvt are undefined once this
       function returns.

RELATED FUNCTIONS
       SDL_BuildAudioCVT

===============================================================================
                                                            *SDL_ConvertPixels*


NAME
       SDL_ConvertPixels -- Function

SYNOPSIS
       Use this function to copy a block of pixels of one format to another format.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ void SDL_ConvertPixels(int          width,       │
       │                        int          height,      │
       │                        Uint32       src_format,  │
       │                        const void*  src,         │
       │                        int          src_pitch,   │
       │                        Uint32       dst_format,  │
       │                        void*        dst,         │
       │                        int          dst_pitch)   │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────┬───────────────────────────────────────────────────────────────┐
       │ width       │ the width of the block to copy, in pixels                     │
       ├─────────────┼───────────────────────────────────────────────────────────────┤
       │ height      │ the height of the block to copy, in pixels                    │
       ├─────────────┼───────────────────────────────────────────────────────────────┤
       │ src_format  │ the format of the source pixels; see Remarks for details      │
       ├─────────────┼───────────────────────────────────────────────────────────────┤
       │ src         │ a pointer to the source pixels                                │
       ├─────────────┼───────────────────────────────────────────────────────────────┤
       │ src_pitch   │ the pitch of the block to copy                                │
       ├─────────────┼───────────────────────────────────────────────────────────────┤
       │ dst_format  │ the format of the destination pixels; see Remarks for details │
       ├─────────────┼───────────────────────────────────────────────────────────────┤
       │ dst         │ a pointer to be filled in with new pixel data                 │
       ├─────────────┼───────────────────────────────────────────────────────────────┤
       │ dst_pitch   │ the pitch of the destination pixels                           │
       └─────────────┴───────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       src_format and dst_format may each be one of the following.

       SDL_PixelFormatEnum values:

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar mode: Y + V  +  U  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar  mode:  Y  + U + V (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packet mode: Y0 + U0 + Y1  + │
       │                              │ V0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed  mode: U0 + Y0 + V0 + │
       │                              │ Y1 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed mode: Y0 + V0 + Y1  + │
       │                              │ U0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar  mode: Y + U/V inter‐ │
       │                              │ leaved (2  planes)  (>=  SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar  mode: Y + V/U inter‐ │
       │                              │ leaved (2  planes)  (>=  SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

===============================================================================
                                                           *SDL_ConvertSurface*


NAME
       SDL_ConvertSurface -- Function

SYNOPSIS
       Use this function to copy an existing surface into a new one that is optimized
       for blitting to a surface of a specified pixel format.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────┐
       │ SDL_Surface SDL_ConvertSurface(SDL_Surface*   src,                   │
       │                                const          SDL_PixelFormat* fmt,  │
       │                                Uint32         flags)                 │
       └──────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬────────────────────────────────────────────────────────────────────────────────────┐
       │ src    │ the existing SDL_Surface structure to convert                                      │
       ├────────┼────────────────────────────────────────────────────────────────────────────────────┤
       │ fmt    │ the SDL_PixelFormat structure that the new surface is optimized for                │
       ├────────┼────────────────────────────────────────────────────────────────────────────────────┤
       │ flags  │ the flags are unused and should be set to 0; this is a leftover from SDL 1.2's API │
       └────────┴────────────────────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns the new SDL_Surface structure that is created or  NULL  if  it  fails;
       call SDL_GetError() for more information.

REMARKS
       This  function  is used to optimize images for faster repeat blitting. This is
       accomplished by converting the original and storing the result as a  new  sur‐
       face.  The  new,  optimized  surface can then be used as the source for future
       blits, making them faster.

RELATED FUNCTIONS
       SDL_ConvertSurfaceFormat
       SDL_CreateRGBSurface

===============================================================================
                                                     *SDL_ConvertSurfaceFormat*


NAME
       SDL_ConvertSurfaceFormat -- Function

SYNOPSIS
       Use  this  function to copy an existing surface to a new surface of the speci‐
       fied format.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────┐
       │ SDL_Surface* SDL_ConvertSurfaceFormat(SDL_Surface*    src,           │
       │                                       Uint32          pixel_format,  │
       │                                       Uint32          flags)         │
       └──────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────────────────────────────────────────────────────┐
       │ src           │ the SDL_Surface structure representing the surface to convert                │
       ├───────────────┼──────────────────────────────────────────────────────────────────────────────┤
       │ pixel_format  │ one of the enumerated values in SDL_PixelFormatEnum; see Remarks for details │
       ├───────────────┼──────────────────────────────────────────────────────────────────────────────┤
       │ flags         │ the flags are unused and should be set to 0                                  │
       └───────────────┴──────────────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns the new surface, or NULL on failure; call SDL_GetError() for more  in‐
       formation.

REMARKS
       format may be one of the following.

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar  mode:  Y  + V + U (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar mode: Y + U  +  V  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packet  mode: Y0 + U0 + Y1 + │
       │                              │ V0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed mode: U0 + Y0 + V0  + │
       │                              │ Y1 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed  mode: Y0 + V0 + Y1 + │
       │                              │ U0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar mode: Y + U/V  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar mode: Y + V/U  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_ConvertSurface

===============================================================================
                                                        *SDL_CreateColorCursor*


NAME
       SDL_CreateColorCursor -- Function

SYNOPSIS
       Use this function to create a color cursor.

SYNTAX
       ┌─────────────────────────────────────────────────────────────┐
       │ SDL_Cursor* SDL_CreateColorCursor(SDL_Surface*    surface,  │
       │                                   int             hot_x,    │
       │                                   int             hot_y)    │
       └─────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬────────────────────────────────────────────────────────┐
       │ surface  │ an SDL_Surface structure representing the cursor image │
       ├──────────┼────────────────────────────────────────────────────────┤
       │ hot_x    │ the x position of the cursor hot spot                  │
       ├──────────┼────────────────────────────────────────────────────────┤
       │ hot_y    │ the y position of the cursor hot spot                  │
       └──────────┴────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  the new cursor on success or NULL on failure; call SDL_GetError() for
       more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                           │
       │                                                                            │
       │ int main(int argc, char* argv[])                                           │
       │ {                                                                          │
       │   SDL_Window* window = NULL;                                               │
       │   SDL_Renderer* renderer = NULL;                                           │
       │   SDL_Surface* surface = NULL;                                             │
       │   SDL_Cursor* cursor = NULL;                                               │
       │   SDL_bool error = SDL_TRUE;                                               │
       │                                                                            │
       │   if (SDL_Init(SDL_INIT_VIDEO) < 0) {                                      │
       │     goto exit;                                                             │
       │   }                                                                        │
       │   if (SDL_CreateWindowAndRenderer(640, 480, 0, &window, &renderer) < 0) {  │
       │     goto exit;                                                             │
       │   }                                                                        │
       │   surface = SDL_LoadBMP((1 < argc) ? argv[1] : "cursor.bmp");              │
       │   if (!surface) {                                                          │
       │     goto exit;                                                             │
       │   }                                                                        │
       │   cursor = SDL_CreateColorCursor(surface, 0, 0);                           │
       │   if (!cursor) {                                                           │
       │     goto exit;                                                             │
       │   }                                                                        │
       │                                                                            │
       │   SDL_SetCursor(cursor);                                                   │
       │   SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);                        │
       │   while (SDL_TRUE) {                                                       │
       │     SDL_Event event;                                                       │
       │     while (SDL_PollEvent(&event)) {                                        │
       │       switch (event.type) {                                                │
       │         case SDL_MOUSEBUTONUP:                                             │
       │         case SDL_QUIT:                                                     │
       │           error = SDL_FALSE;                                               │
       │           goto exit;                                                       │
       │       }                                                                    │
       │     }                                                                      │
       │     SDL_RenderClear(renderer);                                             │
       │     SDL_RenderPresent(renderer);                                           │
       │   }                                                                        │
       │                                                                            │
       │ exit:                                                                      │
       │   if (error) {                                                             │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", SDL_GetError());      │
       │   }                                                                        │
       │   if (cursor) {                                                            │
       │     SDL_FreeCursor(cursor);                                                │
       │   }                                                                        │
       │   if (surface) {                                                           │
       │     SDL_FreeSurface(surface);                                              │
       │   }                                                                        │
       │   if (renderer) {                                                          │
       │     SDL_DestroyRenderer(renderer);                                         │
       │   }                                                                        │
       │   SDL_Quit();                                                              │
       │   return error;                                                            │
       │ }                                                                          │
       └────────────────────────────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_CreateCursor
       SDL_FreeCursor

===============================================================================
                                                               *SDL_CreateCond*


NAME
       SDL_CreateCond -- Function

SYNOPSIS
       Use this function to create a condition varible.

SYNTAX
       ┌─────────────────────────────────┐
       │ SDL_cond* SDL_CreateCond(void)  │
       └─────────────────────────────────┘

RETURN VALUE
       Returns  a  new condition variable or NULL on failure; call SDL_GetError() for
       more information.

CODE EXAMPLES
       Typical use of condition variables.

       ┌──────────────────────────────────┐
       │ SDL_bool condition = SDL_FALSE;  │
       │ SDL_mutex* lock;                 │
       │ SDL_cond *cond;                  │
       │                                  │
       │ lock = SDL_CreateMutex();        │
       │ cond = SDL_CreateCond();         │
       │ Thread A:                        │
       │   SDL_LockMutex(lock);           │
       │   while (!condition) {           │
       │     SDL_CondWait(cond, lock);    │
       │   }                              │
       │   SDL_UnlockMutex(lock);         │
       │                                  │
       │ Thread B:                        │
       │   SDL_LockMutex(lock);           │
       │   ...                            │
       │   condition = SDL_TRUE;          │
       │   ...                            │
       │   SDL_CondSignal(cond);          │
       │   SDL_UnlockMutex(lock);         │
       │ SDL_DestroyCond(cond);           │
       │ SDL_DestroyMutex(lock);          │
       └──────────────────────────────────┘

RELATED FUNCTIONS
       SDL_CondBroadcast
       SDL_CondSignal
       SDL_CondWait
       SDL_CondWaitTimeout
       SDL_DestroyCond

===============================================================================
                                                             *SDL_CreateCursor*


NAME
       SDL_CreateCursor -- Function

SYNOPSIS
       Use  this function to create a cursor using the specified bitmap data and mask
       (in MSB format).

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ SDL_Cursor* SDL_CreateCursor(const Uint8*     data,   │
       │                              const Uint8*     mask,   │
       │                              int              w,      │
       │                              int              h,      │
       │                              int              hot_x,  │
       │                              int              hot_y)  │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ data   │ the  color  value  for  each │
       │        │ pixel of the cursor; see Re‐ │
       │        │ marks for details            │
       ├────────┼──────────────────────────────┤
       │ mask   │ the  mask  value  for   each │
       │        │ pixel of the cursor; see Re‐ │
       │        │ marks for details            │
       ├────────┼──────────────────────────────┤
       │ w      │ the width of the cursor; see │
       │        │ Remarks for details          │
       ├────────┼──────────────────────────────┤
       │ h      │ the  height  of  the  cursor │
       │        │ (same restrictions as w?)    │
       ├────────┼──────────────────────────────┤
       │ hot_x  │ the X-axis location  of  the │
       │        │ upper  left  corner  of  the │
       │        │ cursor relative to  the  ac‐ │
       │        │ tual mouse position          │
       ├────────┼──────────────────────────────┤
       │ hot_y  │ the  Y-axis  location of the │
       │        │ upper  left  corner  of  the │
       │        │ cursor  relative  to the ac‐ │
       │        │ tual mouse position          │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns a new cursor with the specified parameters on success or NULL on fail‐
       ure; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────┐
       │ /* Stolen from the mailing list */                            │
       │ /* Creates a new mouse cursor from an XPM */                  │
       │                                                               │
       │ /* XPM */                                                     │
       │ static const char *arrow[] = {                                │
       │   /* width height num_colors chars_per_pixel */               │
       │   "    32    32        3            1",                       │
       │   /* colors */                                                │
       │   "X c #000000",                                              │
       │   ". c #ffffff",                                              │
       │   "  c None",                                                 │
       │   /* pixels */                                                │
       │   "X                               ",                         │
       │   "XX                              ",                         │
       │   "X.X                             ",                         │
       │   "X..X                            ",                         │
       │   "X...X                           ",                         │
       │   "X....X                          ",                         │
       │   "X.....X                         ",                         │
       │   "X......X                        ",                         │
       │   "X.......X                       ",                         │
       │   "X........X                      ",                         │
       │   "X.....XXXXX                     ",                         │
       │   "X..X..X                         ",                         │
       │   "X.X X..X                        ",                         │
       │   "XX  X..X                        ",                         │
       │   "X    X..X                       ",                         │
       │   "     X..X                       ",                         │
       │   "      X..X                      ",                         │
       │   "      X..X                      ",                         │
       │   "       XX                       ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "                                ",                         │
       │   "0,0"                                                       │
       │ };                                                            │
       │                                                               │
       │ static SDL_Cursor *init_system_cursor(const char *image[])    │
       │ {                                                             │
       │   int i, row, col;                                            │
       │   Uint8 data[4*32];                                           │
       │   Uint8 mask[4*32];                                           │
       │   int hot_x, hot_y;                                           │
       │                                                               │
       │   i = -1;                                                     │
       │   for (row=0; row<32; ++row) {                                │
       │     for (col=0; col<32; ++col) {                              │
       │       if (col % 8) {                                          │
       │         data[i] <<= 1;                                        │
       │         mask[i] <<= 1;                                        │
       │       } else {                                                │
       │         ++i;                                                  │
       │         data[i] = mask[i] = 0;                                │
       │       }                                                       │
       │       switch (image[4+row][col]) {                            │
       │         case 'X':                                             │
       │           data[i] |= 0x01;                                    │
       │           mask[i] |= 0x01;                                    │
       │           break;                                              │
       │         case '.':                                             │
       │           mask[i] |= 0x01;                                    │
       │           break;                                              │
       │         case ' ':                                             │
       │           break;                                              │
       │       }                                                       │
       │     }                                                         │
       │   }                                                           │
       │   sscanf(image[4+row], "%d,%d", &hot_x, &hot_y);              │
       │   return SDL_CreateCursor(data, mask, 32, 32, hot_x, hot_y);  │
       │ }                                                             │
       └───────────────────────────────────────────────────────────────┘

REMARKS
       mask has to be in MSB (Most Significant Bit) format.

       The cursor width (w) must be a multiple of 8 bits.

       The cursor is created in black and white according to the following:

       ┌───────┬────────┬──────────────────────────────────────────┐
       │ data  │  mask  │ Resulting Pixel on Screen                │
       ├───────┼────────┼──────────────────────────────────────────┤
       │ 0     │  1     │ White                                    │
       ├───────┼────────┼──────────────────────────────────────────┤
       │ 1     │  1     │ Black                                    │
       ├───────┼────────┼──────────────────────────────────────────┤
       │ 0     │  0     │ Transparent                              │
       ├───────┼────────┼──────────────────────────────────────────┤
       │ 1     │  0     │ Inverted color if possible, black if not │
       └───────┴────────┴──────────────────────────────────────────┘
       Cursors created with this function must be freed with SDL_FreeCursor().

       If you want to have a color cursor, then this function is not for you; instead
       you must hide the normal system cursor using SDL_ShowCursor() and in your main
       loop,  when  you draw graphics, also draw a SDL_Surface at the location of the
       mouse cursor.

       Or use SDL_CreateColorCursor().

       Note that, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which  pro‐
       vides twelve readily available system cursors to pick from.

RELATED FUNCTIONS
       SDL_FreeCursor
       SDL_SetCursor
       SDL_ShowCursor

===============================================================================
                                                              *SDL_CreateMutex*


NAME
       SDL_CreateMutex -- Function

SYNOPSIS
       Use this function to create a new mutex.

SYNTAX
       ┌───────────────────────────────────┐
       │ SDL_mutex* SDL_CreateMutex(void)  │
       └───────────────────────────────────┘

RETURN VALUE
       Returns  the  initialized  and  unlocked  mutex  or  NULL  on  failture;  call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────┐
       │ SDL_mutex* mutex;                            │
       │                                              │
       │ mutex = SDL_CreateMutex();                   │
       │ if (!mutex) {                                │
       │   fprintf(stderr, "Couldn't create mutex0);  │
       │   return;                                    │
       │ }                                            │
       │                                              │
       │ if (SDL_LockMutex(mutex) == 0) {             │
       │   /* Do stuff while mutex is locked */       │
       │   SDL_UnlockMutex(mutex);                    │
       │ } else {                                     │
       │   fprintf(stderr, "Couldn't lock mutex0);    │
       │ }                                            │
       │                                              │
       │ SDL_DestroyMutex(mutex);                     │
       └──────────────────────────────────────────────┘

REMARKS
       Calls to SDL_LockMutex() will not return while the mutex is locked by  another
       thread. See SDL_TryLockMutex() to attempt to lock without blocking.

       SDL mutexes are reentrant.

RELATED FUNCTIONS
       SDL_DestoryMutex
       SDL_LockMutex
       SDL_TryLockMutex
       SDL_UnlockMutex

===============================================================================
                                                         *SDL_CreateRGBSurface*


NAME
       SDL_CreateRGBSurface -- Function

SYNOPSIS
       Use this function to allocate a new RGB surface.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ SDL_Surface* SDL_CreateRGBSurface(Uint32    flags,   │
       │                                   int       width,   │
       │                                   int       height,  │
       │                                   int       depth,   │
       │                                   Uint32    Rmask,   │
       │                                   Uint32    Gmask,   │
       │                                   Uint32    Bmask,   │
       │                                   Uint32    Amask)   │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬───────────────────────────────────────────────────────────┐
       │ flags   │ the flags are unused and should be set to 0               │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ width   │ the width of the surface                                  │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ height  │ the height of the surface                                 │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ depth   │ the depth of the surface in bits; see Remarks for details │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ Rmask   │ the red mask for the pixels                               │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ Gmask   │ the green mask for the pixels                             │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ Bmask   │ the blue mask for the pixels                              │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ Amask   │ the alpha mask for the pixels                             │
       └─────────┴───────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  the  new  SDL_Surface  structure that is created or NULL if it falls;
       call SDL_GetError() for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ /* Create a 32-bit surface with the bytes of each pixel in R,G,B,A order, as expected by OpenGL for textures */             │
       │ SDL_Surface* surface;                                                                                                       │
       │ Uint32 rmask, gmask, bmask, amask;                                                                                          │
       │                                                                                                                             │
       │ /* SDL interprets each pixel as a 32-bit number, so our masks must depend on the endianness (byte order) of the machine */  │
       │ #if SDL_BYTEORDER == SDL_BIG_ENDIAN                                                                                         │
       │   rmask = 0xff000000;                                                                                                       │
       │   gmask = 0x00ff0000;                                                                                                       │
       │   bmask = 0x0000ff00;                                                                                                       │
       │   amask = 0x000000ff;                                                                                                       │
       │ #else                                                                                                                       │
       │   rmask = 0x000000ff;                                                                                                       │
       │   gmask = 0x0000ff00;                                                                                                       │
       │   bmask = 0x00ff0000;                                                                                                       │
       │   amask = 0xff000000;                                                                                                       │
       │ #endif                                                                                                                      │
       │                                                                                                                             │
       │ surface = SDL_CreateRGBSurface(0, width, height, 32, rmask, gmask, bmask, amask);                                           │
       │ if (surface == NULL)                                                                                                        │
       │ {                                                                                                                           │
       │   SDL_Log("SDL_CreateRGBSurface() failed: %s", SDL_GetError());                                                             │
       │   exit(1);                                                                                                                  │
       │ }                                                                                                                           │
       │                                                                                                                             │
       │ /* or using the default masks for the depth: */                                                                             │
       │ surface = SDL_CreateRGBSurface(0, width, height, 32, 0, 0, 0, 0);                                                           │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The depth if 4 or 8 bits, and empty palette is allocated for the  surface.  If
       depth is greater than 8 bits, the pixel format is set using the [RGBA]mask pa‐
       rameters.

       The [RGBA]mask parameters are the bitmasks used to extract that color  from  a
       pixel.  Rmask being FF000000 means the red data is stored in the most signifi‐
       cant byte. Using zeros for the RGB masks sets a default value,  based  on  the
       depth.  (e.g. SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);) However, using zero for
       the Amask results in an Amask of 0.

       By default surfaces with an alpha mask are set up for blending as with

              SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)

       You can change this by calling SDL_SetSurfaceBlendMode() and selecting a  dif‐
       ferent blendmode.

RELATED FUNCTIONS
       SDL_CreateRGBSurfaceFrom
       SDL_CreateRGBSurfaceWithFormat
       SDL_FreeSurface

===============================================================================
                                                     *SDL_CreateRGBSurfaceFrom*


NAME
       SDL_CreateRGBSurfaceFrom -- Function

SYNOPSIS
       Use this function to allocate a new RGB surface with existing pixel data.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ SDL_Surface* SDL_CreateRGBSurfaceFrom(void*     pixels,  │
       │                                       int       width,   │
       │                                       int       height,  │
       │                                       int       depth,   │
       │                                       int       pitch,   │
       │                                       Uint32    Rmask,   │
       │                                       Uint32    Gmask,   │
       │                                       Uint32    Bmask,   │
       │                                       Uint32    Amask)   │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬───────────────────────────────────────────────────────────┐
       │ pixels  │ a pointer to existing pixel data                          │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ width   │ the width of the surface                                  │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ height  │ the height of the surface                                 │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ depth   │ the depth of the surface in bits; see Remarks for details │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ pitch   │ the length of a row of pixels in bytes                    │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ Rmask   │ the red mask for the pixels                               │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ Gmask   │ the green mask for the pixels                             │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ Bmask   │ the blue mask for the pixels                              │
       ├─────────┼───────────────────────────────────────────────────────────┤
       │ Amask   │ the alpha mask for the pixels                             │
       └─────────┴───────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  the  new  SDL_Surface  structure that is created or NULL if it fails;
       call SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ // This example shows how to create a SDL_Surface* with the data                                                     │
       │ // loaded from an image file with the stb_image.h library                                                            │
       │ // (https://github.com/nothings/stb/)                                                                                │
       │                                                                                                                      │
       │ // the color format you request stb_image to utput, use STBI_rgb                                                     │
       │ // if you don't want/need the alpha channel                                                                          │
       │ int req_format = STBI_rgb_alpha;                                                                                     │
       │ int width, height, orig_format;                                                                                      │
       │ unsigned char* data = stbi_load("./test.png", &width, &height, &orig_format, req_format);                            │
       │ if (data == NULL) {                                                                                                  │
       │   SDL_Log("Loading image failed: %s", stbi_failure_reason());                                                        │
       │   exit(1);                                                                                                           │
       │ }                                                                                                                    │
       │                                                                                                                      │
       │ // Set up the pixel format color masks for RGB(A) byte arrays.                                                       │
       │ // Only STBI_rgb (3) and STBI_rgb_alpha (4) are supported here!                                                      │
       │ Uint32 rmask, gmask, bmask, amask;                                                                                   │
       │ #if SDL_BYTEORDER == SDL_BIG_ENDIAN                                                                                  │
       │   int shift = (req_format == STBI_rgb) ? 8 : 0;                                                                      │
       │   rmask = 0xff000000 >> shift;                                                                                       │
       │   gmask = 0x00ff0000 >> shift;                                                                                       │
       │   bmask = 0x0000ff00 >> shift;                                                                                       │
       │   amask = 0x000000ff >> shift;                                                                                       │
       │ #else // little endian, like x86                                                                                     │
       │   rmask = 0x000000ff;                                                                                                │
       │   gmask = 0x0000ff00;                                                                                                │
       │   bmask = 0x00ff0000;                                                                                                │
       │   amask = (req_format == STBI_rgb) ? 0 : 0xff000000;                                                                 │
       │ #endif                                                                                                               │
       │                                                                                                                      │
       │ int depth, pitch;                                                                                                    │
       │ if (req_format == STBI_rgb) {                                                                                        │
       │   depth = 24;                                                                                                        │
       │   pitch = 3*width;  // 3 bytes per pixel * pixels per row                                                            │
       │ } else {                                                                                                             │
       │   depth = 24;                                                                                                        │
       │   pitch = 4*width;                                                                                                   │
       │ }                                                                                                                    │
       │                                                                                                                      │
       │ SDL_Surface* surf = SDL_CreateRGBSurfaceFrom((void*)data, width, height, depth, pitch, rmask, gmask, bmask, amask);  │
       │                                                                                                                      │
       │ if (surf == NULL) {                                                                                                  │
       │   SDL_Log("Creating surface failed: %s", SDL_GetError());                                                            │
       │   stbi_image_free(data);                                                                                             │
       │   exit(1);                                                                                                           │
       │ }                                                                                                                    │
       │                                                                                                                      │
       │ // ... do something useful with the surface ...                                                                      │
       │ // ...                                                                                                               │
       │                                                                                                                      │
       │ // when you don't need the surface anymore, free it..                                                                │
       │ SDL_FreeSurface(surf);                                                                                               │
       │ // .. *and* the data used by the surface!                                                                            │
       │ stbi_image_free(data);                                                                                               │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The depth is 4 or 8 bits, an empty palette is allocated for  the  surface.  If
       depth is greater than 8 bits, the pixel format is set using the [RGBA]mask pa‐
       rameters.

       The [RGBA]mask parameters are the bitmasks used to extract that color  from  a
       pixel.  For instance, Rmask being FF000000 means the red data is stored in the
       most significant byte. Using zeros for the RGB masks  sets  a  default  value,
       based  on  the  depth. (e.g. SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);) However,
       using zero for the Amask results in an Amask of 0.

       By default surfaces with an alhpa mask are set up for blending as with

              SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)

       You can change this by calling SDL_SetSurfaceBlendMode() and selecting a  dif‐
       ferent blendMode.

       No  copy  is  made of the pixel data. Pixel data is not managed automatically;
       you must free the surface before you free the pixel data.

RELATED FUNCTIONS
       SDL_CreateRGBSurface
       SDL_CreateRGBSurfaceWithFormatFrom
       SDL_FreeSurface

===============================================================================
                                               *SDL_CreateRGBSurfaceWithFormat*


NAME
       SDL_CreateRGBSurfaceWithFormat -- Function

SYNOPSIS
       Use this function to allocate an RGB surface.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ SDL_Surface* SDL_CreateRGBSurfaceWithFormat(Uint32    flags,   │
       │                                             int       width,   │
       │                                             int       height,  │
       │                                             int       depth,   │
       │                                             Uint32    format)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────────────────────────────────────────────────────┐
       │ flags   │ the flags are obsolete and should be set to 0                       │
       ├─────────┼─────────────────────────────────────────────────────────────────────┤
       │ width   │ the width in pixels of the surface to create                        │
       ├─────────┼─────────────────────────────────────────────────────────────────────┤
       │ height  │ the height in pixels of the surface to create                       │
       ├─────────┼─────────────────────────────────────────────────────────────────────┤
       │ depth   │ the depth in bits of the surface to create                          │
       ├─────────┼─────────────────────────────────────────────────────────────────────┤
       │ format  │ the pixel format (see SDL_PixelFormatEnum) of the surface to create │
       └─────────┴─────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  a  new SDL_Surface on success or NULL on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ /* Create a 32-bit surface with the bytes of each pixel in R,G,B,A order, as expected by OpenGL for textures */  │
       │ SDL_Surface* surf;                                                                                               │
       │ surf = SDL_CreateRGBSurfaceWithFormat(0, width, height, 32, SDL_PIXELFORMAT_RGBA32);                             │
       │ if (surf == NULL) {                                                                                              │
       │   SDL_Log("SDL_CreateRGBSurfaceWithFormat() failed: %s", SDL_GetError());                                        │
       │   exit(1);                                                                                                       │
       │ }                                                                                                                │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       If the function runs out of memory, it will return NULL.

VERSION
       This function is available since SDL2.0.5.

RELATED FUNCTIONS
       SDL_CreateRGBSurface
       SDL_CreateRGBSurfaceWithFormatFrom
       SDL_FreeSurface

===============================================================================
                                           *SDL_CreateRGBSurfaceWithFormatFrom*


NAME
       SDL_CreateRGBSurfaceWithFormatFrom -- Function

SYNOPSIS
       Use this function to allocate an RGB surface from provided pixel data.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────┐
       │ SDL_Surface* SDL_CreateRGBSurfaceWithFormatFrom(void*     pixels,  │
       │                                                 int       width,   │
       │                                                 int       height,  │
       │                                                 int       depth,   │
       │                                                 int       pitch,   │
       │                                                 Uint32    format)  │
       └────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬───────────────────────────────────────────────┐
       │ pixels  │ the pixel data to create the surface from     │
       ├─────────┼───────────────────────────────────────────────┤
       │ width   │ the width in pixels of the surface to create  │
       ├─────────┼───────────────────────────────────────────────┤
       │ height  │ the height in pixels of the surface to create │
       ├─────────┼───────────────────────────────────────────────┤
       │ depth   │ the depth in bits of the surface to create    │
       ├─────────┼───────────────────────────────────────────────┤
       │ pitch   │ the length of a row of pixels in bytes        │
       ├─────────┼───────────────────────────────────────────────┤
       │ format  │ the pixel format of the surface to create     │
       └─────────┴───────────────────────────────────────────────┘

RETURN VALUE
       Returns  a  new SDL_Surface on success or NULL on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ // This example shows how to create a SDL_Surface* with the data loaded from an image                            │
       │ // file with the stb_image.h library (https://github.com/nothings/stb/)                                          │
       │                                                                                                                  │
       │ // the color format you request stb_image to output,                                                             │
       │ // use STBI_rgb if you don't want/need the alpha channel                                                         │
       │ int req_format = STBI_rgb_alpha;                                                                                 │
       │ int width, height, orig_format;                                                                                  │
       │ unsigned char* data = stbi_load("./test.png", &width, &height, &orig_format, req_format);                        │
       │ if(data == NULL) {                                                                                               │
       │   SDL_Log("Loading image failed: %s", stbi_failure_reason());                                                    │
       │   exit(1);                                                                                                       │
       │ }                                                                                                                │
       │                                                                                                                  │
       │ int depth, pitch;                                                                                                │
       │ Uint32 pixel_format;                                                                                             │
       │ if (req_format == STBI_rgb) {                                                                                    │
       │   depth = 24;                                                                                                    │
       │   pitch = 3*width; // 3 bytes per pixel * pixels per row                                                         │
       │   pixel_format = SDL_PIXELFORMAT_RGB24;                                                                          │
       │ } else { // STBI_rgb_alpha (RGBA)                                                                                │
       │   depth = 32;                                                                                                    │
       │   pitch = 4*width;                                                                                               │
       │   piexel_format = SDL_PIXELFORMAT_RGBA32;                                                                        │
       │ }                                                                                                                │
       │                                                                                                                  │
       │ SDL_Surface* surf = SDL_CreateRGBSurfaceWithFormatFrom((void*)data, width, height, depth, pitch, pixel_format);  │
       │                                                                                                                  │
       │ if (surf == NULL) {                                                                                              │
       │   SDL_Log("Creating surface failed: %s", SDL_GetError());                                                        │
       │   stbi_image_free(data);                                                                                         │
       │   exit(1);                                                                                                       │
       │ }                                                                                                                │
       │                                                                                                                  │
       │ // ... do something useful with the surface ...                                                                  │
       │ // ...                                                                                                           │
       │                                                                                                                  │
       │ // when you don't need the surface anymore, free it..                                                            │
       │ SDL_FreeSurface(surf);                                                                                           │
       │ // .. *and* the data used by the surface!                                                                        │
       │ stbi_image_free(data);                                                                                           │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       If the function runs out of memory, it will return NULL.

       No copy is made of the pixel data. Pixel data is  not  managed  automatically;
       you must free the surface before you free the pixel data.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_CreateRGBSurfaceFrom
       SDL_CreateRGBSurfaceWithFormat
       SDL_FreeSurface

===============================================================================
                                                           *SDL_CreateRenderer*


NAME
       SDL_CreateRenderer -- Function

SYNOPSIS
       Use this function to create 2D rendering context for a window.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ SDL_Renderer* SDL_CreateRenderer(SDL_Window*  window,  │
       │                                  int          index,   │
       │                                  Uint32       flags)   │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the  window  where rendering │
       │         │ is displayed                 │
       ├─────────┼──────────────────────────────┤
       │ index   │ the index of  the  rendering │
       │         │ driver  to initialize, or -1 │
       │         │ to initialize the first  one │
       │         │ supporting   the   requested │
       │         │ flags                        │
       ├─────────┼──────────────────────────────┤
       │ flags   │ 0, or one or  more  SDL_Ren‐ │
       │         │ dererFlags   OR'd  together; │
       │         │ see Remarks for details      │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns a valid rendering  context  or  NULL  if  there  was  an  error;  call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                        │
       │                                                                         │
       │ int main(int argc, char* argv[]) {                                      │
       │   SDL_Window* win = NULL:                                               │
       │   SDL_Renderer* renderer = NULL;                                        │
       │   SDL_Texture* bitmapTex = NULL;                                        │
       │   SDL_Surface* bitmapSurface = NULL;                                    │
       │   int posX = 100, posY = 100, width = 320, height = 240;                │
       │                                                                         │
       │   SDL_Init(SDL_INIT_VIDEO);                                             │
       │                                                                         │
       │   win = SDL_CreateWindow("Hello World", posX, posY, width, height, 0);  │
       │                                                                         │
       │   renderer = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);     │
       │                                                                         │
       │   bitmapSurface = SDL_LoadBMP("img/hello.bmp");                         │
       │   bitmapTex = SDL_CreateTextureFromSurface(renderer, bitmapSurface);    │
       │   SDL_FreeSurface(bitmapSurface);                                       │
       │                                                                         │
       │   whlie (1) {                                                           │
       │     SDL_Event e;                                                        │
       │     if (SDL_PollEvent(&e)) {                                            │
       │       if (e.type == SDL_QUIT) {                                         │
       │         break;                                                          │
       │       }                                                                 │
       │     }                                                                   │
       │                                                                         │
       │     SDL_RenderClear(renderer);                                          │
       │     SDL_RenderCopy(renderer, bitmapTex, NULL, NULL);                    │
       │     SDL_RenderPresent(renderer);                                        │
       │   }                                                                     │
       │                                                                         │
       │   SDL_DestroyTexture(bitmapTex);                                        │
       │   SDL_DestroyRenderer(renderer);                                        │
       │   SDL_DestroyWindow(win);                                               │
       │   SDL_Quit();                                                           │
       │   return 0;                                                             │
       │ }                                                                       │
       └─────────────────────────────────────────────────────────────────────────┘

REMARKS
       flags may be any of the following OR'd together:

       ┌─────────────────────────────┬───────────────────────────────────────────────┐
       │ SDL_RENDERER_SOFTWARE       │ the renderer is a software fallback           │
       ├─────────────────────────────┼───────────────────────────────────────────────┤
       │ SDL_RENDERER_ACCELERATED    │ the renderer uses hardware acceleration       │
       ├─────────────────────────────┼───────────────────────────────────────────────┤
       │ SDL_RENDERER_PRESENTVSYNC   │ present is synchronized with the refresh rate │
       ├─────────────────────────────┼───────────────────────────────────────────────┤
       │ SDL_RENDERER_TARGETTEXTURE  │ the renderer supports rendering to texture    │
       └─────────────────────────────┴───────────────────────────────────────────────┘
       Note that providing no flags gives priority to available SDL_RENDERER_ACCELER‐
       ATED renderers.

RELATED FUNCTIONS
       SDL_CreateSoftwareRenderer
       SDL_DestroyRenderer
       SDL_GetNumRenderDrivers
       SDL_GetRendererInfo

===============================================================================
                                                          *SDL_CreateSemaphore*


NAME
       SDL_CreateSemaphore -- Function

SYNOPSIS
       Use this function to create a semaphore.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ SDL_sem* SDL_CreateSemaphore(Uint32 initial_value)  │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────────┬─────────────────────────────────────┐
       │ initial_value  │ the starting value of the semaphore │
       └────────────────┴─────────────────────────────────────┘

RETURN VALUE
       Returns  a  new semaphore or NULL on failure; call SDL_GetError() for more in‐
       formation.

CODE EXAMPLES
       ┌────────────────────────────────────┐
       │ SDL_atomic_t done;                 │
       │ SDL_sem* sem;                      │
       │                                    │
       │ SDL_AtomicSet(&done, 0);           │
       │ sem = SDL_CreateSemaphore(0);      │
       │ Thread A:                          │
       │   while (!SDL_AtomicGet(&done)) {  │
       │     add_data_to_queue();           │
       │     SDL_SemPost(sem);              │
       │   }                                │
       │                                    │
       │ Thread B:                          │
       │   whlie (!SDL_AtomicGet(&done)) {  │
       │     SDL_SemWait(sem);              │
       │     if (data_available()) {        │
       │       get_data_from_queue();       │
       │     }                              │
       │   }                                │
       │ SDL_AtomicSet(&done, 1);           │
       │ SDL_SemPost(sem);                  │
       │ wait_for_threads();                │
       │ SDL_DestroySemaphore(sem);         │
       └────────────────────────────────────┘

REMARKS
       This function creates a new semaphore and initializes it with the  value  ini‐
       tal_value.  Each wait operation on the semaphore will atomically decrement the
       semaphore value and potentially block if the semaphore value is 0.  Each  post
       operation  will  automatically  increment the semaphore value and wake waiting
       threads and allow them to retry the wait operation.

RELATED FUNCTIONS
       SDL_DestroySemaphore
       SDL_SemPost
       SDL_SemTryWait
       SDL_SemValue
       SDL_SemWait
       SDL_SemWaitTimeout

===============================================================================
                                                   *SDL_CreateSoftwareRenderer*


NAME
       SDL_CreateSoftwareRenderer -- Function

SYNOPSIS
       Use this function to create a 2D software rendering context for a surface.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────┐
       │ SDL_Renderer* SDL_CreateSoftwareRenderer(SDL_Surface* surface)  │
       └─────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬────────────────────────────────────────────────────────────────────────────┐
       │ surface  │ the SDL_Surface structure representing the surface where rendering is done │
       └──────────┴────────────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  a  valid  rendering  context  or  NULL  if  there  was an error; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                                            │
       │                                                                                                             │
       │ SDL_Window* window;                                                                                         │
       │ SDL_Renderer* renderer;                                                                                     │
       │ int done;                                                                                                   │
       │                                                                                                             │
       │ void DrawChessBoard(SDL_Renderer* renderer)                                                                 │
       │ {                                                                                                           │
       │   int row = 0, column = 0, x = 0;                                                                           │
       │   SDL_Rect rect, darea;                                                                                     │
       │                                                                                                             │
       │   /* Get the size of drawing surface */                                                                     │
       │   for (; row < 8; row++)                                                                                    │
       │   {                                                                                                         │
       │     column = row % 2;                                                                                       │
       │     x = column;                                                                                             │
       │     for (; column < 4 + (row%2); column++) {                                                                │
       │       SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0xFF);                                                      │
       │                                                                                                             │
       │       rect.w = darea.w/8;                                                                                   │
       │       rect.h = darea.h/8;                                                                                   │
       │       rect.x = x * rect.w;                                                                                  │
       │       rect.y = row * rect.h;                                                                                │
       │       x = x + 2;                                                                                            │
       │       SDL_RenderFillRect(renderer, &rect);                                                                  │
       │     }                                                                                                       │
       │   }                                                                                                         │
       │ }                                                                                                           │
       │                                                                                                             │
       │ void loop()                                                                                                 │
       │ {                                                                                                           │
       │   SDL_Event e;                                                                                              │
       │   while (SDL_PollEvent(&e)) {                                                                               │
       │     if (e.type == SDL_QUIT) {                                                                               │
       │       done = 1;                                                                                             │
       │       return;                                                                                               │
       │     }                                                                                                       │
       │                                                                                                             │
       │     if ((e.type == SDL_KEYDOWN) && (e.key.keysym.sym == SDLK_ESCAPE)) {                                     │
       │       done = 1;                                                                                             │
       │       return;                                                                                               │
       │     }                                                                                                       │
       │   }                                                                                                         │
       │                                                                                                             │
       │   DrawChessBoard(renderer);                                                                                 │
       │                                                                                                             │
       │   /* Got everything on rendering surface, now Update the drawing image on window screen */                  │
       │   SDL_UpdateWindowSurface(window);                                                                          │
       │ }                                                                                                           │
       │                                                                                                             │
       │ int main(int argc, char* argv[])                                                                            │
       │ {                                                                                                           │
       │   SDL_Surface* surface;                                                                                     │
       │                                                                                                             │
       │   /* Enable standard application logging */                                                                 │
       │   SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);                                  │
       │                                                                                                             │
       │   /* Initialize SDL */                                                                                      │
       │   if (SDL_Init(SDL_INIT_VIDEO) != 0)                                                                        │
       │   {                                                                                                         │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_Init fail: %s0, SDL_GetError());                        │
       │     return 1;                                                                                               │
       │   }                                                                                                         │
       │                                                                                                             │
       │   /* Create window and renderer for given surface */                                                        │
       │   window = SDL_CreateWindow("Chessboard", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFIN#ED, 640, 480, 0);  │
       │   if (!window) {                                                                                            │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Window creation fail : %s0, SDL_GetError());                │
       │     return 1;                                                                                               │
       │   }                                                                                                         │
       │                                                                                                             │
       │   surface = SDL_GetWindowSurface(window);                                                                   │
       │   renderer = SDL_CreateSoftwareRenderer(surface);                                                           │
       │   if (!renderer) {                                                                                          │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Render creation for surface fail : %s0, SDL_GetError());    │
       │     return 1;                                                                                               │
       │   }                                                                                                         │
       │                                                                                                             │
       │   /* Clear the rendering surface with the specified color */                                                │
       │   SDL_SetRenderDrawColor(renderer, 0xFF, 0xFF, 0xFF, 0xFF);                                                 │
       │   SDL_RenderClear(renderer);                                                                                │
       │                                                                                                             │
       │   /* Draw the Image on rendering surface */                                                                 │
       │   done = 0;                                                                                                 │
       │                                                                                                             │
       │   while (!done) {                                                                                           │
       │     loop();                                                                                                 │
       │   }                                                                                                         │
       │                                                                                                             │
       │   SDL_Quit();                                                                                               │
       │   return 0;                                                                                                 │
       │ }                                                                                                           │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       Two other API which can be used to create SDL_Renderer:

       1.) SDL_CreateRenderer() 2.) SDL_CreateWindowAndRenderer()

RELATED FUNCTIONS
       SDL_CreateRendeerer
       SDL_DestroyRenderer

===============================================================================
                                                       *SDL_CreateSystemCursor*


NAME
       SDL_CreateSystemCursor -- Function

SYNOPSIS
       Use this function to create a system cursor.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ SDL_Cursor* SDL_CreateSystemCursor(SDL_SystemCursor id)  │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────┬─────────────────────────────────────────────────────┐
       │ id  │ a system cursor enum value; see Remarks for details │
       └─────┴─────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  a  cursor on success or NULL on failure; call SDL_GetError() for more
       information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────┐
       │ SDL_Cursor* cursor;                                       │
       │ cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);  │
       │ SDL_SetCursor(cursor);                                    │
       └───────────────────────────────────────────────────────────┘

REMARKS
       id may be one of the following:

       ┌──────────────────────────────┬──────────────────────────────────────────────────────────┐
       │ SDL_SYSTEM_CURSOR_ARROW      │ arrow                                                    │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_IBEAM      │ i-beam                                                   │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_WAIT       │ wait                                                     │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_CROSSHAIR  │ crosshair                                                │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_WAITARROW  │ small wait cursor (or wait if not available)             │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_SIZENWSE   │ double arrow pointing northwest and southeast            │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_SIZENESW   │ double arrow pointing northeast and southwest            │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_SIZEWE     │ double arrow pointing west and east                      │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_SIZENS     │ double arrow pointing north and south                    │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_SIZEALL    │ four pointed arrow poinintg north, south, east, and west │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_NO         │ slashed circle or crossbones                             │
       ├──────────────────────────────┼──────────────────────────────────────────────────────────┤
       │ SDL_SYSTEM_CURSOR_HAND       │ hand                                                     │
       └──────────────────────────────┴──────────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0

RELATED FUNCTIONS
       SDL_FreeCursor

===============================================================================
                                                            *SDL_CreateTexture*


NAME
       SDL_CreateTexture -- Function

SYNOPSIS
       Use this function to create a texture for a rendering context.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ SDL_Texture* SDL_CreateTexture(SDL_Renderer*    renderer,  │
       │                                Uint32           format,    │
       │                                int              access,    │
       │                                int              w,         │
       │                                int              h);        │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────────────────────────────────────────────────────┐
       │ renderer  │ the rendering context                                                        │
       ├───────────┼──────────────────────────────────────────────────────────────────────────────┤
       │ format    │ one of the enumerated values in SDL_PixelFormatEnum; see Remarks for details │
       ├───────────┼──────────────────────────────────────────────────────────────────────────────┤
       │ access    │ one of the enumerated values in DL_TextureAccess; see Remearks for details   │
       ├───────────┼──────────────────────────────────────────────────────────────────────────────┤
       │ w         │ the width of the texture in pixels                                           │
       ├───────────┼──────────────────────────────────────────────────────────────────────────────┤
       │ h         │ the height of the texture in pixels                                          │
       └───────────┴──────────────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  a  pointer to the created texture or NULL if no rendering context was
       active, the format was unsupported, or the width or height were out of  range;
       call SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                                         │
       │                                                                                                          │
       │ /* Moving Rectangle */                                                                                   │
       │ int main(int argc, char *argv[])                                                                         │
       │ {                                                                                                        │
       │   SDL_Window* window;                                                                                    │
       │   SDL_Renderer* renderer;                                                                                │
       │   SDL_Texture* texture;                                                                                  │
       │   SDL_Event event;                                                                                       │
       │   SDL_Rect r;                                                                                            │
       │                                                                                                          │
       │   if (SDL_Init(SDL_INIT_VIDEO) < 0) {                                                                    │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s", SDL_GetError());           │
       │     return 3;                                                                                            │
       │   }                                                                                                      │
       │                                                                                                          │
       │   window = SDL_CreateWindow("SDL_CreateTexture",                                                         │
       │                             SDL_WINDOWPOS_UNDEFINED,                                                     │
       │                             SDL_WINDOWPOS_UNDEFINED,                                                     │
       │                             1024, 768,                                                                   │
       │                             SDL_WINDOW_RESIZABLE);                                                       │
       │   r.w = 100;                                                                                             │
       │   r.h = 50;                                                                                              │
       │                                                                                                          │
       │   renderer = SDL_CreateRenderer(window, -1, 0);                                                          │
       │                                                                                                          │
       │   texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, 1024, 768);  │
       │                                                                                                          │
       │   while (1) {                                                                                            │
       │     SDL_PollEvent(&event);                                                                               │
       │     if (event.type == SDL_QUIT)                                                                          │
       │       break;                                                                                             │
       │     r.x = rand() % 500;                                                                                  │
       │     r.y = rand() % 500;                                                                                  │
       │                                                                                                          │
       │     SDL_SetRenderTarget(renderer, texture);                                                              │
       │     SDL_SetRenderDrawColor(renderer, 0x00, 0x00, 0x00, 0x00);                                            │
       │     SDL_RenderClear(renderer);                                                                           │
       │     SDL_RenderDrawRect(renderer, &r);                                                                    │
       │     SDL_SetRenderDrawColor(renderer, 0xFF, 0x00, 0x00, 0x00);                                            │
       │     SDL_RenderFillRect(renderer, &r);                                                                    │
       │     SDL_SetRenderTarget(renderer, NULL);                                                                 │
       │     SDL_RenderCopy(renderer, texture, NULL, NULL);                                                       │
       │     SDL_RenderPresent(renderer);                                                                         │
       │   }                                                                                                      │
       │                                                                                                          │
       │   SDL_DestroyRenderer(renderer);                                                                         │
       │   SDL_Quit();                                                                                            │
       │   return 0;                                                                                              │
       │ }                                                                                                        │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       format see SDL_PixelFormatEnum.
       access see SDL_TextureAccess.

RELATED FUNCTIONS
       SDL_CreateTextureFromSurface
       SDL_DestroyTexture
       SDL_QueryTexture
       SDL_UpdateTexture

===============================================================================
                                                 *SDL_CreateTextureFromSurface*


NAME
       SDL_CreateTextureFromSurface -- Function

SYNOPSIS
       Use this function to create a texture from an existing surface.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────┐
       │ SDL_Texture* SDL_CreateTextureFromSurface(SDL_Renderer*   renderer,  │
       │                                           SDL_Surface*    surface);  │
       └──────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────────────────────────────────────────────────┐
       │ renderer  │ the rendering context                                                    │
       ├───────────┼──────────────────────────────────────────────────────────────────────────┤
       │ surface   │ the SDL_Surface structure containing pixel data used to fill the texture │
       └───────────┴──────────────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  the created texture or NULL on failture; call SDL_GetError() for more
       information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ Uint32 rmask, gmask, bmask, amask;                                                                                          │
       │                                                                                                                             │
       │ /* SDL interprets each pixel as a 32-bit number, so our masks must depend on the endianness (byte order) of the machine */  │
       │ #if SDL_BYTEORDER == SDL_BIG_ENDIAN                                                                                         │
       │   rmask = 0xff000000;                                                                                                       │
       │   gmask = 0x00ff0000;                                                                                                       │
       │   bmask = 0x0000ff00;                                                                                                       │
       │   amask = 0x000000ff;                                                                                                       │
       │ #else                                                                                                                       │
       │   rmask = 0x000000ff;                                                                                                       │
       │   gmask = 0x0000ff00;                                                                                                       │
       │   bmask = 0x00ff0000;                                                                                                       │
       │   amaks = 0xff000000;                                                                                                       │
       │ #endif                                                                                                                      │
       │                                                                                                                             │
       │ SDL_Surface* surface = SDL_CreateRGBSurface(0, 640, 480, 32, rmask, gmask, bmask, amask);                                   │
       │                                                                                                                             │
       │ if (surface == NULL) {                                                                                                      │
       │   fprintf(stderr, "CreateRGBSurface failed: %s0, SDL_GetError());                                                           │
       │   exit(1);                                                                                                                  │
       │ }                                                                                                                           │
       │                                                                                                                             │
       │ SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);                                                     │
       │                                                                                                                             │
       │ if (texture == NULL) {                                                                                                      │
       │   fprintf(stderr, "CreateTextureFromSurface failed: %s0, SDL_GetError());                                                   │
       │   exit(1);                                                                                                                  │
       │ }                                                                                                                           │
       │                                                                                                                             │
       │ SDL_FreeSurface(surface);                                                                                                   │
       │ surface = NULL;                                                                                                             │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The surface is not modified or freed by this function.

       The  SDL_TextureAccess  hint  for  the  created  texture   is   SDL_TEXTUREAC‐
       CESS_STATIC.

       The pixel format of the created texture may be different from the pixel of the
       surface. Use SDL_QueryTexture() to query the pixel format of the texture.

RELATED FUNCTIONS
       SDL_CreateTexture
       SDL_DestroyTexture
       SDL_QueryTexture

===============================================================================
                                                             *SDL_CreateThread*


NAME
       SDL_CreateThread -- Function

SYNOPSIS
       Use this function to create a new thread.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ SDL_Thread* SDL_CreateThread(SDL_ThreadFunction   fn,    │
       │                              const char*          name,  │
       │                              void*                data)  │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬─────────────────────────────────────────────────────────────────┐
       │ fn    │ the function to call in the new thread; see Remarks for details │
       ├───────┼─────────────────────────────────────────────────────────────────┤
       │ name  │ the name of the thread; see Remarks for details                 │
       ├───────┼─────────────────────────────────────────────────────────────────┤
       │ data  │ a pointer that is passed to fn                                  │
       └───────┴─────────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns an opaque pointer to the new thread object on success, NULL if the new
       thread could not be created; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────┐
       │ #include <stdio.h>                                                         │
       │ #include "SDL.h"                                                           │
       │                                                                            │
       │ /* Very simple thread - counts 0 to 9 delaying 50ms between increments */  │
       │ static int TestThread(void* ptr)                                           │
       │ {                                                                          │
       │   int cnt;                                                                 │
       │                                                                            │
       │   for (cnt=0; cnt<10; ++cnt)                                               │
       │   {                                                                        │
       │     printf("Thread counter: %d0, cnt);                                     │
       │     SDL_Delay(50);                                                         │
       │   }                                                                        │
       │                                                                            │
       │   return cnt;                                                              │
       │ }                                                                          │
       │                                                                            │
       │ int main(int argc, char* argv[])                                           │
       │ {                                                                          │
       │   SDL_Thread *thread;                                                      │
       │   int threadReturnValue;                                                   │
       │                                                                            │
       │   printf("Simple SDL_CreateThread test0);                                  │
       │                                                                            │
       │   /* Simple create a thread */                                             │
       │   thread = SDL_CreateThread(TestThread, "TestThread", NULL);               │
       │                                                                            │
       │   if (thread == NULL)                                                      │
       │   {                                                                        │
       │     printf("SDL_Thread failed: %s0, SDL_GetError());                       │
       │   }                                                                        │
       │   else                                                                     │
       │   {                                                                        │
       │     SDL_WaitThread(thread, &threadReturnValue);                            │
       │     printf("Thread returned value: %d0, threadReturnValue);                │
       │   }                                                                        │
       │                                                                            │
       │   return 0;                                                                │
       │ }                                                                          │
       └────────────────────────────────────────────────────────────────────────────┘

       ┌────────────────────────────────┐
       │ Output:                        │
       │ Simple SDL_CreateThread test:  │
       │ Thread counter: 0              │
       │ Thread counter: 1              │
       │ Thread counter: 2              │
       │ Thread counter: 3              │
       │ Thread counter: 4              │
       │ Thread counter: 5              │
       │ Thread counter: 6              │
       │ Thread counter: 7              │
       │ Thread counter: 8              │
       │ Thread counter: 9              │
       │ Thread returned value: 10      │
       └────────────────────────────────┘

REMARKS
       SDL_CreateThread() creates a new thread of execution that shares  all  of  its
       parent's  global  memory,  signal handlers, file descriptors, etc and runs the
       function fn, passing it the void pointer data. The thread quits  when  fn  re‐
       turns.

       The function prototype for fn is:

       ┌──────────────────────────────────────┐
       │ int SDL_ThreadFunction(void* data);  │
       └──────────────────────────────────────┘
       where its parameter is:

       ┌───────┬──────────────────────────────┐
       │ data  │ what  was  passed as data to │
       │       │ SDL_CreateThread()           │
       └───────┴──────────────────────────────┘
       There are no requirements for thread  naming  conventions,  so  long  ass  the
       string  is null-terminated UTF-8, but these guidelines are helpful in choosing
       a name:

       http://stackoverflow.com/questions/149932/naming-conventions-for-threads

       If a system imposes requirements, SDL will try to  munge  the  string  for  it
       (truncate,  etc),  but  the  original  string  contents will be available from
       SDL_GetThreadName().

RELATED FUNCTIONS
       SDL_WaitThread

===============================================================================
                                                             *SDL_CreateWindow*


NAME
       SDL_CreateWindow -- Function

SYNOPSIS
       Use  this function to create a window with the specified position, dimensions,
       and flags.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ SDL_Window* SDL_CreateWindow(const char*    title,  │
       │                              int            x,      │
       │                              int            y,      │
       │                              int            w,      │
       │                              int            h,      │
       │                              Uint32         flags)  │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ title  │ the title of the window,  in │
       │        │ UTF-8 encoding               │
       ├────────┼──────────────────────────────┤
       │ x      │ the  x  position of the win‐ │
       │        │ dow, SDL_WINDOWPOS_CENTERED, │
       │        │ or SDL_WINDOWPOS_UNDEFINED   │
       ├────────┼──────────────────────────────┤
       │ y      │ the  y  position of the win‐ │
       │        │ dow, SDL_WINDOWPOS_CENTERED, │
       │        │ or SDL_WINDOWPOS_UNDEFINED   │
       ├────────┼──────────────────────────────┤
       │ w      │ the  width of the window, in │
       │        │ screen coordinates           │
       ├────────┼──────────────────────────────┤
       │ h      │ the height of the window, in │
       │        │ screen coordinates           │
       ├────────┼──────────────────────────────┤
       │ flags  │ 0,  or none or more SDL_Win‐ │
       │        │ dowFlags OR'd together;  see │
       │        │ Remarks for details          │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the  window  that was created or NULL on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────┐
       │ // Example program                                                            │
       │ // Using SDL2 to create an application window                                 │
       │                                                                               │
       │ #include "SDL.h"                                                              │
       │ #include <stdio.h>                                                            │
       │                                                                               │
       │ int main(int argc, char* argv[])                                              │
       │ {                                                                             │
       │   SDL_Window* window;         // declare a pointer                            │
       │   SDL_Init(SDL_INIT_VIDEO);   // initialize SDL2                              │
       │                                                                               │
       │   // create an application window with the following settings:                │
       │   window = SDL_CreateWindow(                                                  │
       │     "An SDL2 window",         // window title                                 │
       │     SDL_WINDOWPOS_UNDEFINED,  // initial x position                           │
       │     SDL_WINDOWPOS_UNDEFINED,  // initial y position                           │
       │     640,                      // width, in pixels                             │
       │     480,                      // height, in pixels                            │
       │     SDL_WINDOW_OPENGL         // flags - see below                            │
       │   );                                                                          │
       │                                                                               │
       │   // check that the window was successfully created                           │
       │   if (window == NULL)                                                         │
       │   {                                                                           │
       │     // in the case that the window could not be made                          │
       │     printf("Could not create window: %s0, SDL_GetError());                    │
       │     return 1;                                                                 │
       │   }                                                                           │
       │                                                                               │
       │   // The window is open: could enter program loop here (see SDL_PollEvent())  │
       │                                                                               │
       │   SDL_Delay(3000);    // Pause execution for 3000 milliseconds, for example   │
       │                                                                               │
       │   // close and destroy the window                                             │
       │   SDL_DestroyWindow(window);                                                  │
       │                                                                               │
       │   // clean up                                                                 │
       │   SDL_Quit();                                                                 │
       │   return 0;                                                                   │
       │ }                                                                             │
       └───────────────────────────────────────────────────────────────────────────────┘

REMARKS
       flags may be any of the following OR'd together:

       ┌────────────────────────────────┬──────────────────────────────┐
       │ SDL_WINDOW_FULLSCREEN          │ fullscreen window            │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_FULLSCREEN_DESKTOP  │ fullscreen  window  at   the │
       │                                │ current desktop resolution   │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_OPENGL              │ window  usable  with  OpenGL │
       │                                │ context                      │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_VULKAN              │ window usable with a  Vulkan │
       │                                │ instance                     │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_HIDDEN              │ window is not visible        │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_BORDERLESS          │ no window decoration         │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_RESIZABLE           │ window can be resized        │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MINIMIZED           │ window is minimized          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MAXIMIZED           │ window is maximized          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_INPUT_GRABBED       │ window has grabbed input fo‐ │
       │                                │ cus                          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_ALLOW_HIGHDPI       │ window should be created  in │
       │                                │ high-DPI  mode  if supported │
       │                                │ (>= SDL 2.0.1)               │
       └────────────────────────────────┴──────────────────────────────┘
       SDL_WINDOW_SHOWN is ignored by SDL_CreateWindow(). The SDL_Window  is  implic‐
       itly  shown  if  SDL_WINDOW_HIDDEN is not set. SDL_WINDOW_SHOWN may be queried
       later using SDL_GetWindowFlags().

       On Apple's macOS you must set the NSHighResolutionCapable Info.plist  property
       to YES, otherwise you will not receive a High DPI OpenGL canvas.

       If  the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its sizes in
       pixels may differ from its size in screen coordinate on platforms  with  high-
       DPI  support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the client
       area's size in screen coordinates, and  SDL_GetDrawableSize()  or  SDL_GetRen‐
       dererOutputSize() to query the drawable size in pixels.

       If  the window is set fullscreen, the width and height parameters w and h will
       not be used. However, invalid size parameters (e.g. too large) may still fail.
       Window  size  is actually limited to 16384 x 16384 for all platforms at window
       creation.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_CreateWindowFrom
       SDL_DestroyWindow

===============================================================================
                                                  *SDL_CreateWindowAndRenderer*


NAME
       SDL_CreateWindowAndRenderer -- Function

SYNOPSIS
       Use this function to create a window and default renderer.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ int SDL_CreateWindowAndRenderer(int             width,         │
       │                                 int             height,        │
       │                                 Uint32          window_flags,  │
       │                                 SDL_Window**    window,        │
       │                                 SDL_Renderer**  renderer)      │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬───────────────────────────────────────────────────────────────┐
       │ width         │ the width of the window                                       │
       ├───────────────┼───────────────────────────────────────────────────────────────┤
       │ height        │ the height of the window                                      │
       ├───────────────┼───────────────────────────────────────────────────────────────┤
       │ window_flags  │ the flags used to create this window (see SDL_CreateWindow()) │
       ├───────────────┼───────────────────────────────────────────────────────────────┤
       │ window        │ a pointer filled with the window, or NULL on error            │
       ├───────────────┼───────────────────────────────────────────────────────────────┤
       │ renderer      │ a pointer filled with the renderer, or NULL on error          │
       └───────────────┴───────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  0  on  success, or -1 on error; call SDL_GetError() for more informa‐
       tion.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                                             │
       │                                                                                                              │
       │ int main(int argc, char* argv[])                                                                             │
       │ {                                                                                                            │
       │   SDL_Window* window;                                                                                        │
       │   SDL_Renderer* renderer;                                                                                    │
       │   SDL_Surface* surface;                                                                                      │
       │   SDL_Texture* texture;                                                                                      │
       │   SDL_Event* event;                                                                                          │
       │                                                                                                              │
       │   if (SDL_Init(SDL_INIT_VIDEO) < 0)                                                                          │
       │   {                                                                                                          │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't initialize SDL: %s", SDL_GetError());               │
       │     return 3;                                                                                                │
       │   }                                                                                                          │
       │                                                                                                              │
       │   if (SDL_CreateWindowAndRenderer(320, 240, SDL_WINDOW_RESIZABLE, &window, &renderer))                       │
       │   {                                                                                                          │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create window and renderer: %s", SDL_GetError());   │
       │     return 3;                                                                                                │
       │   }                                                                                                          │
       │                                                                                                              │
       │   surface = SDL_LoadBMP("sample.bmp");                                                                       │
       │   if (!surface)                                                                                              │
       │   {                                                                                                          │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create surface from image: %s", SDL_GetError());    │
       │     return 3;                                                                                                │
       │   }                                                                                                          │
       │   texture = SDL_CreateTextureFromSurface(renderer, surface);                                                 │
       │   if (!texture)                                                                                              │
       │   {                                                                                                          │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Couldn't create texture from surface: %s", SDL_GetError());  │
       │     return 3;                                                                                                │
       │   }                                                                                                          │
       │                                                                                                              │
       │   SDL_FreeSurface(surface);                                                                                  │
       │                                                                                                              │
       │   while (1)                                                                                                  │
       │   {                                                                                                          │
       │     SDL_PollEvent(&event);                                                                                   │
       │     if (event.type == SDL_QUIT)                                                                              │
       │     {                                                                                                        │
       │       break;                                                                                                 │
       │     }                                                                                                        │
       │     SDL_SetRenderDrawColor(renderer, 0x00, 0x00, 0x00, 0x00);                                                │
       │     SDL_RenderClear(renderer);                                                                               │
       │     SDL_RenderCopy(renderer, texture, NULL, NULL);                                                           │
       │     SDL_RenderPresent(renderer);                                                                             │
       │   }                                                                                                          │
       │                                                                                                              │
       │   SDL_DestroyTexture(texture);                                                                               │
       │   SDL_DestoryRenderer(renderer);                                                                             │
       │   SDL_DestroyWindow(window);                                                                                 │
       │                                                                                                              │
       │   SDL_Quit();                                                                                                │
       │   return 0;                                                                                                  │
       │ }                                                                                                            │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_CreateRenderer
       SDL_CreateWindow

===============================================================================
                                                         *SDL_CreateWindowFrom*


NAME
       SDL_CreateWindowFrom -- Function

SYNOPSIS
       Use this function to create an SDL window from an existing native window.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ SDL_Window* SDL_CreateWindowFrom(const void* data)  │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ data  │ a  pointer  to driver-depen‐ │
       │       │ dent window  creation  data, │
       │       │ typically your native window │
       │       │ cast to a void*              │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns the window that was created or NULL on  failure;  call  SDL_GetError()
       for more information.

REMARKS
       In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows) the
       hint SDL_HITN_VIDEO_WINDOW_SHARE_PIXEL_FORMAT needs to  be  configured  before
       using SDL_CreateWindowFrom().

RELATED FUNCTIONS
       SDL_CreateWindow
       SDL_DestroyWindow

===============================================================================
                                                         *SDL_CreateYUVOverlay*


NAME
       SDL_CreateYUVOverlay - Create a YUV video overlay

SYNOPSIS
       #include "SDL.h"

       SDL_Overlay   *SDL_CreateYUVOverlay(int  width,  int  height,  Uint32  format,
       SDL_Surface *display);

DESCRIPTION
       SDL_CreateYUVOverlay creates a YUV overlay of the specified width, height  and
       format  (see  SDL_Overlay  for  a list of available formats), for the provided
       display. A SDL_Overlay structure is returned.

       The term 'overlay' is a misnomer since, unless the overlay is created in hard‐
       ware, the contents for the display surface underneath the area where the over‐
       lay is shown will be overwritten when the overlay is displayed.

SEE ALSO
       SDL_Overlay, SDL_DisplayYUVOverlay, SDL_FreeYUVOverlay

===============================================================================
                                                        *SDL_DXGIGetOutputInfo*


NAME
       SDL_DXGIGetOutputInfo -- Function

SYNOPSIS
       Use this function to get the DXGI Adapter and Output indices for the specified
       display index.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ SDL_bool SDL_DXGIGetOutputInfo(int    displayIndex,  │
       │                                int*   adapterIndex,  │
       │                                int*   outputIndex)   │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────────────────────────┐
       │ displayIndex  │ the display index for which to get both indices  │
       ├───────────────┼──────────────────────────────────────────────────┤
       │ adapterIndex  │ a pointer to be filled in with the adapter index │
       ├───────────────┼──────────────────────────────────────────────────┤
       │ outputIndex   │ a pointer to be filled in with the output index  │
       └───────────────┴──────────────────────────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE on success or SDL_FALSE; call SDL_GetError for more  informa‐
       tion.

REMARKS
       The DXGI Adapter and Output indices can be passed to EnumAdapters and EnumOut‐
       puts respectively to get the objects required to create a DX10 or DX11  device
       and swap chain.

       Before  SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it re‐
       turns and SDL_bool.

VERSION
       This function is available since SDL 2.0.2.

===============================================================================
                                                            *SDL_DelEventWatch*


NAME
       SDL_DelEventWatch -- Function

SYNOPSIS
       Use  this  function to remove an event watch callback added with SDL_AddEvent‐
       Watch().

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_DelEventWatch(SDL_EventFilter  filter,    │
       │                        void*            userdata)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ filter    │ the   function    originally │
       │           │ passed    to   SDL_AddEvent‐ │
       │           │ Watch(); see Remarks for de‐ │
       │           │ tails                        │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ the    pointer    originally │
       │           │ passed   to    SDL_AddEvent‐ │
       │           │ Watch()                      │
       └───────────┴──────────────────────────────┘

REMARKS
       This  function  takes  the  same  input as SDL_AddEventWatch() to identify and
       delete the corresonding callback.

RELATED FUNCTIONS
       SDL_AddEventWatch

===============================================================================
                                                          *SDL_DelHintCallback*


NAME
       SDL_DelHintCallback -- Function

SYNOPSIS
       Use this function to remove a function watching a particular hint.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ void SDL_DelHintCallback(const char*        name,      │
       │                          SDL_HintCallback   callback,  │
       │                          void*              userdata)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ name      │ the hint being watched       │
       ├───────────┼──────────────────────────────┤
       │ callback  │ the  function  being  called │
       │           │ when the hint value changes  │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ the pointer being passed  to │
       │           │ the callback function        │
       └───────────┴──────────────────────────────┘

REMARKS
       The function prototype for callback is:

       ┌────────────────────────────────────────────────┐
       │ void SDL_HintCallback(void*         userdata,  │
       │                       const char*   name,      │
       │                       const char*   oldValue,  │
       │                       const char*   newValue)  │
       └────────────────────────────────────────────────┘
       where its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ what  was passed as userdata │
       │           │ to SDL_DelHintCallback()     │
       ├───────────┼──────────────────────────────┤
       │ name      │ what was passed as  name  to │
       │           │ SDL_DelHintCallback()        │
       ├───────────┼──────────────────────────────┤
       │ oldValue  │ the old value                │
       ├───────────┼──────────────────────────────┤
       │ newValue  │ the new value                │
       └───────────┴──────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AddHintCallback

===============================================================================
                                                                    *SDL_Delay*


NAME
       SDL_Delay -- Function

SYNOPSIS
       Use this function to wait a specified number of milliseconds before returning.

SYNTAX
       ┌────────────────────────────┐
       │ void SDL_Delay(Uint32 ms)  │
       └────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────┬─────────────────────────────────────┐
       │ ms  │ the number of milliseconds to delay │
       └─────┴─────────────────────────────────────┘

REMARKS
       This  function  waits  a specified number of milliseconds before returning. It
       waits at least the specified time, but possibly longer due to OS scheduling.

===============================================================================
                                                             *SDL_DequeueAudio*


NAME
       SDL_DequeueAudio -- Function

SYNOPSIS
       Use this function to dequeue more audio on non-callback devices.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ Uint32 SDL_DequeueAudio(SDL_AudioDeviceID     dev,   │
       │                         void*                 data,  │
       │                         Uint32                len)   │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ dev   │ the  device ID from which we │
       │       │ will dequeue audio           │
       ├───────┼──────────────────────────────┤
       │ data  │ a pointer into  where  audio │
       │       │ data should be copied        │
       ├───────┼──────────────────────────────┤
       │ len   │ the  number  of  bytes  (not │
       │       │ samples!)  to  which  (data) │
       │       │ points                       │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns  number  of  bytes  dequeued, which could be less than requested; call
       SDL_GetError() for more information.

REMARKS
       If you are looking to queue audio for output on a  non-callback  playback  de‐
       vice, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always return
       0 if you use it with playback devices.

       SDL offsers two ways to retrieve audio from a capture device: you  can  either
       supply a callback that SDL triggers  with some frequency as the device records
       more audio data, (push method), or you can supply no callback,  and  then  SDL
       will  expect you to retrieve data at regular intervals (pull method) with this
       function.

       There are no limits on the amount of data you can queue, short  of  exhuastion
       of  address space. Data from the device will keep queuing as necessary without
       further intervention from you. This means you will eventually run out of  mem‐
       ory if you aren't routinely dequeueing data.

       Capture  devices  will not queue data when paused; if you are expecting to not
       need captured audio for some length of  time,  use  SDL_PauseAudioDevice()  to
       stop  the  capture  device from queueing more data. This can be useful during,
       say, level loading times. When unpaused, capture devices will  start  queueing
       data  from  that  point,  having  flushed  any capturable data available while
       paused.

       This function is thread-safe, but dequeueing from the  same  device  from  two
       threads at once does not promise which thread will dequeued data first.

       You  may not dequeue audio from a device that is using an application-supplied
       callback; doing so returns an error. You have to use the  audio  callback,  or
       dequeue audio with this function, but not both.

       You should not call SDL_LockAudio() on the device before queueing; SDL handles
       locking internally for this function.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_ClearQueuedAudio
       SDL_GetQueuedAudioSize

===============================================================================
                                                              *SDL_DestroyCond*


NAME
       SDL_DestroyCond -- Function

SYNOPSIS
       Use this function to destroy a condition variable.

SYNTAX
       ┌───────────────────────────────────────┐
       │ void SDL_DestroyCond(SDL_cond* cond)  │
       └───────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ cond  │ the  condition  variable  to │
       │       │ destroy                      │
       └───────┴──────────────────────────────┘

CODE EXAMPLES
       Typical use of condition variables:

       ┌───────────────────────────────────────────┐
       │ SDL_bool condition = SDL_FALSE;           │
       │ SDL_mutex* lock;                          │
       │ SDL_cond* cond;                           │
       │                                           │
       │ lock = SDL_CreateMutex();                 │
       │ cond = SDL_CreateCond();                  │
       │ Thread A:                                 │
       │   SDL_LockMutex(lock);                    │
       │   while (!condition) {                    │
       │     SDL_CondWait(cond, lock);             │
       │   }                                       │
       │   SDL_UnlockMutex(lock);                  │
       │                                           │
       │ Thread B:                                 │
       │   SDL_LockMutex(lock);                    │
       │   ...                                     │
       │   condition = SDL_TRUE;                   │
       │   ...                                     │
       │   SDL_CondSignal(cond);                   │
       │   SDL_UnlockMutex(cond);    SDL_Destroy‐  │
       │ Cond(cond); SDL_DestroyMutex(lock);       │
       └───────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_CondBroadcast
       SDL_CondSignal
       SDL_CondWait
       SDL_CondWaitTimeout
       SDL_CreateCond

===============================================================================
                                                             *SDL_DestroyMutex*


NAME
       SDL_DestroyMutex -- Function

SYNOPSIS
       Use this function to destroy a mutex created with SDL_CreateMutex().

SYNTAX
       ┌──────────────────────────────────────────┐
       │ void SDL_DestroyMutex(SDL_mutex* mutex)  │
       └──────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────┐
       │ mutex  │ the mutex to destroy │
       └────────┴──────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────┐
       │ SDL_mutex* mutex;                            │
       │                                              │
       │ mutex = SDL_CreateMutex();                   │
       │ if (!mutex) {                                │
       │   fprintf(stderr, "Couldn't create mutex0);  │
       │   return;                                    │
       │ }                                            │
       │                                              │
       │ if (SDL_LockMutex(mutex) == 0) {             │
       │   /* Do stuff while mutex is locked */       │
       │   SDL_UnlockMutex(mutex);                    │
       │ } else {                                     │
       │   fprintf(stderr, "Couldn't lock mutex0);    │
       │ }                                            │
       │                                              │
       │ SDL_DestroyMutex(mutex);                     │
       └──────────────────────────────────────────────┘

REMARKS
       This function must be called on any mutex that is no longer needed. Failure to
       destory a mutex will result in a system memory or resource leak. While  it  is
       safe to destroy a mutex that is UNLOCKED, it is not safe to attempt to destroy
       a locked mutex and may result in undefined behavior depending on the platform.

RELATED FUNCTIONS
       SDL_CreateMutex
       SDL_LockMutex
       SDL_TryLockMutex
       SDL_UnlockMutex

===============================================================================
                                                          *SDL_DestroyRenderer*


NAME
       SDL_DestroyRenderer -- Function

SYNOPSIS
       Use this function to destroy the rendering context for a window and free asso‐
       ciated textures.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ void SDL_DestroyRenderer(SDL_Renderer* renderer)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬───────────────────────┐
       │ renderer  │ the rendering context │
       └───────────┴───────────────────────┘

RELATED FUNCTIONS
       SDL_CreateRenderer

===============================================================================
                                                         *SDL_DestroySemaphore*


NAME
       SDL_DestroySemaphore -- Function

SYNOPSIS
       Use this function to destroy a semaphore.

SYNTAX
       ┌──────────────────────────────────────────┐
       │ void SDL_DestroySemaphore(SDL_sem* sem)  │
       └──────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────┐
       │ sem  │ the semaphore to destroy │
       └──────┴──────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────┐
       │ SDL_atomic_t done;                 │
       │ SDL_sem* sem;                      │
       │                                    │
       │ SDL_AtomicSet(&done, 0);           │
       │ sem = SDL_CreateSemaphore(0);      │
       │ Thread A:                          │
       │   while (!SDL_AtomicGet(&done)) {  │
       │     add_data_to_queue();           │
       │     SDL_SemPost(sem);              │
       │   }                                │
       │                                    │
       │ Thread B:                          │
       │   while (!SDL_AtomicGet(&done)) {  │
       │     SDL_SemWait(sem);              │
       │     if (dta_available()) {         │
       │       get_data_from_queue();       │
       │     }                              │
       │   }                                │
       │ SDL_AtomicSet(&done, 1);           │
       │ SDL_SemPost(sem);                  │
       │ wait_for_threads();                │
       │ SDL_DestroySemaphore(sem);         │
       └────────────────────────────────────┘

REMARKS
       It  is  not safe to destroy a semaphore if there are threads currently waiting
       on it.

RELATED FUNCTIONS
       SDL_CreateSemaphore
       SDL_SemPost
       SDL_SemTryWait
       SDL_SemValue
       SDL_SemWait
       SDL_SemWaitTimeout

===============================================================================
                                                           *SDL_DestroyTexture*


NAME
       SDL_DestroyTexture -- Function

SYNOPSIS
       Use this function to destroy the specified texture.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_DestroyTexture(SDL_Texture* texture)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬────────────────────────┐
       │ texture  │ the texture to destroy │
       └──────────┴────────────────────────┘

REMARKS
       Passing NULL or an otherwise invalid texture will set the SDL error message to
       "Invalid texture".

RELATED FUNCTIONS
       SDL_CreateTexture
       SDL_CreateTextureFromSurface

===============================================================================
                                                            *SDL_DestroyWindow*


NAME
       SDL_DestroyWindow -- Function

SYNOPSIS
       Use this function to destroy a window.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ void SDL_DestroyWindow(SDL_Window* window)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬───────────────────────┐
       │ window  │ the window to destroy │
       └─────────┴───────────────────────┘

REMARKS
       If window is NULL, this function will return immediatley after setting the SDL
       error message to "Invalid window". See SDL_GetError().

RELATED FUNCTIONS
       SDL_CreateWindow
       SDL_CreateWindowFrom

===============================================================================
                                                             *SDL_DetachThread*


NAME
       SDL_DetachThread -- Function

SYNOPSIS
       Use this function to let a thread clean up on exit without intervention.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_DetachThread(SDL_Thread* thread)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ thread  │ the  SDL_Thread pointer that │
       │         │ was   returned   from    the │
       │         │ SDL_CreateThread() call that │
       │         │ started this thrad           │
       └─────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────┐
       │ extern int TestThread(void* ptr);                                              │
       │ SDL_Thread* thread = SDL_CreateThread(TestThread, "TestThread", (void*)NULL);  │
       │ SDL_DetachThread(thread);   /* will go away on its own up completion. */       │
       └────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       A thread may be "detached" to signify that it should not remain until  another
       thread  has  called  SDL_WaitThread()  on it. Detaching a thread is useful for
       long-running threads that nothing needs to synchronize with or further manage.
       When a detached thread is done, it simply goes away.

       Three  is  no way to recover the return code of a detached thread. If you need
       this, don't detach the thread and instead use SDL_WaitThread().

       Once a thread is detached, you should usually assume the SDL_Thread isn't safe
       to  reference  again,  as it will become invalid immediately upon the detached
       thread's exit, instead of remaining until someone has called  SDL_WaitThread()
       to finally clean it up. As such, don't detach the same thread more than once.

       If a thread has already exited when passed to SDL_DetachThread(), it will stop
       waiting for a call to SDL_WaitThread() and clean up  immediately.  It  is  not
       safe to detach a thread that might be used with SDL_WaitThread().

       You  may not call SDL_WaitThread() on a thread that has been detached. Use ei‐
       ther that function or this one, but not both, or behavior is undefined.

       It is safe to pass NULL to this function; it is a no-op.

VERSION
       This function is available since SDL 2.0.2.

RELATED FUNCTIONS
       SDL_CreateThread
       SDL_WaitThread

===============================================================================
                                                 *SDL_Direct3D9GetAdapterIndex*


NAME
       SDL_Direct3D9GetAdapterIndex -- Function

SYNOPSIS
       Use  this  function  to  get the D3D9 adapter index that matches the specified
       display index.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_Direct3D9GetAdapterIndex(int displayIndex)  │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the display index for  which │
       │               │ to  get the D3D0 adapter in‐ │
       │               │ dex                          │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the D3D0 adapter index on success or a negative error code on failure;
       call SDL_GetError() for more information.

REMARKS
       The  returned adapter index can be passed to IDirect3D9::CreateDevice and con‐
       trols on which monitor a full screen application will appear.

VERSION
       This function is available since SDL 2.0.1.

===============================================================================
                                                       *SDL_DisableScreenSaver*


NAME
       SDL_DisableScreenSaver -- Function

SYNOPSIS
       Use this function to prevent the screen from being blanked by a screen saver.

SYNTAX
       ┌────────────────────────────────────┐
       │ void SDL_DisableScreenSaver(void)  │
       └────────────────────────────────────┘

REMARKS
       If you disable the screensaver, it is automatically re-enabled when SDL quits.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_EnableScreenSaver
       SDL_IsScreenSaverEnabled

===============================================================================
                                                            *SDL_DisplayFormat*


NAME
       SDL_DisplayFormat - Convert a surface to the display format

SYNOPSIS
       #include "SDL.h"

       SDL_Surface *SDL_DisplayFormat(SDL_Surface *surface);

DESCRIPTION
       This function takes a surface and copies it to a new surface of the pixel for‐
       mat and colors of the video framebuffer, suitable for fast blitting  onto  the
       display surface. It calls SDL_ConvertSurface

       If you want to take advantage of hardware colorkey or alpha blit acceleration,
       you should set the colorkey and alpha value before calling this function.

       If you want an alpha channel, see SDL_DisplayFormatAlpha.

RETURN VALUE
       If the conversion fails or runs out of memory, it returns NULL

SEE ALSO
       SDL_ConvertSurface,  SDL_DisplayFormatAlpha   SDL_SetAlpha,   SDL_SetColorKey,
       SDL_Surface

===============================================================================
                                                       *SDL_DisplayFormatAlpha*


NAME
       SDL_DisplayFormatAlpha - Convert a surface to the display format

SYNOPSIS
       #include "SDL.h"

       SDL_Surface *SDL_DisplayFormatAlpha(SDL_Surface *surface);

DESCRIPTION
       This function takes a surface and copies it to a new surface of the pixel for‐
       mat and colors of the video framebuffer plus an alpha  channel,  suitable  for
       fast blitting onto the display surface. It calls SDL_ConvertSurface

       If you want to take advantage of hardware colorkey or alpha blit acceleration,
       you should set the colorkey and alpha value before calling this function.

       This function can be used to convert a colourkey to an alpha channel,  if  the
       SDL_SRCCOLORKEY flag is set on the surface. The generated surface will then be
       transparent (alpha=0) where the pixels match the colourkey,  and  opaque  (al‐
       pha=255) elsewhere.

RETURN VALUE
       If the conversion fails or runs out of memory, it returns NULL

SEE ALSO
       SDL_ConvertSurface, SDL_SetAlpha, SDL_SetColorKey, SDL_DisplayFormat, SDL_Sur‐
       face

===============================================================================
                                                              *SDL_DisplayMode*


NAME
       SDL_DisplayMode -- Structure

SYNOPSIS
       A structure that contains the description of a display mode.

DATA FIELDS
       ┌─────────┬──────────────┬───────────────────────┐
       │ Uint32  │ format       │ one  of  the SDL_Pix‐ │
       │         │              │ elFormatEnum  values; │
       │         │              │ see  Remarks  for de‐ │
       │         │              │ tails                 │
       ├─────────┼──────────────┼───────────────────────┤
       │ int     │ w            │ width, in screen  co‐ │
       │         │              │ ordinates             │
       ├─────────┼──────────────┼───────────────────────┤
       │ int     │ h            │ height, in screen co‐ │
       │         │              │ ordinates             │
       ├─────────┼──────────────┼───────────────────────┤
       │ int     │ refresh_rate │ refresh rate (in Hz), │
       │         │              │ or 0 for unspecified  │
       ├─────────┼──────────────┼───────────────────────┤
       │ void*   │ driverdata   │ driver-specific data, │
       │         │              │ initialize to 0       │
       └─────────┴──────────────┴───────────────────────┘

CODE EXAMPLES
       static int display_in_use = 0;/* Only using first display */
       int i, display_mode_count;
       SDL_DisplayMode mode;
       Uint32 f;

       SDL_Log("SDL_GetNumVideoDisplays(): %i", SDL_GetNumVideoDisplay());

       display_mode_count = SDL_GetNumDisplayModes(display_in_use);
       if (display_mode_count < 1) {
                SDL_Log("SDL_GetNumDisplayModes failed: %s", SDL_GetError());
                return 1;
       }
       SDL_Log("SDL_GetNumDisplayModes: %i", display_mode_count);

       for (i=0; i < display_mode_count; ++i) {
                if (SDL_GetDisplayMode(display_in_use, i, &mode) != 0) {
                               SDL_Log("SDL_GetDisplayMode failed: %s", SDL_GetError());
                               return 1;
                }
                f = mode.format;

                SDL_Log("Mode %ibpp %i%s%i x %i", i, SDL_BITSPERPIXEL(f), SDL_GetPixelFormatName(f), mode.w, mode.h);
       }

REMARKS
       format may be one of the following:

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar mode: Y + V  +  U  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar  mode:  Y  + U + V (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packed mode: Y0+U0+Y1+V0  (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed  mode: U0+Y0+V0+Y1 (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed mode: Y0+V0+Y1+U0  (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar  mode: Y + U/V inter‐ │
       │                              │ leaved (2  planes)  (>=  SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar  mode: Y + V/U inter‐ │
       │                              │ leaved (2  planes)  (>=  SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetClosestDisplayMode
       SDL_GetCurrentDisplayMode
       SDL_GetDesktopDisplayMode
       SDL_GetDisplayMode
       SDL_GetNumDisplayModes
       SDL_GetWindowDisplayMode
       SDL_SetWindowDisplayMode

===============================================================================
                                                        *SDL_DisplayYUVOverlay*


NAME
       SDL_DisplayYUVOverlay - Blit the overlay to the display

SYNOPSIS
       #include "SDL.h"

       int SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect);

DESCRIPTION
       Blit  the  overlay  to the surface specified when it was created. The SDL_Rect
       structure, dstrect, specifies the position and size of the destination. If the
       dstrect  is  a  larger  or  smaller  than the overlay then the overlay will be
       scaled, this is optimized for 2x scaling.

RETURN VALUES
       Returns 0 on success

SEE ALSO
       SDL_Overlay, SDL_CreateYUVOverlay

===============================================================================
                                                       *SDL_DollarGestureEvent*


NAME
       SDL_DollarGestureEvent -- Structure

SYNOPSIS
       A structure that contains complex gesture event information.

DATA FIELDS
       ┌────────────────┬────────────┬───────────────────────┐
       │ Uint32         │ type       │ SDL_DOLLARGESTURE  or │
       │                │            │ SDL_DOLLARRECORD      │
       ├────────────────┼────────────┼───────────────────────┤
       │ Uint32         │ timetamp   │ timestamp   of    the │
       │                │            │ event                 │
       ├────────────────┼────────────┼───────────────────────┤
       │ SDL_TouchID    │ touchId    │ the touch device id   │
       ├────────────────┼────────────┼───────────────────────┤
       │ SDL_GestureID  │ gestureId  │ the  unique id of the │
       │                │            │ closest  gesture   to │
       │                │            │ the performed stroke  │
       ├────────────────┼────────────┼───────────────────────┤
       │ Uint32         │ numFingers │ the number of fingers │
       │                │            │ used  to   draw   the │
       │                │            │ stroke                │
       ├────────────────┼────────────┼───────────────────────┤
       │ float          │ error      │ the   difference  be‐ │
       │                │            │ tween   the   gesture │
       │                │            │ template  and the ac‐ │
       │                │            │ tual  performed  ges‐ │
       │                │            │ ture  (lower error is │
       │                │            │ a better match)       │
       ├────────────────┼────────────┼───────────────────────┤
       │ float          │ x          │ the normalized center │
       │                │            │ of gesture            │
       ├────────────────┼────────────┼───────────────────────┤
       │ float          │ y          │ the normalized center │
       │                │            │ of gesture            │
       └────────────────┴────────────┴───────────────────────┘

REMARKS
       SDL_DollarGestureEvent is a member of the SDL_Event union and is used when  an
       event  of  type SDL_DOLLARGESTURE is reported. You would access it through the
       event's dgesture field.

       x and y are in range 0 to 1.

       For SDL_DOLLARRECORD only touchId and gestureId are valid.

       For    more    information     see:     README-gesture.md     (https://hg.lib‐
       sdl.org/SDL/file/default/docs/README-gesture.md)

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_MultiGestureEVent

===============================================================================
                                                                *SDL_DropEvent*


NAME
       SDL_DropEvent -- Structure

SYNOPSIS
       A structure that contains an event used to request a file open by the system.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ the     event    type │
       │         │           │ SDL_DROPFILE,         │
       │         │           │ SDL_DROPTEXT,         │
       │         │           │ SDL_DROPBEGIN,     or │
       │         │           │ SDL_DROPCOMPLETE      │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ timestamp    of   the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ char*   │ file      │ the file name,  which │
       │         │           │ should  be freed with │
       │         │           │ SDL_free(),  is  NULL │
       │         │           │ on BEGIN/COMPLETE     │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ windowID  │ the  window  that was │
       │         │           │ dropped on, if any    │
       └─────────┴───────────┴───────────────────────┘

CODE EXAMPLES
       // Example program:
       // SDL_DropEvent usage

       #include "SDL.h"

       int main(int argc, char *argv[]) {
                SDL_bool done;
                SDL_Window *window;
                SDL_Event event;// Declare event handle
                char* dropped_filedir;// Pointer for directory of dropped file

                SDL_Init(SDL_INIT_VIDEO);// SDL2 initialization

                window = SDL_CreateWindow(// Create a window
                            "SDL_DropEvent usage, please drop the file on window",
                            SDL_WINDOWPOS_CENTERED,
                            SDL_WINDOWPOS_CENTERED,
                            640,
                            480,
                            SDL_WINDOW_OPENGL
                );

                // Check that the window was successfully made
                if (window == NULL) {
                            // In the event that the window could not be made...
                            SDL_Log("Could not create window: %s", SDL_GetError());
                            SDL_Quit();
                            return 1;
                }

                SDL_EventState(SDL_DROPFILE, SDL_ENABLE);

                done = SDL_FALSE;
                while (!done) {
                            while (!done && SDL_PollEvent(&event)) {
                            switch (event.type) {
                            case SDL_QUIT: {// In case of exit
                            done = SDL_TRUE;
                            break;
                            }

                            case SDL_DROPFILE: {// In case of dropped file
                            dropped_filedir = event.drop.file;
                            // Shows directory of dropped file
                            SDL_ShowSimpleMessageBox(
                            SDL_MESSAGEBOX_INFORMATION,
                            "File dropped on window",
                            dropped_filedir,
                            window
                            );
                            SDL_free(dropped_filedir);// Free dropped_diledir memory
                            break;
                            }
                            }
                            }
                            SDL_Delay(0);
                }

                SDL_DestroyWindow(window);// Close and destroy the window
                SDL_Quit(); // Clean up
                return 0;
       }

REMARKS
       SDL_DropEvent is a member of the SDL_Event union and is used when an event  of
       type  SDL_DROPFILE,  SDL_DROPTEXT,  SDL_DROPBEGIN,  or SDL_DROPCOMPLETE is re‐
       ported. You would access it through the event's drop field.

       These events are enabled by default. You can disable it with SDL_EventState().

       If these events are enabled you must free the filename  in  the  events  using
       SDL_free().

       SDL_DROPTEXT,  SDL_DROPBEGIN,  and  SDL_DROPCOMPLETE  are  available since SDL
       2.0.5.

   macOS
       To enable drag & drop on your SDL app, you  must  also  edit  your  info.plist
       file.  Add/Modify  Document Types. For examples, to enable all document types,
       add the "public.data" mime type as a document type.

VERSION
       This structure is available since SDL 2.0.0.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

RELATED FUNCTIONS
       SDL_EventState

===============================================================================
                                                          *SDL_EnableKeyRepeat*


NAME
       SDL_EnableKeyRepeat - Set keyboard repeat rate.

SYNOPSIS
       #include "SDL.h"

       int SDL_EnableKeyRepeat(int delay, int interval);

DESCRIPTION
       Enables or disables the keyboard repeat rate. delay specifies how long the key
       must be pressed before it begins repeating, it then repeats at the speed spec‐
       ified by interval. Both delay and interval are expressed in milliseconds.

       Setting  delay to 0 disables key repeating completely. Good default values are
       SDL_DEFAULT_REPEAT_DELAY and SDL_DEFAULT_REPEAT_INTERVAL.

RETURN VALUE
       Returns 0 on success and -1 on failure.

===============================================================================
                                                        *SDL_EnableScreenSaver*


NAME
       SDL_EnableScreenSaver -- Function

SYNOPSIS
       Use this function to allow the screen to be blanked by a screen saver.

SYNTAX
       ┌───────────────────────────────────┐
       │ void SDL_EnableScreenSaver(void)  │
       └───────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_DisableScreenSaver
       SDL_IsScreenSaverEnabled

===============================================================================
                                                            *SDL_EnableUNICODE*


NAME
       SDL_EnableUNICODE - Enable UNICODE translation

SYNOPSIS
       #include "SDL.h"

       int SDL_EnableUNICODE(int enable);

DESCRIPTION
       Enables/Disables Unicode keyboard translation.

       To  obtain the character codes corresponding to received keyboard events, Uni‐
       code translation must first be turned on using this function. The  translation
       incurs  a slight overhead for each keyboard event and is therefore disabled by
       default. For each subsequently received key down event, the unicode member  of
       the  SDL_keysym  structure will then contain the corresponding character code,
       or zero for keysyms that do not correspond to any character code.

       A value of 1 for enable enables Unicode translation; 0  disables  it,  and  -1
       leaves it unchanged (useful for querying the current translation mode).

       Note that only key press events will be translated, not release events.

RETURN VALUE
       Returns the previous translation mode (0 or 1).

SEE ALSO
       SDL_keysym

===============================================================================
                                                            *SDL_EnclosePoints*


NAME
       SDL_EnclosePoints -- Function

SYNOPSIS
       Use this function to calculate a minimal rectangle enclosing a set of points.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_EnclosePoints(const SDL_Point*   points,  │
       │                            int                count,   │
       │                            const SDL_Rect*    clip,    │
       │                            SDL_Rect*          result)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ points  │ an  array of SDL_Pointstruc‐ │
       │         │ tures representing points to │
       │         │ be enclosed                  │
       ├─────────┼──────────────────────────────┤
       │ count   │ the  number of structures in │
       │         │ the points array             │
       ├─────────┼──────────────────────────────┤
       │ clip    │ an SDL_Rect  structure  used │
       │         │ for  clipping or NULL to en‐ │
       │         │ close all  points;  see  Re‐ │
       │         │ marks for details            │
       ├─────────┼──────────────────────────────┤
       │ result  │ an SDL_Rect structure filled │
       │         │ in with the minimal  enclos‐ │
       │         │ ing rectangle                │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  SDL_TRUE  if  any points were enclosed or SDL_FALSE if all the points
       were outside of the clipping rectangle.

REMARKS
       If clip is not NULL then only points inside of the clipping rectangle are con‐
       sidered.

===============================================================================
                                                                    *SDL_Event*


NAME
       SDL_Event -- Structure

SYNOPSIS
       A structure that contains structures for the different event types.

DATA FIELDS
       ┌────────────────────────────┬──────────┬───────────────────────┐
       │ Uint32                     │ type     │ event   type,  shared │
       │                            │          │ with all events       │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_CommonEvent            │ common   │ common event data     │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_WindowEvent            │ window   │ window event data     │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_KeyboardEvent          │ key      │ keyboard event data   │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_TextEditingEvent       │ edit     │ text  editing   event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_TextInputEvent         │ text     │ text input event data │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_MouseMotionEvent       │ motion   │ mouse   motion  event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_MouseButtonEvent       │ button   │ mouse  button   event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_MouseWheelEvent        │ wheel    │ mouse   wheel   event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_JoyAxisEvent           │ jaxis    │ joystick  axis  event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_JoyBallEvent           │ jball    │ joystick  ball  event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_JoyHatEvent            │ jhat     │ joystick  hat   event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_JoyButtonEvent         │ jbutton  │ joystick button event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_JoyDeviceEvent         │ jdevice  │ joystick device event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_ControllerAxisEvent    │ caxis    │ game  controller axis │
       │                            │          │ event data            │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_ControllerButtonEvent  │ cbutton  │ game controller  but‐ │
       │                            │          │ ton event data        │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_ControllerDeviceEvent  │ cdevice  │ game  controller  de‐ │
       │                            │          │ vice event data       │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_AudioDeviceEvent       │ adevice  │ audio  device   event │
       │                            │          │ data (>= SDL 2.0.4)   │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_QuitEvent              │ quit     │ quit   request  event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_UserEvent              │ user     │ custom event data     │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_SysWMEvent             │ syswm    │ system dependent win‐ │
       │                            │          │ dow event data        │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_TouchFingerEvent       │ tfinger  │ touch   finger  event │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_MultiGestureEvent      │ mgesture │ multi-finger  gesture │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_DollarGestureEvent     │ dgesture │ multi-finger  gesture │
       │                            │          │ data                  │
       ├────────────────────────────┼──────────┼───────────────────────┤
       │ SDL_DropEvent              │ drop     │ drag and  drop  event │
       │                            │          │ data                  │
       └────────────────────────────┴──────────┴───────────────────────┘

REMARKS
       The SDL_Event structure is the core of all event handling in SDL. SDL_Event is
       a union of all event structure used in SDL. Using it is  a  simple  matter  of
       knowing  which  event  type corresponds to which union member. The table below
       lists these relationships.

       The SDL_Event structure has two uses:
         - Reading events from the event queue
         - Placing events on the event queue

   Reading events from the event queue
       Reading events from the event queue is done  with  either  SDL_PollEvent()  or
       SDL_PeepEvent(). We'll use SDL_PollEvent() and step through an example.

       First off, we create an empty SDL_Event structure.

       ┌────────────────────────┐
       │ SDL_Event test_event;  │
       └────────────────────────┘

       SDL_PollEvent()  removes  the next event from the event queue. If there are no
       events on the queue it returns 0, otherwise it returns 1. We use a while  loop
       to process each event in turn.

       ┌───────────────────────────────────────┐
       │ while (SDL_PollEvent(&test_event)) {  │
       └───────────────────────────────────────┘

       The SDL_PollEvent() function takes a pointer to an SDL_Event structure that is
       to be filled with event information. We know that if  SDL_PollEvent()  removes
       an  event  from  the  queue  then  the event information will be placed in our
       test_event structure, but we also know that the type of event will  be  placed
       in  the  type member of test_event. So to handle each event type separately we
       use a switch statement.

       ┌─────────────────────────────┐
       │ switch (test_event.type) {  │
       └─────────────────────────────┘

       We need to know what kind of events we're looking for and the event  types  of
       those  events.  So let's assume we want to detect where the user is moving the
       mouse pointer within our application. We look through our event types and  no‐
       tice  that  SDL_MOUSEMOTION is, more than likely, the event we're looking for.
       Looking at the table below tells us that SDL_MOUSEMOTION  events  are  handled
       within  the  SDL_MouseMotionEvent  structure  which  is  the  motion member of
       SDL_Event. We can check for  SDL_MOUSEMOTION  event  type  within  our  switch
       statement like so:

       ┌──────────────────────────┐
       │   case SDL_MOUSEMOTION:  │
       └──────────────────────────┘

       All  we  need  to  do  now is read the information out of the motion member of
       test_event.

       ┌───────────────────────────────────────────────────────────────────────────────────────────────┐
       │     printf("We got a motion event.\n");                                                       │
       │     printf("Current mouse position is: (%d, %d)0, test_event.motion.x, test_event.motion.y);  │
       │     break;                                                                                    │
       │   default:                                                                                    │
       │     printf("Unhandled Event!\n");                                                             │
       │     break;                                                                                    │
       │   }                                                                                           │
       │ }                                                                                             │
       │ printf("Event queue empty.\n");                                                               │
       └───────────────────────────────────────────────────────────────────────────────────────────────┘

   Placing events on the event queue
       It is also possible to push events onto the event queue and so  use  it  as  a
       two-way communication path. Both SDL_PushEvent() and SDL_PeepEvent() allow you
       to place events onto the  event  queue.  This  is  usually  used  to  place  a
       SDL_USEREVENT  on the event queue, however you could use it to post fake input
       events if you wished. Creating your own events is a simple matter of  choosing
       the  event  type you want, setting the type member and filling the appropriate
       member structure with information.

       ┌───────────────────────────────────┐
       │ SDL_Event user_event;             │
       │                                   │
       │ user_event.type = SDL_USEREVENT;  │
       │ user_event.user.code = 2;         │
       │ user_event.user.data1 = NULL;     │
       │ user_event.user.data2 = NULL;     │
       │ SDL_PushEvent(&user_event);       │
       └───────────────────────────────────┘

   Relationships between event types and union members
       ┌───────────────────────────┬───────────────────────────┬─────────────────┐
       │        Event Type         │      Event Structure      │ SDL_Event Field │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_AUDIODEVICEADDED      │ SDL_AudioDeviceEvent      │ adevice         │
       │ SDL_AUDIODEVICEREMOVED    │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_CONTROLLERAXISMOTION  │ SDL_ControllerAxisEvent   │ caxis           │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_CONTROLLERBUTTONDOWN  │ SDL_ControllerButtonEvent │ cbutton         │
       │ SDL_CONTROLLERBUTTONUP    │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_CONTROLLERDE‐         │ SDL_ControllerDeviceEvent │ cdevice         │
       │ VICEADDED                 │                           │                 │
       │ SDL_CONTROLLERDEVICERE‐   │                           │                 │
       │ MOVED                     │                           │                 │
       │ SDL_CONTROLLERDE‐         │                           │                 │
       │ VICEREMAPPED              │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_DOLLARGESTURE         │ SDL_DollarGestureEvent    │ dgesture        │
       │ SDL_DOLLARRECORD          │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_DROPFILE              │ SDL_DropEvent             │ drop            │
       │ SDL_DROPTEXT              │                           │                 │
       │ SDL_DROPBEGIN             │                           │                 │
       │ SDL_DROPCOMPLETE          │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_FINGERMOTION          │ SDL_TouchFignerEvent      │ tfinger         │
       │ SDL_FINGERDOWN            │                           │                 │
       │ SDL_FINGERUP              │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_KEYDOWN               │ SDL_KeyboardEvent         │ key             │
       │ SDL_KEYUP                 │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_JOYAXISMOTION         │ SDL_JoyAxisEvent          │ jaxis           │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_JOYBALLMOTION         │ SDL_JoyBallEvent          │ jball           │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_JOYHATMOTION          │ SDL_JoyHatEvent           │ jhat            │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_JOYBUTTONDOWN         │ SDL_JoyButtonEvent        │ jbutton         │
       │ SDL_JOYBUTTONUP           │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_JOYDEVICEADDED        │ SDL_JoyDeviceEvent        │ jdevice         │
       │ SDL_JOYDEVICEREMOVED      │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_MOUSEMOTION           │ SDL_MouseMotionEvent      │ motion          │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_MOUSEBUTTONDOWN       │ SDL_MouseButtonEvent      │ button          │
       │ SDL_MOUSEBUTTONUP         │                           │                 │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_MOUSEWHEEL            │ SDL_MouseWheelEvent       │ wheel           │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_MULTIGESTURE          │ SDL_MultiGestureEvent     │ mgesture        │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_QUIT                  │ SDL_QuitEvent             │ quit            │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_SYSWMEVENT            │ SDL_SysWMEvent            │ syswm           │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_TEXTEDITING           │ SDL_TextEditingEvent      │ edit            │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_TEXTINPUT             │ SDL_TextInputEvent        │ text            │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_USEREVENT             │ SDL_UserEvent             │ user            │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ SDL_WINDOWEVENT           │ SDL_WindowEvent           │ window          │
       ├───────────────────────────┼───────────────────────────┼─────────────────┤
       │ Other events              │ SDL_CommonEvent           │ none, use .type │
       └───────────────────────────┴───────────────────────────┴─────────────────┘

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_AudioDeviceEvent
       SDL_ControllerAxisEvent
       SDL_ControllerButtonEvent
       SDL_ControllerDeviceEvent
       SDL_DollarGestureEvent
       SDL_DropEvent
       SDL_JoyAxisEvent
       SDL_JoyBallEvent
       SDL_JoyButtonEvent
       SDL_JoyDeviceEvent
       SDL_JoyHatEvent
       SDL_KeyboardEvent
       SDL_MouseButtonEvent
       SDL_MouseMotionEvent
       SDL_MouseWheelEvent
       SDL_MultiGestureEvent
       SDL_QuitEvent
       SDL_SysWMEvent
       SDL_TextEditingEvent
       SDL_TextInputEvent
       SDL_TouchFingerEvent
       SDL_UserEvent
       SDL_WindowEvent

RELATED FUNCTIONS
       SDL_PeepEvents
       SDL_PollEvent
       SDL_PushEvent
       SDL_WaitEvent
       SDL_WaitEventTimeout

===============================================================================
                                                               *SDL_EventState*


NAME
       SDL_EventState -- Function

SYNOPSIS
       Use this function to set the state of processing events by type.

SYNTAX
       ┌───────────────────────────────────────┐
       │ Uint8 SDL_EventState(Uint32   type,   │
       │                      int      state)  │
       └───────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ type   │ the   type   of  event;  see │
       │        │ SDL_EventType for details    │
       ├────────┼──────────────────────────────┤
       │ state  │ how to  process  the  event; │
       │        │ see Remarks for details      │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns  SDL_DISABLE  or  SDL_ENABLE, representing the processing state of the
       event before this function makes any changes to it.

REMARKS
       state may be any of the following:

       ┌─────┬────────────────────────────────┬───────────────────────┐
       │ -1  │  SDL_QUERY                     │ returns  the  current │
       │     │                                │ processing  state  of │
       │     │                                │ the specified event   │
       ├─────┼────────────────────────────────┼───────────────────────┤
       │ 0   │  SDL_IGNORE (aka SDL_DISABLE)  │ the event will  auto‐ │
       │     │                                │ matically  be dropped │
       │     │                                │ from the event  queue │
       │     │                                │ and  will not be fil‐ │
       │     │                                │ tered                 │
       ├─────┼────────────────────────────────┼───────────────────────┤
       │ 1   │  SDL_ENABLE                    │ the  event  will   be │
       │     │                                │ processed normally    │
       └─────┴────────────────────────────────┴───────────────────────┘

RELATED FUNCTIONS
       SDL_GetEventState

===============================================================================
                                                                *SDL_EventType*


NAME
       SDL_EventType -- Enumerations

SYNOPSIS
       An enumeration of the types of events that can be delivered.

DESCRIPTION
       Values

       ┌─────────────────┬────────────────────────┐
       │ SDL_FIRSTEVENT  │ do not remove (unused) │
       └─────────────────┴────────────────────────┘

       Application Events

       ┌───────────┬──────────────────────────────┐
       │ SDL_QUIT  │ user-requested quit; see Re‐ │
       │           │ marks for details.           │
       └───────────┴──────────────────────────────┘

       Android, iOS and WinRT events; see Remarks for details

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_APP_TERMINATING          │ OS is terminating the appli‐ │
       │                              │ cation                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_APP_LOWMEMORY            │ OS  is  low  on memory; free │
       │                              │ some                         │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_APP_WILLENTERBACKGROUND  │ application   is    entering │
       │                              │ background                   │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_APP_DIDENTERBACKGROUND   │ application   entered  back‐ │
       │                              │ ground                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_APP_WILLENTERFOREGROUND  │ application   is    entering │
       │                              │ foreground                   │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_APP_DIDENTERFOREGROUND   │ application   entered  fore‐ │
       │                              │ ground                       │
       └──────────────────────────────┴──────────────────────────────┘

       Window events

       ┌──────────────────┬───────────────────────┐
       │ SDL_WINDOWEVENT  │ window state chagne   │
       ├──────────────────┼───────────────────────┤
       │ SDL_SYSWMEVENT   │ system specific event │
       └──────────────────┴───────────────────────┘

       Keyboard events

       ┌────────────────────┬──────────────────────────────┐
       │ SDL_KEYDOWN        │ key pressed                  │
       ├────────────────────┼──────────────────────────────┤
       │ SDL_KEYUP          │ key released                 │
       ├────────────────────┼──────────────────────────────┤
       │ SDL_TEXTEDITING    │ keyboard text editing  (com‐ │
       │                    │ position)                    │
       ├────────────────────┼──────────────────────────────┤
       │ SDL_TEXTINPUT      │ keyboard text input          │
       ├────────────────────┼──────────────────────────────┤
       │ SDL_KEYMAPCHANGED  │ keymap changed due to a sys‐ │
       │                    │ tem event such as  an  input │
       │                    │ language  or keyboard layout │
       │                    │ change (>= SDL 2.0.4)        │
       └────────────────────┴──────────────────────────────┘

       Mouse events

       ┌──────────────────────┬───────────────────────┐
       │ SDL_MOUSEMOTION      │ mouse moved           │
       ├──────────────────────┼───────────────────────┤
       │ SDL_MOUSEBUTTONDOWN  │ mouse button pressed  │
       ├──────────────────────┼───────────────────────┤
       │ SDL_MOUSEBUTTONUP    │ mouse button released │
       ├──────────────────────┼───────────────────────┤
       │ SDL_MOUSEWHEEL       │ mouse wheel motion    │
       └──────────────────────┴───────────────────────┘

       Joystick events

       ┌───────────────────────┬──────────────────────────────┐
       │ SDL_JOYAXISMOTION     │ joystick axis motion         │
       ├───────────────────────┼──────────────────────────────┤
       │ SDL_JOYALLMOTION      │ joystick trackball motion    │
       ├───────────────────────┼──────────────────────────────┤
       │ SDL_JOYHATMOTION      │ joystick hat position change │
       ├───────────────────────┼──────────────────────────────┤
       │ SDL_JOYBUTTONDOWN     │ joystick button pressed      │
       ├───────────────────────┼──────────────────────────────┤
       │ SDL_JOYBUTTONUP       │ joystick button released     │
       ├───────────────────────┼──────────────────────────────┤
       │ SDL_JOYDEVICEADDED    │ joystick connected           │
       ├───────────────────────┼──────────────────────────────┤
       │ SDL_JOYDEVICEREMOVED  │ joystick disconnected        │
       └───────────────────────┴──────────────────────────────┘

       Controller events

       ┌───────────────────────────────┬────────────────────────────┐
       │ SDL_CONTROLLERAXISMOTION      │ controller axis motion     │
       ├───────────────────────────────┼────────────────────────────┤
       │ SDL_CONTROLLERBUTTONDOWN      │ controller button pressed  │
       ├───────────────────────────────┼────────────────────────────┤
       │ SDL_CONTROLLERBUTTONUP        │ controller button released │
       ├───────────────────────────────┼────────────────────────────┤
       │ SDL_CONTROLLERDEVICEADDED     │ controller connected       │
       ├───────────────────────────────┼────────────────────────────┤
       │ SDL_CONTROLLERDEVICEREMOVED   │ controller disconnected    │
       ├───────────────────────────────┼────────────────────────────┤
       │ SDL_CONTROLLERDEVICEREMAPPED  │ controller mapping updated │
       └───────────────────────────────┴────────────────────────────┘

       Touch events

       ┌───────────────────┬──────────────────────────────┐
       │ SDL_FINGERDOWN    │ user has touched  input  de‐ │
       │                   │ vice                         │
       ├───────────────────┼──────────────────────────────┤
       │ SDL_FINGERUP      │ user  stopped touching input │
       │                   │ device                       │
       ├───────────────────┼──────────────────────────────┤
       │ SDL_FINGERMOTION  │ user is dragging  finger  on │
       │                   │ input device                 │
       └───────────────────┴──────────────────────────────┘

       Gesture events

       ┌────────────────────┬───┐
       │ SDL_DOLLARGESTURE  │   │
       ├────────────────────┼───┤
       │ SDL_DOLLARRECORD   │   │
       ├────────────────────┼───┤
       │ SDL_MULTIGESTURE   │   │
       └────────────────────┴───┘

       Clipboard events

       ┌──────────────────────┬───────────────────────┐
       │ SDL_CLIPBOARDUPDATE  │ the clipboard changed │
       └──────────────────────┴───────────────────────┘

       Drag and drop events

       ┌───────────────────┬──────────────────────────────┐
       │ SDL_DROPFILE      │ the  system  requests a file │
       │                   │ open                         │
       ├───────────────────┼──────────────────────────────┤
       │ SDL_DROPTEXT      │ text/plain     drag-and-drop │
       │                   │ event                        │
       ├───────────────────┼──────────────────────────────┤
       │ SDL_DROPBEGIN     │ a new set of drops is begin‐ │
       │                   │ ning (>= SDL 2.0.5)          │
       ├───────────────────┼──────────────────────────────┤
       │ SDL_DROPCOMPLETE  │ current set of drops is  now │
       │                   │ complete (>= SDL 2.0.5)      │
       └───────────────────┴──────────────────────────────┘

       Audio hotplug events

       ┌─────────────────────────┬──────────────────────────────┐
       │ SDL_AUDIODEVICEADDED    │ a new audio device is avail‐ │
       │                         │ able (>= SDL 2.0.4)          │
       ├─────────────────────────┼──────────────────────────────┤
       │ SDL_AUDIODEVICEREMOVED  │ an audio device has been re‐ │
       │                         │ moved (>= SDL 2.0.4)         │
       └─────────────────────────┴──────────────────────────────┘

       Render events

       ┌───────────────────────────┬──────────────────────────────┐
       │ SDL_RENDER_TARGETS_RESET  │ the render targets have been │
       │                           │ reset  and  their   contents │
       │                           │ need  to  be updated (>= SDL │
       │                           │ 2.0.2)                       │
       ├───────────────────────────┼──────────────────────────────┤
       │ SDL_RENDER_DEVICE_RESET   │ the device  has  been  reset │
       │                           │ and  all textures need to be │
       │                           │ recreated (>= SDL 2.0.4)     │
       └───────────────────────────┴──────────────────────────────┘

       There are for your use, and should be allocated with SDL_RegisterEvents()

       ┌────────────────┬──────────────────────────────┐
       │ SDL_USEREVENT  │ a user-specified event       │
       ├────────────────┼──────────────────────────────┤
       │ SDL_LASTEVENT  │ only for  bounding  internal │
       │                │ arrays                       │
       └────────────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────┐
       │ SDL_Event e;                                       │
       │ while (SDL_PollEvent(&e)) {                        │
       │     if (e.type == SDL_KEYDOWN) {                   │
       │         SDL_Log("User just pressed down a key!");  │
       │     }                                              │
       │ }                                                  │
       └────────────────────────────────────────────────────┘

REMARKS
       SDL_QUIT

       SDL_QUIT  events  are  generated  for a variety of reasons. An application can
       choose to ignore the event, for example, if it wants to offer a prompt  asking
       the user to save the current work.

       An SDL_QUIT event is generated when the user clicks on the close button of the
       last existing window. This happens in addition to the SDL_WINDOWEVENT/SDL_WIN‐
       DOWEVENT_CLOSE  event,  so the application can check whichever is appropriate,
       or both, or neither. If the application ignores this event and creates another
       window,  SDL_QUIT will be sent again the next time the user clicks on the last
       remaining window's close button.

       SDL_QUIT is not limited to window closing. On macOS, pressing Commmand+Q  (the
       standard keyboard shortcut for "Quit this application") will cause SDL to gen‐
       erate and SDL_QUIT event, regardless of what windows exist at  the  time.  The
       application is still responsible for terminating itself properly, however. Ap‐
       plications that completely ignore Command+Q will fail macOS App Store certifi‐
       cation.

       On      POSIX     systems,     SDL_Init()     installs     signal     handlers
       (https://en.wikipedia.org/wiki/Signal_(IPC)) for SIGINT  (keyboard  interrupt)
       and  SIGTERM  (system  termination request), if handlers do not already exist,
       that generate SDL_QUIT events as well. There is no way to determine the  cause
       of  an  SDL_QUIT  event, but setting a signal handler in your application will
       override the default generation of quit events for that signal.

       Android, iOS, and WinRT Events

       What we currently label as "Android, iOS, and WinRT Events"  are  specific  to
       mobile  and  embedded devices that have different requirements than your usual
       desktop application. These events must be handled in an  event  filter,  since
       often  the  OS  needs  an  immediate  response and will terminate your process
       shortly after sending the event, and if it sits in the SDL event queue,  it'll
       be  too  late. You can handle everything else through a normal SDL_PollEvent()
       loop, but you should set up a callback  with  SDL_SetEventFilter()  for  these
       specific events.

       This is how these events currently map to the underlying OS:

       ┌──────────────────────────────┬────────────────┬──────────────────────────────────────┬───────────────┬──────────────┐
       │          SDL Event           │      What      │                 iOS                  │    Android    │    WinRT     │
       ├──────────────────────────────┼────────────────┼──────────────────────────────────────┼───────────────┼──────────────┤
       │ SDL_APP_TERMINATING          │ The   applica‐ │ applicationWillTerminate()           │ onDestroy()   │ Exiting()    │
       │                              │ tion is  being │                                      │               │              │
       │                              │ terminated  by │                                      │               │              │
       │                              │ the OS.        │                                      │               │              │
       ├──────────────────────────────┼────────────────┼──────────────────────────────────────┼───────────────┼──────────────┤
       │ SDL_APP_LOWMEMORY            │ the   applica‐ │ applicationDidReceiveMemoryWarning() │ onLowMemory() │ --           │
       │                              │ tion is low on │                                      │               │              │
       │                              │ memory,   free │                                      │               │              │
       │                              │ memory if pos‐ │                                      │               │              │
       │                              │ sible.         │                                      │               │              │
       ├──────────────────────────────┼────────────────┼──────────────────────────────────────┼───────────────┼──────────────┤
       │ SDL_APP_WILLENTERBACKGROUND  │ The   applica‐ │ applicationWillResignActive()        │ onPause()     │ Suspending() │
       │                              │ tion  is about │                                      │               │              │
       │                              │ to  enter  the │                                      │               │              │
       │                              │ background.    │                                      │               │              │
       ├──────────────────────────────┼────────────────┼──────────────────────────────────────┼───────────────┼──────────────┤
       │ SDL_APP_DIDENTERBACKGROUND   │ The   applica‐ │ applicationDidEnterBackground()      │ onPause()     │ Suspending() │
       │                              │ tion did enter │                                      │               │              │
       │                              │ the background │                                      │               │              │
       │                              │ and  may   not │                                      │               │              │
       │                              │ get   CPU  for │                                      │               │              │
       │                              │ some time.     │                                      │               │              │
       ├──────────────────────────────┼────────────────┼──────────────────────────────────────┼───────────────┼──────────────┤
       │ SDL_APP_WILLENTERFOREGROUND  │ The   applica‐ │ applicationWillEnterForeground()     │ onResume()    │ Resuming()   │
       │                              │ tion  is about │                                      │               │              │
       │                              │ to  enter  the │                                      │               │              │
       │                              │ foreground.    │                                      │               │              │
       ├──────────────────────────────┼────────────────┼──────────────────────────────────────┼───────────────┼──────────────┤
       │ SDL_APP_DIDENTERFOREGROUND   │ The   applica‐ │ applicationDidBecomeActive()         │ onResume()    │ Resuming()   │
       │                              │ tion  is   now │                                      │               │              │
       │                              │ interactive.   │                                      │               │              │
       └──────────────────────────────┴────────────────┴──────────────────────────────────────┴───────────────┴──────────────┘

RELATED STRUCTURES
       SDL_JoyAxisEvent
       SDL_JoyBallEvent
       SDL_JooyButtonEvent
       SDL_JoyHatEvent
       SDL_JoyDeviceEvent
       SDL_ControllerAxisEvent
       SDL_ControllerButtonEvent
       SDL_ControllerDeviceEvent
       SDL_KeyboardEvent
       SDL_MouseButtonEvent
       SDL_MouseMotionEvent
       SDL_MouseWheelEvent
       SDL_QuitEvent
       SDL_SysWMEvent
       SDL_TextEditingEvent
       SDL_TextInputEvent
       SDL_UserEvent
       SDL_WindowEvent
       SDL_DropEvent
       SDL_AudioDeviceEvent
       SDL_TouchFingerEvent
       SDL_DollarGestureEvent
       SDL_MultiGestureEvent

RELATED FUNCTIONS
       SDL_PollEvent
       SDL_SetEventFilter

===============================================================================
                                                              *SDL_ExposeEvent*


NAME
       SDL_ExposeEvent - Quit requested event

STRUCTURE DEFINITION
       typedef struct{
         Uint8 type
       } SDL_ExposeEvent;

STRUCTURE DATA
       type                SDL_VIDEOEXPOSE

DESCRIPTION
       SDL_ExposeEvent  is  a member of the SDL_Event union and is used whan an event
       of type SDL_VIDEOEXPOSE is reported.

       A VIDEOEXPOSE event is triggered when the screen has been modified outside  of
       the application, usually by the window manager and needs to be redrawn.

SEE ALSO
       SDL_Event, SDL_SetEventFilter

===============================================================================
                                                                 *SDL_FillRect*


NAME
       SDL_FillRect -- Function

SYNOPSIS
       Use this function to perform a fast fill of a rectangle with a specific color.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ int SDL_FillRect(SDL_Surface*       dst,    │
       │                  const SDL_Rect*    rect,   │
       │                  Uint32             color)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ dst    │ the   SDL_Surface  structure │
       │        │ that is the drawing target   │
       ├────────┼──────────────────────────────┤
       │ rect   │ the SDL_Rect structure  rep‐ │
       │        │ resenting  the  rectangle to │
       │        │ fill, or NULL  to  fill  the │
       │        │ entire surface               │
       ├────────┼──────────────────────────────┤
       │ color  │ the  color to fill with; see │
       │        │ Remarks for dettails         │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns l0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────┐
       │ /* Declaring the surface. */                                 │
       │ SDL_Surface *s;                                              │
       │                                                              │
       │ /* Creating the surface */                                   │
       │ s = SDL_CreateRGBSurface(0, width, height, 32, 0, 0, 0, 0);  │
       │                                                              │
       │ /* Filling the surface with red color. */                    │
       │ SDL_FillRect(s, NULL, SDL_MapRGB(s->format, 255, 0, 0));     │
       └──────────────────────────────────────────────────────────────┘

REMARKS
       color  should  be a pixel of the format used by the surface, and can be gener‐
       ated by SDL_MapRGB() or SDL_MapRGBA(). If the color value  contains  an  alpha
       component  then  the destination is simply filled with that alpha information,
       no blending takes place.

       If there is a clip  rectangle  set  on  the  desntination  (set  via  SDL_Set‐
       ClipRect()),  then  this  function  will fill based on the intersection of the
       clip rectangle and rect.

RELATED FUNCTIONS
       SDL_FillRects

===============================================================================
                                                                *SDL_FillRects*


NAME
       SDL_FillRects -- Function

SYNOPSIS
       Use  this  function  to perform a fast fill of a set of rectangles with a spe‐
       cific color.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ int SDL_FillRects(SDL_Surface*      dst,    │
       │                   const SDL_Rect*   rects,  │
       │                   int               count,  │
       │                   Uint32            color)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ dst    │ the  SDL_Surface   structure │
       │        │ that is the drawing target   │
       ├────────┼──────────────────────────────┤
       │ rects  │ an  array of SDL_Rect struc‐ │
       │        │ tures representing the  rec‐ │
       │        │ tangles to be filled         │
       ├────────┼──────────────────────────────┤
       │ count  │ the  number of rectangles in │
       │        │ the array                    │
       ├────────┼──────────────────────────────┤
       │ color  │ the color to fill with;  see │
       │        │ Remarks for details          │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       color should be a pixel of the format used by the surface, and can  be  gener‐
       ated  by  SDL_MapRGB()  or SDL_MapRGBA(). If the color value contains an alpha
       component then the destination is simply filled with that  alpha  information,
       no blending takes place.

       If  there  is  a  clip  rectangle  set  on  the  destination (set via SDL_Set‐
       ClipRect()), then this function will filled based on the intersection  of  the
       clip rectangle and rects.

RELATED FUNCTIONS
       SDL_FillRect

===============================================================================
                                                             *SDL_FilterEvents*


NAME
       SDL_FilterEvents -- Function

SYNOPSIS
       Use  this  function  to  run  a  specific filter function on the current event
       queue, removing any events for which the filter returns 0.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_FilterEvents(SDL_EventFilter   filter,    │
       │                       void*             userdata)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ filter    │ the function to call when an │
       │           │ event  happens;  see Remarks │
       │           │ for details                  │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ a pointe that is  passed  to │
       │           │ filter                       │
       └───────────┴──────────────────────────────┘

REMARKS
       The function prototype for filter is:

       ┌──────────────────────────────────────────────┐
       │ int SDL_EventFilter(void*         userdata,  │
       │                     SDL_Event*    event)     │
       └──────────────────────────────────────────────┘
       where its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ what  was passed as userdata │
       │           │ to SDL_FilterEvents()        │
       ├───────────┼──────────────────────────────┤
       │ event     │ the desired  event  to  pull │
       │           │ from the queue               │
       └───────────┴──────────────────────────────┘
       See  SDL_SetEventFilter()  for  more information. Unlike SDL_SetEventFilter(),
       this function does not change the filter permanently, it only  uses  the  sup‐
       plied filter until this function returns.

RELATED FUNCTIONS
       SDL_GetEventFilter
       SDL_SetEventFilter

===============================================================================
                                                                   *SDL_Finger*


NAME
       SDL_Finger -- Structure

SYNOPSIS
       A structure that contains touch information.

DATA FIELDS
       ┌───────────────┬──────────┬───────────────────────┐
       │ SDL_FingerID  │ id       │ the finger id         │
       ├───────────────┼──────────┼───────────────────────┤
       │ float         │ x        │ the  x-axis  location │
       │               │          │ of the  touch  event, │
       │               │          │ normalized (0...1)    │
       ├───────────────┼──────────┼───────────────────────┤
       │ float         │ y        │ the  y-axis  location │
       │               │          │ of the  touch  event, │
       │               │          │ normalized (0...1)    │
       ├───────────────┼──────────┼───────────────────────┤
       │ float         │ pressure │ the quantity of pres‐ │
       │               │          │ sure applied, normal‐ │
       │               │          │ ized (0...1)          │
       └───────────────┴──────────┴───────────────────────┘

VERSION
       This structure is available since SDL 2.0.0.

RELATED STRUCTURES
       SDL_TouchFingerEvent

RELATED FUNCTIONS
       SDL_GetNumTouchFingers
       SDL_GetTouchFinger

===============================================================================
                                                                     *SDL_Flip*


NAME
       SDL_Flip - Swaps screen buffers

SYNOPSIS
       #include "SDL.h"

       int SDL_Flip(SDL_Surface *screen);

DESCRIPTION
       On  hardware  that supports double-buffering, this function sets up a flip and
       returns. The hardware will wait for vertical retrace, and then swap video buf‐
       fers  before the next video surface blit or lock will return. On hardware that
       doesn't support  double-buffering,  this  is  equivalent  to  calling  SDL_Up‐
       dateRect(screen, 0, 0, 0, 0)

       The SDL_DOUBLEBUF flag must have been passed to SDL_SetVideoMode, when setting
       the video mode for this function to perform hardware flipping.

RETURN VALUE
       This function returns 0 if successful, or -1 if there was an error.

SEE ALSO
       SDL_SetVideoMode, SDL_UpdateRect, SDL_Surface

===============================================================================
                                                               *SDL_FlushEvent*


NAME
       SDL_FlushEvent -- Function

SYNOPSIS
       Use this function to clear events from the event queue.

SYNTAX
       ┌───────────────────────────────────┐
       │ void SDL_FlushEvent(Uint32 type)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ type  │ the  type  of  event  to  be │
       │       │ cleared;  see  SDL_EventType │
       │       │ for details                  │
       └───────┴──────────────────────────────┘

REMARKS
       This will unconditionally remove any events from the queue that match type. If
       you need to remove a range of event types, use SDL_FlushEvents() instead.

       It's also normal to just ignore events you don't care about in your event loop
       without calling this function.

       This  function  only affects currently queued events. If you want to make sure
       that all pending OS events are flushed, you can call SDL_PumpEvents()  on  the
       main thread immediately before the flush call.

RELATED FUNCTIONS
       SDL_FlushEvents

===============================================================================
                                                               *SDL_FreeCursor*


NAME
       SDL_FreeCursor -- Function

SYNOPSIS
       Use  this  function to free a cursor created with SDL_CreateCursor(), SDL_Cre‐
       ateColorCursor(), or SDL_CreateSystemCursor().

SYNTAX
       ┌──────────────────────────────────────────┐
       │ void SDL_FreeCursor(SDL_Cursor* cursor)  │
       └──────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬────────────────────┐
       │ cursor  │ the cursor to free │
       └─────────┴────────────────────┘

RELATED FUNCTIONS
       SDL_CreateColorCursor
       SDL_CreateCursor
       SDL_CreateSystemCursor

===============================================================================
                                                               *SDL_FreeFormat*


NAME
       SDL_FreeFormat -- Function

SYNOPSIS
       Use this function to free an SDL_PixelFormat structure allocated by SDL_Alloc‐
       Format.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ void SDL_FreeFormat(SDL_PixelFormat* format)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬───────────────────────────────────────┐
       │ format  │ the SDL_PixelFormat structure to free │
       └─────────┴───────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_AllocFormat

===============================================================================
                                                              *SDL_FreePalette*


NAME
       SDL_FreePalette -- Function

SYNOPSIS
       Use this function to free a palette created with SDL_AllocPalette().

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ void SDL_FreePalette(SDL_Palette* palette)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬───────────────────────────────────────┐
       │ palette  │ the SDL_Palette structure to be freed │
       └──────────┴───────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_AllocPalette

===============================================================================
                                                                   *SDL_FreeRW*


NAME
       SDL_FreeRW -- Function

SYNOPSIS
       Use this function to free an SDL_RWops structure allocated by SDL_AllocRW().

SYNTAX
       ┌───────────────────────────────────┐
       │ void SDL_FreeRW(SDL_RWops* area)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬─────────────────────────────────────┐
       │ area  │ the SDL_RWops structure to be freed │
       └───────┴─────────────────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────┐
       │ /* this would be your SDL_RWops implementation's "close" method. */  │
       │ void close_my_rwops(SDL_RWops *rw)                                   │
       │ {                                                                    │
       │   if (rw != NULL)                                                    │
       │   {                                                                  │
       │     /* close any other resources */                                  │
       │     SDL_FreeRW(rw);                                                  │
       │   }                                                                  │
       │ }                                                                    │
       └──────────────────────────────────────────────────────────────────────┘

REMARKS
       Applications  do not need to use this function unless they are providing their
       own SDL_RWops implementation. If you just need a  SDL_RWops  to  read/write  a
       common  data  source,  you should use the built-in implementation in SDL, like
       SDL_RWFromFile() or SDL_RWFromMem(), etc, and call the close method  on  those
       SDL_RWops pointers when you are done with them.

       Only  use  SDL_FreeRW()  on pointers returned by SDL_AllocRW(). The pointer is
       invalid as soon as this function returns. Any extra  memory  allocated  during
       creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must be
       responsible for managing that memory in their close method.

RELATED FUNCTIONS
       SDL_AllocRW

===============================================================================
                                                              *SDL_FreeSurface*


NAME
       SDL_FreeSurface -- Function

SYNOPSIS
       Use this function to free an RGB surface.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ void SDL_FreeSurface(SDL_Surface* surface)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬───────────────────────────────────┐
       │ surface  │ the SDL_Surface structure to free │
       └──────────┴───────────────────────────────────┘

REMARKS
       If  the  surface  was  created using SDL_CreateRGBSurfaceFrom() then the pixel
       data is not freed.

       It is safe to pass NULL to this function.

RELATED FUNCTIONS
       SDL_CreateRGBSurface
       SDL_CreateRGBSurfaceFrom
       SDL_LoadBMP
       SDL_LoadBMP_RW

===============================================================================
                                                                  *SDL_FreeWAV*


NAME
       SDL_FreeWAV -- Function

SYNOPSIS
       Use  this  function  to  free  data previously allocated with SDL_LoadWAV() or
       SDL_LoadWAV_RW().

SYNTAX
       ┌─────────────────────────────────────┐
       │ void SDL_FreeWAV(Uint8* audio_buf)  │
       └─────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ audio_buf  │ a pointer to the buffer cre‐ │
       │            │ ated   by  SDL_LoadWAV()  or │
       │            │ SDL_LoadWAV_RW()             │
       └────────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────┐
       │ SDL_AudioSpec wav_spec;                                                      │
       │ Uint32 wav_length;                                                           │
       │ Uint8* wav_buffer;                                                           │
       │                                                                              │
       │ /* Load the WAV */                                                           │
       │ if (SDL_LoadWAV("test.wav", &wav_spec, &wav_buffer, &wav_length) == NULL) {  │
       │   fprintf(stderr, "Could not open test.wav: %s0, SDL_GetError());            │
       │ } else {                                                                     │
       │   /* Do stuff with the WAV data, and then... */                              │
       │   SDL_FreeWAV(wav_buffer);                                                   │
       │ }                                                                            │
       └──────────────────────────────────────────────────────────────────────────────┘

REMARKS
       After a WAVE file has been opened with SDL_LoadWAV() or  SDL_LoadWAV_RW()  its
       data can eventually be freed with SDL_FreeWAV(). It is safe to call this func‐
       tion with a NULL pointer.

RELATED FUNCTIONS
       SDL_LoadWAV
       SDL_LoadWAV_RW

===============================================================================
                                                           *SDL_FreeYUVOverlay*


NAME
       SDL_FreeYUVOverlay - Free a YUV video overlay

SYNOPSIS
       #include "SDL.h"

       void SDL_FreeYUVOverlay(SDL_Overlay *overlay);

DESCRIPTION
       Frees and overlay created by SDL_CreateYUVOverlay.

SEE ALSO
       SDL_Overlay, SDL_DisplayYUVOverlay, SDL_FreeYUVOverlay

===============================================================================
                                                           *SDL_GL_BindTexture*


NAME
       SDL_GL_BindTexture -- Function

SYNOPSIS
       Use  this function to bind an OpenGL/ES/ES2 texture to the current context for
       use with OpengGL instructions when rendering OpenGL primitives directly.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_GL_BindTexture(SDL_Texture* texture,  │
       │                        float*       texw,     │
       │                        float*       texh)     │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to bind  to  the │
       │          │ current  OpenGL/ES/ES2  con‐ │
       │          │ text                         │
       ├──────────┼──────────────────────────────┤
       │ texw     │ a pointer to a  float  value │
       │          │ which  will  be  filled with │
       │          │ the texture width or NULL if │
       │          │ you don't need that value    │
       ├──────────┼──────────────────────────────┤
       │ texh     │ a  pointer  to a float value │
       │          │ which will  be  filled  with │
       │          │ the  texture  height or NULL │
       │          │ if you don't need that value │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success, or -1 if the operation is not supported; call SDL_GetEr‐
       ror() for more information.

REMARKS
       If provided, texw and texh will be filled with the width and height values su‐
       tiable for the provided texture. In most cases, both will be 1.0, however,  on
       systems that support the GL_ARB_TEXTURE_rectangle extension, these values will
       actually be the pixel width and height used to created the  texture,  so  this
       factor  needs  to  be taken into account when providing texture coordinates to
       OpenGL.

       You need a renderer to create a SDL_Texture, therefore you can only  use  this
       function  with  an implicit OpenGL context from SDL_CreateRenderer(), not with
       your own OpenGL. If you need control over your OpenGL  context,  you  need  to
       write your own texture-loading methods.

       Also  note that SDL may upload RGB textures as BGR (or vice-versa), and re-or‐
       der the color channels in the shaders phase, so the uploaded texture may  have
       swapped color channels.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GL_MakeCurrent
       SDL_GL_UnbindTexture

===============================================================================
                                                         *SDL_GL_CreateContext*


NAME
       SDL_GL_CreateContext -- Function

SYNOPSIS
       Use  this  function to create an OpenGL context for use with an OpenGL window,
       and make it current.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ SDL_GLContext SDL_GL_CreateContext(SDL_Window* window)  │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────────────────┐
       │ window  │ the window to associate with the context │
       └─────────┴──────────────────────────────────────────┘

RETURN VALUE
       Returns the OpenGL context associated with  window  or  NULL  on  error;  call
       SDL_GetError() for more details.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────┐
       │ // Window mode MUST include SDL_WINDOW_OPENGL for use with OpenGL.        │
       │ SDL_Window* window = SDL_CreateWindow(                                    │
       │   "SDL2/OpenGL Demo", 0, 0, 640, 480,                                     │
       │   SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);                                │
       │                                                                           │
       │ // Create and OpenGL context associated with the window                   │
       │ SDL_GLContext glcontext = SDL_GL_CreateContext(window);                   │
       │                                                                           │
       │ // now you can make GL calls                                              │
       │ glClearColor(0,0,0,1);                                                    │
       │ glClear(GL_COLOR_BUFFER_BIT);                                             │
       │ SDL_GL_SwapWindow(window);                                                │
       │                                                                           │
       │ // Once finished with OpenGL functions, the SDL_GLContext can be deleted  │
       │ SDL_GL_DeleteContext(glcontext);                                          │
       └───────────────────────────────────────────────────────────────────────────┘

REMARKS
       Windows  users new to OpenGL should not that, for historical reasons, GL func‐
       tions added after OpenGL version 1.1 are not available by default. Those func‐
       tions must be loaded at run-time, either with an OpenGL extension-handling li‐
       brary or with SDL_GL_GetProcAddress() and its related functions.

       SDL_GLContext is an alias for void*.

RELATED FUNCTIONS
       SDL_GL_DeleteContext
       SDL_GL_MakeCurrent

===============================================================================
                                                         *SDL_GL_DeleteContext*


NAME
       SDL_GL_DeleteContext -- Function

SYNOPSIS
       Use this function to delete an OpenGL context.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ void SDL_GL_DeleteContext(SDL_GLContext context)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────────┐
       │ context  │ the OpenGL context to be deleted │
       └──────────┴──────────────────────────────────┘

RELATED FUNCTIONS
       SDL_GL_CreateContext

===============================================================================
                                                    *SDL_GL_ExtensionSupported*


NAME
       SDL_GL_ExtensionSupported -- Function

SYNOPSIS
       Use this function to check if an OpenGL extension is supported for the current
       context.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_GL_ExtensionSupported(const char* extension)  │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬────────────────────────────────────┐
       │ extension  │ the name of the extension to check │
       └────────────┴────────────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────┐
       │ if (SDL_GL_ExtensionSupported("GL_EXT_framebuffer_blit")) {  │
       │   draw_to_the_screen_with_framebuffer_blit();   // faster!   │
       │ } else {                                                     │
       │   draw_to_the_screen_with_a_textured_quad();    // slower!   │
       │ }                                                            │
       └──────────────────────────────────────────────────────────────┘

REMARKS
       This function operates on the current GL context; you must have created a con‐
       text  and  it must be current before calling this function. Do not assume that
       all contexts you create will have the same set  of  extensions  available,  or
       that recreating an existing context will offer the same extensions again.

       While it's probably not a massive overhead, this function is not an O(1) oper‐
       ation. Check the extensions you care about after creating the GL  context  and
       save that information somewhere instead of calling the function every time you
       need to know.

VERSION
       This function is available since SDL 2.0.0.

===============================================================================
                                                          *SDL_GL_GetAttribute*


NAME
       SDL_GL_GetAttribute -- Function

SYNOPSIS
       Use  this  function  to get the actual value for an attribute from the current
       context.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ int SDL_GL_GetAttribute(SDL_GLattr  atr,    │
       │                         int*        value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬───────────────────────────────────┐
       │ attr   │ the SDL_GLattr structure to query │
       ├────────┼───────────────────────────────────┤
       │ value  │ a pointer filled in with the cur‐ │
       │        │ rent value of attr                │
       └────────┴───────────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       attr may be one of the following:

       ┌────────────────────────────────────┬──────────────────────────────┐
       │ SDL_GL_RED_SIZE                    │ the minimum number  of  bits │
       │                                    │ for  the  red channel of the │
       │                                    │ color buffer; defaults to 3  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_GREEN_SIZE                  │ the minimum number  of  bits │
       │                                    │ for the green channel of the │
       │                                    │ color buffer; defaults to 3  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_BLUE_SIZE                   │ the minimum number  of  bits │
       │                                    │ for  the blue channel of the │
       │                                    │ color buffer; defaults to 2  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ALPHA_SIZE                  │ the minimum number  of  bits │
       │                                    │ for the alpha channel of the │
       │                                    │ color buffer; defaults to 0  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_BUFFER_SIZE                 │ the minimum number  of  bits │
       │                                    │ for  frame  buffer size; de‐ │
       │                                    │ faults to 0                  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_DOUBLEBUFFER                │ whether the output is single │
       │                                    │ or double buffered; defaults │
       │                                    │ to double buffering on       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_DEPTH_SIZE                  │ the minimum number  of  bits │
       │                                    │ in th depth buffer; defaults │
       │                                    │ to 16                        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_STENCIL_SIZE                │ the minimum number  of  bits │
       │                                    │ in  the  stencil buffer; de‐ │
       │                                    │ faults to 0                  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_RED_SIZE              │ the minimum number  of  bits │
       │                                    │ for  the  red channel of the │
       │                                    │ accumulation   buffer;   de‐ │
       │                                    │ fautls to 0                  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_GREEN_SIZE            │ the  minimum  number of bits │
       │                                    │ for the green channel of the │
       │                                    │ accumulation   buffer;   de‐ │
       │                                    │ faults to 0                  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_BLUE_SIZE             │ the minimum number  of  bits │
       │                                    │ for  the blue channel of the │
       │                                    │ accumulation   buffer;   de‐ │
       │                                    │ faults to 0                  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_ALPHA_SIZE            │ the  minimum  number of bits │
       │                                    │ for the alpha channel of the │
       │                                    │ accumulation   buffer;   de‐ │
       │                                    │ faults to 0                  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_STEREO                      │ whether the output is stereo │
       │                                    │ 3D; defaules to off          │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_MULTISAMPLEBUFFERS          │ the  number  of buffers used │
       │                                    │ for multisample  anti-alias‐ │
       │                                    │ ing;  defaults to 0; see Re‐ │
       │                                    │ marks     (https://wiki.lib‐ │
       │                                    │ sdl.org/SDL_GLattr#multisam‐ │
       │                                    │ ple) for details             │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_MULTISAMPLESAMPLES          │ the number of  samples  used │
       │                                    │ around   the  current  pixel │
       │                                    │ used for  multisample  anti- │
       │                                    │ aliasing; defaults to 0; see │
       │                                    │ Remarks   (https://wiki.lib‐ │
       │                                    │ sdl.org/SDL_GLattr#multisam‐ │
       │                                    │ ple) for details             │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCELERATED_VISUAL          │ set to 1 to require hardware │
       │                                    │ acceleration,  set  to  0 to │
       │                                    │ force  software   rendering; │
       │                                    │ defaults to allow either     │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_RETAINED_BACKING            │ not used (deprecated)        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_MAJOR_VERSION       │ OpenGL  context  major  ver‐ │
       │                                    │ sion;      see       Remarks │
       │                                    │ (https://wiki.lib‐           │
       │                                    │ sdl.org/SDL_GLattr#multisam‐ │
       │                                    │ ple) for details             │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_MINOR_VERSION       │ OpenGL  context  minor  ver‐ │
       │                                    │ sion;      see       Remarks │
       │                                    │ (https://wiki.lib‐           │
       │                                    │ sdl.org/SDL_GLattr#multisam‐ │
       │                                    │ ple) for details             │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_FLAGS               │ some  combination  of  0  or │
       │                                    │ more  of  elements  of   the │
       │                                    │ SDL_GLcontextFlag   enumera‐ │
       │                                    │ tion; defaults to 0          │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_PROFILE_MASK        │ type of  GL  context  (Core, │
       │                                    │ Compatibility,    ES).   See │
       │                                    │ SDL_GLprofile; default value │
       │                                    │ depends on platform          │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_SHARE_WITH_CURRENT_CONTEXT  │ OpenGL  context sharing; de‐ │
       │                                    │ faults to 0                  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_FRAMEBUFFER_SRGB_CAPABLE    │ requests sRGB  capable  vis‐ │
       │                                    │ ual;  defaults  to 0 (>= SDL │
       │                                    │ 2.0.1)                       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_RELEASE_BEHAVIOR    │ sets context the release be‐ │
       │                                    │ havior;  defaults  to  1 (>= │
       │                                    │ SDL 2.0.4)                   │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_EGL                 │ not used (deprecated)        │
       └────────────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GL_ResetAttributes
       SDL_GL_SetAttribute

===============================================================================
                                                     *SDL_GL_GetCurrentContext*


NAME
       SDL_GL_GetCurrentContext -- Function

SYNOPSIS
       Use this function to get the currently active OpenGL context.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ SDL_GLContext SDL_GL_GetCurrentContext(void)  │
       └───────────────────────────────────────────────┘

RETURN VALUE
       Returns  the  currently  active  OpenGL  context  or  NULL  on  failure;  call
       SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GL_MakeCurrent

===============================================================================
                                                      *SDL_GL_GetCurrentWindow*


NAME
       SDL_GL_GetCurrentWindow -- Function

SYNOPSIS
       Use this function to get the currently active OpenGL window.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ SDL_Window* SDL_GL_GetCurrentWindow(void)  │
       └────────────────────────────────────────────┘

RETURN VALUE
       Returns the currently active OpenGL window on success or NULL on failure; call
       SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

===============================================================================
                                                       *SDL_GL_GetDrawableSize*


NAME
       SDL_GL_GetDrawableSize -- Function

SYNOPSIS
       Use  this function to get the size of a window's underlying drawable in pixels
       (for use with glViewport).

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ void SDL_GL_GetDrawableSize(SDL_Window* window,  │
       │                             int*        w,       │
       │                             int*        h)       │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window  from  which  the │
       │         │ drawable   size   should  be │
       │         │ queried                      │
       ├─────────┼──────────────────────────────┤
       │ w       │ a pointer  to  variable  for │
       │         │ storing the width in pixels, │
       │         │ may be NULL                  │
       ├─────────┼──────────────────────────────┤
       │ h       │ a pointer  to  variable  for │
       │         │ storing  the  height in pix‐ │
       │         │ els, may be NULL             │
       └─────────┴──────────────────────────────┘

REMARKS
       This may differ from SDL_GetWindowSize() if  we're  rendering  to  a  high-DPI
       drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a plat‐
       form with high-DPI support (Apple calls this "Retina"), and  not  disabled  by
       the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.

VERSION
       This function is available since SDL 2.0.1.

RELATED FUNCTIONS
       SDL_CreateWindow
       SDL_GetWindowSize

===============================================================================
                                                        *SDL_GL_GetProcAddress*


NAME
       SDL_GL_GetProcAddress -- Function

SYNOPSIS
       Use this function to get an OpenGL function by name.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void* SDL_GL_GetProcAddress(const char* proc)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ proc  │ the  name of an OpenGL func‐ │
       │       │ tion                         │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to the named OpenGL function. The returned pointer should be
       casted to the appropriate function signature.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────────┐
       │ typedef void (APIENTRY* GL_ActiveTextureARB_Func)(unsigned int);                  │
       │ GL_ActiveTextureARB_Func glActiveTextureARB_ptr = 0;                              │
       │                                                                                   │
       │ /* Get function pointer */                                                        │
       │ glActiveTextureARB_ptr = (GL_ActiveTextureARB_Func)                               │
       │ SDL_GL_GetProcAddress("glActiveTextureARB");                                      │
       │                                                                                   │
       │ /* It was your responsibility to make sure this was a valid function to call! */  │
       │ glActiveTextureARB_ptr(GL_TEXTURE0_ARB);                                          │
       └───────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       If  the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all GL
       functions must be retrieved this way. Usually this is used to  retrieve  func‐
       tion pointers to OpenGL extensions.

       These  are  some quirks to looking up OpenGL functions that require some extra
       care from the application. If you code carefully, you can handle these  quirks
       without any platform-specific code, though:

       -  On  Windows, function pointers are specific to the current GL context; this
       means you need to have created a GL context and made it current before calling
       SDL_GL_GetProcAddress().  If you recreate your context or create a second con‐
       text, you should assume that any existing function pointers  aren't  valid  to
       use  with  it. This is (currently) a Windows-specific limitation, and in prac‐
       tice lots of drivers don't suffer this limitation, but it is still the way the
       wgl  API  is documented to work and you should expect crashes if you don't re‐
       spect it. Store a copy of the function pointers that comes and goes with  con‐
       text lifespan.

       -  On  X11, function pointers returned by this function are valid for any con‐
       text, and can even be looked up before a context is created at all. This means
       that,  for at least some common OpenGL implementations, if you look up a func‐
       tion that doesn't exist, you'll get a non-NULL result that is  _NOT_  safe  to
       call. You must always make sure the function is actually available fro a given
       GL context before calling it, by checking for the existence of the appropriate
       extension  with  SDL_GL_ExtensionSupported(), or verifying that the version of
       OpenGL you're using offers the function as core functionality.

       - Some OpenGL drivers, on all platforms, will return NULL if a function  isn't
       supported,  but ou can't count on this behavior. Check for extensions you use,
       and if you get a NULL anyway, act as if that extension wasn't available.  This
       is  probably  a  bug in the driver, but you can code defensively for this sce‐
       nario anyhow.

       - Just because you're on Linux/Unix, don't assume you'll be using  X11.  Next-
       gen  display  servers  are  waiting to replace it, and may or may not make the
       same promises about function pointers.

       - OpenGL function pointers must be declared APIENTRY as in the  example  code.
       This  will ensure the proper calling convention is followed on platforms where
       this matters (Win32) thereby avoiding stack corruption.  •

RELATED FUNCTIONS
       SDL_GL_ExtensionSupported
       SDL_GL_LoadLibrary
       SDL_GL_UnloadLibrary

===============================================================================
                                                       *SDL_GL_GetSwapInterval*


NAME
       SDL_GL_GetSwapInterval -- Function

SYNOPSIS
       Use this function to get the swap interval for the current OpenGL context.

SYNTAX
       ┌───────────────────────────────────┐
       │ int SDL_GL_GetSwapInterval(void)  │
       └───────────────────────────────────┘

RETURN VALUE
       Returns  0  if  there  is no vertical retrace synchronization, 1 if the buffer
       swap is synchronized with the vertical retrace, and -1 if  late  swaps  happen
       immediately  instead  of waiting for the next retrace; call SDL_GetError() for
       more information.

REMARKS
       If the system can't determine the swap interval, or there isn't a  valid  cur‐
       rent context, this function will return 0 as a safe default.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GL_SetSwapInterval

===============================================================================
                                                           *SDL_GL_LoadLibrary*


NAME
       SDL_GL_LoadLibrary -- Function

SYNOPSIS
       Use this function to dynamically load an OpenGL library.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ int SDL_GL_LoadLibrary(const char* path)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ path  │ the    platform    dependent │
       │       │ OpenGL library name, or NULL │
       │       │ to  open  the default OpenGL │
       │       │ library                      │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       This  should  be done after initializing the video driver, but before creating
       any OpenGL windows. If no OpenGL library is loaded, the default  library  will
       be loaded upon creation of the first OpenGL window.

       If you do this, you need to retrieve all of the GL functions used in your pro‐
       gram from the dynamic library using SDL_GL_GetProcAddress().

RELATED FUNCTIONS
       SDL_GL_GetProcAddress
       SDL_GL_UnloadLibrary

===============================================================================
                                                           *SDL_GL_MakeCurrent*


NAME
       SDL_GL_MakeCurrent -- Function

SYNOPSIS
       Use  this  function  to  set up an OpenGL context for rendering into an OpenGL
       window.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ int SDL_GL_MakeCurrent(SDL_Window*    window,   │
       │                        SDL_GLContext  context)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ window   │ the window to associate with │
       │          │ the context                  │
       ├──────────┼──────────────────────────────┤
       │ context  │ the  OpenGL context to asso‐ │
       │          │ ciate with the window        │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failture; call SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_GL_CreateContext

===============================================================================
                                                       *SDL_GL_ResetAttributes*


NAME
       SDL_GL_ResetAttributes -- Function

SYNOPSIS
       Use  this  function  to  reset all previously set OpenGL context attributes to
       their default values.

SYNTAX
       ┌────────────────────────────────────┐
       │ void SDL_GL_ResetAttributes(void)  │
       └────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.2.

RELATED FUNCTIONS
       SDL_GL_GetAttribute
       SDL_GL_SetAttribute

===============================================================================
                                                          *SDL_GL_SetAttribute*


NAME
       SDL_GL_SetAttribute -- Function

SYNOPSIS
       Use this function to set an OpenGL window attribute before window creation.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ void SDL_GL_SetAttribute(SDL_GLattr     attr,   │
       │                          int            value)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ attr   │ the OpenGL attribute to set; │
       │        │ see Remarks for details      │
       ├────────┼──────────────────────────────┤
       │ value  │ the desired  value  for  the │
       │        │ attribute                    │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_Window* window;                                                                                                       │
       │ SDL_GLContext context;                                                                                                    │
       │                                                                                                                           │
       │ SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 5);                                                                                  │
       │ SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 5);                                                                                │
       │ SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 5);                                                                                 │
       │ SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16);                                                                               │
       │ SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);                                                                              │
       │                                                                                                                           │
       │ window = SDL_CreateWindow("OpenGL Window", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_OPENGL);  │
       │ if (!window) {                                                                                                            │
       │   fprintf(stderr, "Couldn't create window: %s0, SDL_GetError());                                                          │
       │   return;                                                                                                                 │
       │ }                                                                                                                         │
       │                                                                                                                           │
       │ context = SDL_GL_CreateContext(window);                                                                                   │
       │ if (!context) {                                                                                                           │
       │   fprintf(stderr, "Couldn't create context: %s0, SDL_GetError());                                                         │
       │   return;                                                                                                                 │
       │ }                                                                                                                         │
       │                                                                                                                           │
       │ int r, g, b;                                                                                                              │
       │ SDL_GL_GetAttribute(SDL_GL_RED_SIZE, &r);                                                                                 │
       │ SDL_GL_GetAttribute(SDL_GL_GREEN_SIZE, &g);                                                                               │
       │ SDL_GL_GetAttribute(SDL_GL_BLUE_SIZE, &b);                                                                                │
       │                                                                                                                           │
       │ printf("Red size: %d, Green size: %d, Blue size: %d0, r, g, b);                                                           │
       └───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This function sets the OpenGL attribute  attr  to  value.  The  requested  at‐
       tributes  should  be  set  before  creating  an  OpenGL window. You should use
       SDL_GL_GetAttribute() to check the values after creating the  OpenGL  context,
       since the values obtained can differ from the requested ones.

       ┌────────────────────────────────────┬──────────────────────────────┐
       │ SDL_GL_RED_SIZE                    │  the minimum number of bits  │
       │                                    │  for the red channel of the  │
       │                                    │  color  buffer; defaults to  │
       │                                    │  3                           │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_GREEN_SIZE                  │  the minimum number of bits  │
       │                                    │  for  the  green channel of  │
       │                                    │  the color buffer; defaults  │
       │                                    │  to 3                        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_BLUE_SIZE                   │  the minimum number of bits  │
       │                                    │  for the  blue  channel  of  │
       │                                    │  the color buffer; defaults  │
       │                                    │  to 2                        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ALPHA_SIZE                  │  the minimum number of bits  │
       │                                    │  for  the  alpha channel of  │
       │                                    │  the color buffer;  efaults  │
       │                                    │  to 0                        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_BUFFER_SIZE                 │  the minimum number of bits  │
       │                                    │  for frame buffer size; de‐  │
       │                                    │  faults to 0                 │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_DOUBLEBUFFER                │  whether the output is sin‐  │
       │                                    │  gle  or  double  buffered;  │
       │                                    │  defaults to double buffer‐  │
       │                                    │  ing on                      │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_DEPTH_SIZE                  │  the minimum number of bits  │
       │                                    │  in  the  depth buffer; de‐  │
       │                                    │  faults to 16                │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_STENCIL_SIZE                │  the minimum number of bits  │
       │                                    │  in the stencil buffer; de‐  │
       │                                    │  faults to 0                 │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_RED_SIZE              │  the minimum number of bits  │
       │                                    │  for the red channel of the  │
       │                                    │  accumulation  buffer;  de‐  │
       │                                    │  faults to 0                 │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_GREEN_SIZE            │  the minimum number of bits  │
       │                                    │  for the green  channel  of  │
       │                                    │  the  accumulation  buffer;  │
       │                                    │  defaults to 0               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_BLUE_SIZE             │  the minimum number of bits  │
       │                                    │  for  the  blue  channel of  │
       │                                    │  the  accumulation  buffer;  │
       │                                    │  defaults to 0               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_ALPHA_SIZE            │  the minimum number of bits  │
       │                                    │  for the alpha  channel  of  │
       │                                    │  the  accumulation  buffer;  │
       │                                    │  defaults to 0               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_STEREO                      │  whether  the   output   is  │
       │                                    │  stereo 3D; defaults to off  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_MULTISAMPLEBUFFERS          │  the number of buffers used  │
       │                                    │  for            multisample  │
       │                                    │  anti-aliasing; defaults to  │
       │                                    │  0; see Remarks for details  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_MULTISAMPLESAMPLES          │  the number of samples used  │
       │                                    │  around  the  current pixel  │
       │                                    │  used    for    multisample  │
       │                                    │  anti-aliasing; defaults to  │
       │                                    │  0; see Remarks for details  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCELERATED_VISUAL          │  set to 1 to require  hard‐  │
       │                                    │  ware  acceleration, set to  │
       │                                    │  0 to force  software  ren‐  │
       │                                    │  dering;  defaults to allow  │
       │                                    │  either                      │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_RETAINED_BACKING            │  not used (deprecated)       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_MAJOR_VERSION       │  OpenGL context major  ver‐  │
       │                                    │  sion;  see Remarks for de‐  │
       │                                    │  tails                       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_MINOR_VERSION       │  OpenGL context minor  ver‐  │
       │                                    │  sion;  see Remarks for de‐  │
       │                                    │  tails                       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_FLAGS               │  some combination of  0  or  │
       │                                    │  more  of  elements  of the  │
       │                                    │  SDL_GLContextFlag enumera‐  │
       │                                    │  tion; defaults to 0         │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_PROFILE_MASK        │  type  of GL context (Core,  │
       │                                    │  Compatibility,  ES).   See  │
       │                                    │  SDL_GLprofile;    defaults  │
       │                                    │  value depends on platform   │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_SHARE_WITH_CURRENT_CONTEXT  │  OpenGL  context   sharing;  │
       │                                    │  defaults to 0               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_FRAMEBUFFER_SRGB_CAPABLE    │  requests sRGB capable vis‐  │
       │                                    │  ual; defaults to 0 (>= SDL  │
       │                                    │  2.0.1)                      │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_RELEASE_BEHAVIOR    │  sets  context  the release  │
       │                                    │  behavior;  defaults  to  1  │
       │                                    │  (>= SDL 2.0.4)              │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_EGL                 │  not used (deprecated)       │
       └────────────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GL_GetAttribute
       SDL_GL_ResetAttributes

===============================================================================
                                                       *SDL_GL_SetSwapInterval*


NAME
       SDL_GL_SetSwapInterval -- Function

SYNOPSIS
       Use this function to set the swap interval for the current OpenGL context.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ int SDL_GL_SetSwapInterval(int interval)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ interval  │ 0  for  immediate updates, 1 │
       │           │ for   updates   synchronized │
       │           │ with  the  vertical retrace, │
       │           │ -1 for adaptive  vsync;  see │
       │           │ Remarks                      │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or -1 if setting the swap interval is not supported; call
       SDL_GetError() for more information.

REMARKS
       Some systems allow specifying -1 for the interval, to enable  adaptive  vsync.
       Adaptive  vsync works the same as vsync, but if you're already missed the ver‐
       tical retrace for a given frame, it swaps bufers immediately, which  might  be
       less  jarring  for  the user during occasional framerate drops. If application
       requests adaptive vsync and the system does not support it, this function will
       fail  and return -1. In such a case, you should probably retry the call with 1
       for the interval.

       Adaptive vsync is implemented for  some  glX  drivers  with  GLX_EXT_swap_con‐
       trol_tear                      (https://www.khronos.org/registry/OpenGL/exten‐
       sions/EXT/GLX_EXT_swap_control_tear.txt) and for  some  Windows  drivers  with
       WGL_EXT_swap_control_tear      (https://www.khronos.org/registry/OpenGL/exten‐
       sions/EXT/WGL_EXT_swap_control_tear.txt).  Read  more  on  the  Khronos   wiki
       (https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync).

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GL_GetSwapInterval

===============================================================================
                                                           *SDL_GL_SwapBuffers*


NAME
       SDL_GL_SwapBuffers - Swap OpenGL framebuffers/Update Display

SYNOPSIS
       #include "SDL.h"

       void SDL_GL_SwapBuffers(void );

DESCRIPTION
       Swap the OpenGL buffers, if double-buffering is supported.

SEE ALSO
       SDL_SetVideoMode, SDL_GL_SetAttribute

===============================================================================
                                                            *SDL_GL_SwapWindow*


NAME
       SDL_GL_SwapWindow -- Function

SYNOPSIS
       Use this function to update a window with OpenGL rendering.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ void SDL_GL_SwapWindow(SDL_Window* window)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────┐
       │ window  │ the window to change │
       └─────────┴──────────────────────┘

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_Window* window = SDL_CreateWindow("SDL2/OpenGL Demo", 30, 30, 640, 480, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);  │
       │                                                                                                                         │
       │ /* Create an OpenGL context associated with the window. */                                                              │
       │ SDL_GLContext glcontext = SDL_GL_CreateContext(window);                                                                 │
       │                                                                                                                         │
       │ /* This makes our buffer swap syncronized with the monitor's vertical refresh */                                        │
       │ SDL_GL_SetSwapInterval(1);                                                                                              │
       │                                                                                                                         │
       │ /* Clear context */                                                                                                     │
       │ glClearColor(0,0,0,1);                                                                                                  │
       │ glClear(GL_COLOR_BUFFER_BIT);                                                                                           │
       │                                                                                                                         │
       │ /* <Extra drawing function here> */                                                                                     │
       │                                                                                                                         │
       │ /* Swap our buffer to display the current contents of buffer on screen */                                               │
       │ SDL_GL_SwapWindow(window);                                                                                              │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This is used with double-buffered OpenGL contexts which are the default.

       On  macOS,  make  sure  you bind 0 to the draw framebuffer before swapping the
       window, otherwise nothing will happen. See this blog  post  (http://rendering‐
       pipeline.com/2012/05/nsopenglcontext-flushbuffer-might-not-do-what-you-think/)
       for more info.

===============================================================================
                                                         *SDL_GL_UnbindTexture*


NAME
       SDL_GL_UnbindTexture -- Function

SYNOPSIS
       Use this function to unbind an OpenGL/ES/ES2 texture from the current context.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ int SDL_GL_UnbindTexture(SDL_Texture* texture)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the  texture  to unbind from │
       │          │ the  current   OpenGL/ES/ES2 │
       │          │ context                      │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success, or -1 if the operation is not supported.

REMARKS
       See SDL_GL_BindTexture() for examples on how to use these functions.

RELATED FUNCTIONS
       SDL_GL_BindTexture
       SDL_GL_MakeCurrent

===============================================================================
                                                         *SDL_GL_UnloadLibrary*


NAME
       SDL_GL_UnloadLibrary -- Function

SYNOPSIS
       Use   this  function  to  unload  the  OpenGL  library  previously  loaded  by
       SDL_GL_LoadLibrary().

SYNTAX
       ┌──────────────────────────────────┐
       │ void SDL_GL_UnloadLibrary(void)  │
       └──────────────────────────────────┘

RELATED FUNCTIONS
       SDL_GL_LoadLibrary

===============================================================================
                                                                   *SDL_GLattr*


NAME
       SDL_GLattr -- Enumerations

SYNOPSIS
       An enumeration of OpenGL configuration attributes.

DESCRIPTION
       Values

       ┌────────────────────────────────────┬──────────────────────────────┐
       │ SDL_GL_RED_SIZE                    │  the minimum number of bits  │
       │                                    │  for the red channel of the  │
       │                                    │  color  buffer; defaults to  │
       │                                    │  3                           │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_GREEN_SIZE                  │  the minimum number of bits  │
       │                                    │  for  the  green channel of  │
       │                                    │  the color buffer; defaults  │
       │                                    │  to 3                        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_BLUE_SIZE                   │  the minimum number of bits  │
       │                                    │  for the  blue  channel  of  │
       │                                    │  the color buffer; defaults  │
       │                                    │  to 2                        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ALPHA_SIZE                  │  the minimum number of bits  │
       │                                    │  for  the  alpha channel of  │
       │                                    │  the color buffer;  efaults  │
       │                                    │  to 0                        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_BUFFER_SIZE                 │  the minimum number of bits  │
       │                                    │  for frame buffer size; de‐  │
       │                                    │  faults to 0                 │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_DOUBLEBUFFER                │  whether the output is sin‐  │
       │                                    │  gle  or  double  buffered;  │
       │                                    │  defaults to double buffer‐  │
       │                                    │  ing on                      │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_DEPTH_SIZE                  │  the minimum number of bits  │
       │                                    │  in  the  depth buffer; de‐  │
       │                                    │  faults to 16                │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_STENCIL_SIZE                │  the minimum number of bits  │
       │                                    │  in the stencil buffer; de‐  │
       │                                    │  faults to 0                 │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_RED_SIZE              │  the minimum number of bits  │
       │                                    │  for the red channel of the  │
       │                                    │  accumulation  buffer;  de‐  │
       │                                    │  faults to 0                 │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_GREEN_SIZE            │  the minimum number of bits  │
       │                                    │  for the green  channel  of  │
       │                                    │  the  accumulation  buffer;  │
       │                                    │  defaults to 0               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_BLUE_SIZE             │  the minimum number of bits  │
       │                                    │  for  the  blue  channel of  │
       │                                    │  the  accumulation  buffer;  │
       │                                    │  defaults to 0               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCUM_ALPHA_SIZE            │  the minimum number of bits  │
       │                                    │  for the alpha  channel  of  │
       │                                    │  the  accumulation  buffer;  │
       │                                    │  defaults to 0               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_STEREO                      │  whether  the   output   is  │
       │                                    │  stereo 3D; defaults to off  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_MULTISAMPLEBUFFERS          │  the number of buffers used  │
       │                                    │  for            multisample  │
       │                                    │  anti-aliasing; defaults to  │
       │                                    │  0; see Remarks for details  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_MULTISAMPLESAMPLES          │  the number of samples used  │
       │                                    │  around  the  current pixel  │
       │                                    │  used    for    multisample  │
       │                                    │  anti-aliasing; defaults to  │
       │                                    │  0; see Remarks for details  │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_ACCELERATED_VISUAL          │  set to 1 to require  hard‐  │
       │                                    │  ware  acceleration, set to  │
       │                                    │  0 to force  software  ren‐  │
       │                                    │  dering;  defaults to allow  │
       │                                    │  either                      │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_RETAINED_BACKING            │  not used (deprecated)       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_MAJOR_VERSION       │  OpenGL context major  ver‐  │
       │                                    │  sion;  see Remarks for de‐  │
       │                                    │  tails                       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_MINOR_VERSION       │  OpenGL context minor  ver‐  │
       │                                    │  sion;  see Remarks for de‐  │
       │                                    │  tails                       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_FLAGS               │  some combination of  0  or  │
       │                                    │  more  of  elements  of the  │
       │                                    │  SDL_GLContextFlag enumera‐  │
       │                                    │  tion; defaults to 0         │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_PROFILE_MASK        │  type  of GL context (Core,  │
       │                                    │  Compatibility,  ES).   See  │
       │                                    │  SDL_GLprofile;    defaults  │
       │                                    │  value depends on platform   │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_SHARE_WITH_CURRENT_CONTEXT  │  OpenGL  context   sharing;  │
       │                                    │  defaults to 0               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_FRAMEBUFFER_SRGB_CAPABLE    │  requests sRGB capable vis‐  │
       │                                    │  ual; defaults to 0 (>= SDL  │
       │                                    │  2.0.1)                      │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_RELEASE_BEHAVIOR    │  sets  context  the release  │
       │                                    │  behavior;  defaults  to  1  │
       │                                    │  (>= SDL 2.0.4)              │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_EGL                 │  not used (deprecated)       │
       └────────────────────────────────────┴──────────────────────────────┘

CODE EXAMPLES
       SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
       SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
       SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
       SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
       SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
       SDL_GL_CreateContext(window);

REMARKS
       While you can set most OpenGL attributes normally, the attributes listed above
       must be known before SDL creates the window that will be used the OpenGL  con‐
       text.  These  attributes  are  set  and  read  with  SDL_GL_SetAttribute() and
       SDL_GL_GetAttribute().

       In some cases, these attributes are minimum requests; the GL does not  promise
       to  give  you  exactly  what  you asked for. It's possible to ask for a 16-bit
       depth buffer and get a 24-bit one instead, for example, or to ask for no sten‐
       cil  buffer  and still have one available. Context creation should fail if the
       GL can't provide your requested attributes at a minimum, but you should  check
       to see exactly what you got.

       Multisample   anti-aliasing   (https://en.wikipedia.org/wiki/Multisample_anti-
       aliasing) is a type of full screen anti-aliasing.  Multisampling  defaults  to
       off  but  can  be  turned  on  by  setting  SDL_GL_MULTISAMPLEBUFFERS to 1 and
       SDL_GL_MULTISAMPLESAMPLES to a value greater than 0. Typical values are 2  and
       4.

       SDL_GL_CONTEXT_PROFILE_MASK determines the type of context created, while both
       SDL_GL_CONTEXT_MAJOR_VERSION and SDL_GL_CONTEXT_MINOR_VERSION determine  which
       version.  All three attributes must be set prior to creating the first window,
       and in general you can't change the value of SDL_GL_CONTEXT_PROFILE_MASK with‐
       out first destroying all windows created with the previous setting.

       SDL_GL_CONTEXT_RELEASE_BEHAVIOR  can  be  set to SDL_GL_CONTEXT_RELEASE_BEHAV‐
       IOR_NONE or SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH.

RELATED FUNCTIONS
       SDL_GL_CreateContext
       SDL_GL_GetAttribute
       SDL_GL_SetAttribute

===============================================================================
                                                            *SDL_GLcontextFlag*


NAME
       SDL_GLcontextFlag -- Enumerations

SYNOPSIS
       An enumeration of OpenGL context configuration flags.

DESCRIPTION
       Values

       ┌─────────────────────────────────────────┬───────────────┐
       │ SDL_GL_CONTEXT_DEBUG_FLAG               │  see Remarks  │
       ├─────────────────────────────────────────┼───────────────┤
       │ SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG  │  see Remarks  │
       ├─────────────────────────────────────────┼───────────────┤
       │ SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG       │  see Remarks  │
       ├─────────────────────────────────────────┼───────────────┤
       │ SDL_GL_CONTEXT_RESET_ISOLATION_FLAG     │  see Remarks  │
       └─────────────────────────────────────────┴───────────────┘

CODE EXAMPLES
       SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_DEBUG_FLAG);

REMARKS
       This   enumeration   is  used  in  conjunction  with  SDL_GL_SetAttribute  and
       SDL_GL_CONTEXT_FLAGS. Multiple flags can be OR'd together.

       If you don't know what these values do, you should assume the defaults are al‐
       ready  fine  and shouldn't use these flags. Not only are they not available on
       all platforms and GPU drivers, they can also have  dramatic  consequences  for
       OpenGL  functionality  and performance, so please research them heavily before
       putting these flags to use.

       SDL_GL_CONTEXT_DEBUG_FLAG

       This flag maps  to  GLX_CONTEXT_DEBUG_BIT_ARB  in  the  GLX_ARB_create_context
       (https://www.khronos.org/registry/OpenGL/extensions/ARB/GLX_ARB_create_con‐
       text.txt) extension for X11 and WGL_CONTEXT_DEBUG_BIT_ARB in the  WGL_ARB_cre‐
       ate_context                    (https://www.khronos.org/registry/OpenGL/exten‐
       sions/ARB/WGL_ARB_create_context.txt) extension for Windows. This flag is cur‐
       rently  ignored  on other targets that don't support equivalent functionality.
       This flag is intended to put the GL into a "debug" mode which might offer bet‐
       ter developer insights, possibly at a loss of performance (although a given GL
       implmentation may or may not do anything differently in the presense  of  this
       flag).

       SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG

       This  flag  maps to GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB in the GLX_ARB_cre‐
       ate_context                    (https://www.khronos.org/registry/OpenGL/exten‐
       sions/ARB/GLX_ARB_create_context.txt)  extension  for X11 and WGL_CONTEXT_FOR‐
       WARD_COMPATIBLE_BIT_ARB         in         the          WGL_ARB_create_context
       (https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_create_con‐
       text.txt) extension for Windows. This flag is currently ignored on other  tar‐
       gets that don't support equivalent functionality. This flag is intended to put
       the GL into a "forward compatible" mode, which means that no deprecated  func‐
       tionality  will  be supported, possibly at a gain in performance, and only ap‐
       plies to GL 3.0 and later contexts.

       SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG

       This flag maps to GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB in the GLX_ARB_create_con‐
       text_robustness                (https://www.khronos.org/registry/OpenGL/exten‐
       sions/ARB/GLX_ARB_create_context_robustness.txt)   extension   for   X11   and
       WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB   in  the  WGL_ARB_create_context_robustness
       (https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_create_con‐
       text_robustness.txt)  extension for Windows. This flag is currently ignored on
       other targets that don't support equivalent functionality. This  flag  is  in‐
       tended  to  require  a  GL  context that supports the GL_ARB_robustness exten‐
       sion--a mode that offers a few APIs that are safer  than  the  usual  defaults
       (think snprintf() vs sprintf()).

       SDL_GL_CONTEXT_RESET_ISOLATION_FLAG

       This  flag  maps to GLX_CONTEXT_RESET_ISOLATION_BIT_ARB in the GLX_ARB_robust‐
       ness_isolation                 (https://www.khronos.org/registry/OpenGL/exten‐
       sions/ARB/GLX_ARB_robustness_application_isolation.txt)  extension for X11 and
       WGL_CONTEXT_RESET_ISOLATION_BIT_ARB)   in   the   WGL_ARB_robustness_isolation
       (https://www.khronos.org/registry/OpenGL/extensions/ARB/WGL_ARB_robustness_ap‐
       plication_isolation.txt) extension for Windows. This flag is currently ignored
       on other targets that don't support equivalent functionality. This flag is in‐
       tended to require the GL to make promises about what to  do  in  the  face  of
       driver or hardware failure.

RELATED ENUMERATIONS
       SDL_GLattr

RELATED FUNCTIONS
       SDL_GL_GetAttribute
       SDL_GL_SetAttribute

===============================================================================
                                                                *SDL_GLprofile*


NAME
       SDL_GLprofile -- Enumerations

SYNOPSIS
       An enumeration of OpenGL profiles.

DESCRIPTION
       Values

       ┌───────────────────────────────────────┬──────────────────────────────┐
       │ SDL_GL_CONTEXT_PROFILE_CORE           │ OpenGL core profile - depre‐ │
       │                                       │ cated functions are disabled │
       ├───────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_PROFILE_COMPATIBILITY  │ OpenGL compatibility profile │
       │                                       │ -  deprecated  functions are │
       │                                       │ allowed                      │
       ├───────────────────────────────────────┼──────────────────────────────┤
       │ SDL_GL_CONTEXT_PROFILE_ES             │ OpenGL ES profile -  only  a │
       │                                       │ subset  of  the  base OpenGL │
       │                                       │ functionality is available   │
       └───────────────────────────────────────┴──────────────────────────────┘

CODE EXAMPLES
       SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);

REMARKS
       This  enumeration  is  used  in  conjunction  with  SDL_GL_SetAttribute()  and
       SDL_GL_CONTEXT_PROFILE_MASK. Although the name SDL_GL_CONTEXT_PROFILE_MASK im‐
       plies that multiple flags can be OR'd together, the profiles are mutually  ex‐
       clusive,  and  SDL_GL_SetAttribute()  accepts at most one of them. Setting the
       SDL_GL_CONTEXT_PROFILE_MASK attribute to 0 leaves the choice of profile up  to
       SDL.  Should  be used in conjunction with the SDL_GL_CONTEXT_MAJOR_VERSION and
       SDL_GL_CONTEXT_MINOR_VERSION attributes, since  OpenGL  profiles  are  defined
       relative to a particular version of OpenGL. There is no way to distinquish be‐
       tween the common and common lite profiles of OpenGL ES versions 1.0 and 1.1.

RELATED ENUMERATIONS
       SDL_GLattr

RELATED FUNCTIONS
       SDL_GL_GetAttribute
       SDL_GL_SetAttribute

===============================================================================
                                                 *SDL_GameControllerAddMapping*


NAME
       SDL_GameControllerAddMapping -- Function

SYNOPSIS
       Use  this function to add support for controllers that SDL is unaware of or to
       cause exsisting controller to have a different binding.

SYNTAX
       ┌──────────────────────────────────────────────────────────────┐
       │ int SDL_GameControllerAddMapping(const char* mappingString)  │
       └──────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────────┬──────────────────────────────┐
       │ mappingString  │ the mapping string; see  be‐ │
       │                │ low                          │
       └────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  1  if a new mapping is added, o if an existing mapping is updated, -1
       on error; call SDL_GetError() for more information.

REMARKS
       The mapping string has the  format  "GUID,name,mapping",  where  GUID  is  the
       string  value  from  SDL_JoystickGetGUIDString(),  name  is the human readable
       string for the device and mappings are controller mappings to  joystick  ones.
       Under  Windows there is a reserved GUID of "xinput" that covers all XInput de‐
       vices. The mapping format for joystick is:

       ┌───────┬────────────────────────────┐
       │ bX    │ a joystick button, index X │
       ├───────┼────────────────────────────┤
       │ hX.Y  │ hat X with value Y         │
       ├───────┼────────────────────────────┤
       │ aX    │ axis X of the joystick     │
       └───────┴────────────────────────────┘
       Buttons can be used as a controller axes and vice versa.

       This  string  shows  an  example  of  a  valid  mapping  for   a   controller:
       "341a3608000000000000504944564944,Afterglow              PS3              Con‐
       troller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dp‐
       down:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,right‐
       stick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrig‐
       ger:b7"

RELATED FUNCTIONS
       SDL_GameControllerMapping
       SDL_GameControllerMappingForGUID

===============================================================================
                                        *SDL_GameControllerAddMappingsFromFile*


NAME
       SDL_GameControllerAddMappingsFromFile -- Function

SYNOPSIS
       Use  this  function  to  load  a  set  of  Game  Controller (https://wiki.lib‐
       sdl.org/CategoryGameController) mappings from a file, filtered by the  current
       SDL_GetPlatform().  A  community  sourced database of controllers is available
       here      (https://raw.githubusercontent.com/gabomdq/SDL_GameControllerDB/mas‐
       ter/gamecontrollerdb.txt on Github).

SYNTAX
       ┌──────────────────────────────────────────────────────────────────┐
       │ int SDL_GameControllerAddMappingsFromFile(const char* filename)  │
       └──────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ filename  │ the name of the database you │
       │           │ want to load                 │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns the number of mappings added or -1 on error; call  SDL_GetError()  for
       more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────┐
       │ SDL_GameControllerAddMappingsFromFile("gamecontrollerdb.txt");  │
       └─────────────────────────────────────────────────────────────────┘

REMARKS
       You  can call this function several times if needed to load different database
       files.

       If a new mapping is loaded for an already known  controller  GUID,  the  later
       version will overwrite the one currently loaded.

       Mappings  not  beloinging  to  the  current platform or with no platform field
       specified will be ignored (i.e. mappings for Linux will be ignored in Windows,
       etc).

       This function will load the text database entirely in memory before processing
       it, so take this into consideration if you are in a memory  constrained  envi‐
       ronment.

VERSION
       This function is available since SDL 2.0.2.

RELATED FUNCTIONS
       SDL_GameControllerAddMaping
       SDL_GameControllerAddMappingsFromRW
       SDL_GameControllerMappingForGUID

===============================================================================
                                          *SDL_GameControllerAddMappingsFromRW*


NAME
       SDL_GameControllerAddMappingsFromRW -- Function

SYNOPSIS
       Use  this  function  to  load  a  set  of  Game  Controller (https://wiki.lib‐
       sdl.org/CategoryGameController) mappings from  a  seeakable  SDL  data  stream
       (memory  or  file),  filtered  by  the  current SDL_GetPlatform(). A community
       sourced database of controllers is available here  (https://raw.githubusercon‐
       tent.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt on Github).

SYNTAX
       ┌──────────────────────────────────────────────────────────────┐
       │ int SDL_GameControllerAddMappingsFromRW(SDL_RWops*  rw,      │
       │                                         int         freerw)  │
       └──────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ rw      │ the data stream for the map‐ │
       │         │ pings to be added            │
       ├─────────┼──────────────────────────────┤
       │ freerw  │ non-zero to close the stream │
       │         │ after being read             │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the  number of mappings added or -1 on error; call SDL_GetError() for
       more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_GameControllerAddMappingsFromRW(SDL_RWFromFile("gamecontrollerdb.txt", "rb"), 1);  │
       └────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       You can call this function several times if needed to load  different  databse
       files.

       If  a  new  mapping  is loaded for an already known controller GUID, the later
       version will overwrite the once currently loaded.

       Mapping not beloging to the current platform or with no platform field  speci‐
       fied  will  be  ignored  (i.e.  mappings for Linux will be ignored in Windows,
       etd).

       This function will load the text database entirely in memory before processing
       it,  so  take this into consideration if you are in a memory constrained envi‐
       ronment.

VERSION
       This function is available since SDL 2.0.2.

RELATED FUNCTIONS
       SDL_GameControllerAddMapping
       SDL_GameControllerAddMappingsFromFile
       SDL_GameControllerMappingForGUID

===============================================================================
                                                       *SDL_GameControllerAxis*


NAME
       SDL_GameControllerAxis -- Enumerations

SYNOPSIS
       An enumeration of axes available from a controller.

DESCRIPTION
       Values

       ┌───────────────────────────────────┬────┐
       │ SDL_CONTROLLER_AXIS_INVALID       │ -- │
       ├───────────────────────────────────┼────┤
       │ SDL_CONTROLLER_AXIS_LEFTX         │ -- │
       ├───────────────────────────────────┼────┤
       │ SDL_CONTROLLER_AXIS_LEFTY         │ -- │
       ├───────────────────────────────────┼────┤
       │ SDL_CONTROLLER_AXIS_RIGHTX        │ -- │
       ├───────────────────────────────────┼────┤
       │ SDL_CONTROLLER_AXIS_RIGHTY        │ -- │
       ├───────────────────────────────────┼────┤
       │ SDL_CONTROLLER_AXIS_TRIGGERLEFT   │ -- │
       ├───────────────────────────────────┼────┤
       │ SDL_CONTROLLER_AXIS_TRIGGERRIGHT  │ -- │
       ├───────────────────────────────────┼────┤
       │ SDL_CONTROLLER_AXIS_MAX           │ -- │
       └───────────────────────────────────┴────┘

RELATED FUNCTIONS
       SDL_GameControllerGetAxis
       SDL_GameControllerGetAxisFromString
       SDL_GameControllerGetBindForAxis
       SDL_GameControllerGetStringForAxis

===============================================================================
                                                     *SDL_GameControllerButton*


NAME
       SDL_GameControllerButton -- Enumerations

SYNOPSIS
       An enumeration of buttons available from a controller.

DESCRIPTION
       Values

       ┌──────────────────────────────────────┬────┐
       │ SDL_CONTROLLER_BUTTON_INVALID        │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_A              │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_B              │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_X              │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_Y              │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_BACK           │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_GUIDE          │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_START          │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_LEFTSTICK      │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_RIGHTSTICK     │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_LEFTSHOULDER   │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_RIGHTSHOULDER  │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_DPAD_UP        │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_DPAD_DOWN      │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_DPAD_LEFT      │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_DPAD_RIGHT     │ -- │
       ├──────────────────────────────────────┼────┤
       │ SDL_CONTROLLER_BUTTON_MAX            │ -- │
       └──────────────────────────────────────┴────┘

RELATED FUNCTIONS
       SDL_GameControllerGetBindForButton
       SDL_GameControllerGetButton
       SDL_GameControllerGetButtonFromString
       SDL_GameControllerGetStringForButton

===============================================================================
                                                      *SDL_GameControllerClose*


NAME
       SDL_GameControllerClose -- Function

SYNOPSIS
       Use  this function to close a game controller previously opened with SDL_Game‐
       ControllerOpen().

SYNTAX
       ┌───────────────────────────────────────────────────────────────────┐
       │ void SDL_GameControllerClose(SDL_GameController* gamecontroller)  │
       └───────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ a game controller identifier │
       │                 │ previously    returned    by │
       │                 │ SDL_GameControllerOpen()     │
       └─────────────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────────┐
       │ /* Attempt to open every controller. */                                            │
       │ for (int i=0; i<SDL_NumJoysticks(); ++i)                                           │
       │ {                                                                                  │
       │   if (SDL_IsGameController(i))                                                     │
       │   {                                                                                │
       │     SDL_GameController *controller = SDL_GameControllerOpen(i);                    │
       │     if (controller)                                                                │
       │     {                                                                              │
       │       SDL_GameControllerClose(controller);                                         │
       │     }                                                                              │
       │     else                                                                           │
       │     {                                                                              │
       │       fprintf(stderr, "Could not open gamecontroller %i: %s0, i, SDL_GetError());  │
       │     }                                                                              │
       │   }                                                                                │
       │ }                                                                                  │
       └────────────────────────────────────────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_GameControllerOpen

===============================================================================
                                                 *SDL_GameControllerEventState*


NAME
       SDL_GameControllerEventState -- Function

SYNOPSIS
       Use  this  function  to  find  the current state of, enable, or disable events
       dealing with Game Controllers. This will not disable  Joystick  events,  which
       can also be fired by a controller (see SDL_JoystickEventState()).

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ int SDL_GameControllerEventState(int state)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ state  │ can  be  one  of  SDL_QUERY, │
       │        │ SDL_IGNORE, or SDL_ENABLE    │
       └────────┴──────────────────────────────┘
       Note: You may use -1, 0, or 1 in place of SDL_QUERY, SDL_IGNORE, or SDL_ENABLE
       respectively.

RETURN VALUE
       Returns  the  same  value  passed  to  the  function,  with  exception  to  -1
       (SDL_QUERY), which will return the current state.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────┐
       │ printf("%i0, SDL_GameControllerEventState(SDL_QUERY));   /* prints 1 */  │
       │ printf("%i0, SDL_GameControllerEventState(SDL_IGNORE));  /* prints 0 */  │
       │ printf("%i0, SDL_GameControllerEventState(SDL_QUERY));   /* prints 0 */  │
       └──────────────────────────────────────────────────────────────────────────┘

REMARKS
       If controller events are disabled, you  must  call  SDL_GameControllerUpdate()
       yourself and check the state of the controller when you want controller infor‐
       mation.

       Any number can be passed to SDL_GameControllerEventState(), but  only  -1,  0,
       and 1 will have any effect. Other numbers will just be returned.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_JoystickEventState

===============================================================================
                                             *SDL_GameControllerFromInstanceID*


NAME
       SDL_GameControllerFromInstanceID -- Function

SYNOPSIS
       Use this function to get SDL_GameController associated with an instance id.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────────────────┐
       │ SDL_GameController* SDL_GameControllerFromInstanceID(SDL_JoystickID joyid)  │
       └─────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ joyid  │ the  instance  id to get the │
       │        │ SDL_GameController for       │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns an SDL_GameController on success or NULL on failure;  call  SDL_GetEr‐
       ror() for more information.

VERSION
       This function is available since SDL 2.0.4.

===============================================================================
                                                *SDL_GameControllerGetAttached*


NAME
       SDL_GameControllerGetAttached -- Function

SYNOPSIS
       Use  this  function  to check if a controller has been opened and is currently
       connected.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_GameControllerGetAttached(SDL_GameController* gamecontroller)  │
       └─────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ a game controller identifier │
       │                 │ previously    returned    by │
       │                 │ SDL_GameControllerOpen()     │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the controller has been opened and currently connected, or
       SDL_FALSE if it has not.

RELATED FUNCTIONS
       SDL_GameControllerClose
       SDL_GameControllerOpen

===============================================================================
                                                    *SDL_GameControllerGetAxis*


NAME
       SDL_GameControllerGetAxis -- Function

SYNOPSIS
       Use  this  function to get the current state of an axis control on a game con‐
       troller.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────────┐
       │ Sint16 SDL_GameControllerGetAxis(SDL_GameController*    gamecontroller,  │
       │                                  SDL_GameControllerAxis axis)            │
       └──────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ a game controller            │
       ├─────────────────┼──────────────────────────────┤
       │ axis            │ an axis index  (one  of  the │
       │                 │ SDL_GameController values)   │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  axis  state  (including  0)  on  success or 0 (also) on failure; call
       SDL_GetError() for more information.

REMARKS
       The axis indices start at index 0.

       The state is a value ranging from -32768 to 32768.  Triggers,  however,  range
       from 0 to 32767 (they never return a negative value).

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GameControllerGetButton

===============================================================================
                                          *SDL_GameControllerGetAxisFromString*


NAME
       SDL_GameControllerGetAxisFromString -- Function

SYNOPSIS
       Use  this  function  to  convert  a  string into an enum representation for an
       SDL_GameControllerAxis.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char* pchString)  │
       └────────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ pchString  │ string    representing     a │
       │            │ SDL_GameController axis      │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the SDL_GameControllerAxis enum corresponding to the input string, or
       SDL_CONTROLLER_AXIS_INVALID if no match was found.

REMARKS
       This function is called internally  to  translate  SDL_GameController  mapping
       strings  for  the  underlying joystick device into the consistent SDL_GameCon‐
       troller mapping. You do not normally need to call this function unless you are
       parsing SDL_GameController mappings in your own code.

RELATED FUNCTIONS
       SDL_GameControllerGetStringForAxis

===============================================================================
                                             *SDL_GameControllerGetBindForAxis*


NAME
       SDL_GameControllerGetBindForAxis -- Function

SYNOPSIS
       Use  this function to get the SDL joystick layer binding for a controller axis
       mapping.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis(SDL_GameController*     gamecontroller,  │
       │                                                               SDL_GameControllerAxis* axis)            │
       └────────────────────────────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ a game controller            │
       ├─────────────────┼──────────────────────────────┤
       │ axis            │ an axis enum value  (one  of │
       │                 │ the   SDL_GameControllerAxis │
       │                 │ values)                      │
       └─────────────────┴──────────────────────────────┘

REMARKS
       Returns a SDL_GameControllerButtonBind describing the bind.  On failure  (like
       the  given Controller axis doesn't exist on the device), its .bindType will be
       SDL_CONTROLLER_BINDTYPE_NONE.

RELATED STRUCTURES
       SDL_GameControllerButtonBind

RELATED FUNCTIONS
       SDL_GameControllerGetBindForButton

===============================================================================
                                           *SDL_GameControllerGetBindForButton*


NAME
       SDL_GameControllerGetBindForButton -- Function

SYNOPSIS
       Use  this  function  to get the SDL joystick layer binding for this controller
       button mapping.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_GameControllerButtonBind SDL_GameControllerGetBindForButton(SDL_GameController*       gamecontroller,  │
       │                                                                 SDL_GameControllerButton  button)          │
       └────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ a game controller            │
       ├─────────────────┼──────────────────────────────┤
       │ button          │ a button enum value (one  of │
       │                 │ the SDL_GameControllerButton │
       │                 │ values)                      │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns a SDL_GameControllerButtonBind describing the bind.  On failure  (like
       the  given  Controller  doesn't  exist  on  the device), its .bindType will be
       SDL_CONTROLLER_BINDTYPE_NONE.

RELATED STRUCTURES
       SDL_GameControllerButtonBind

RELATED FUNCTIONS
       SDL_GameControllerGetBindForAxis

===============================================================================
                                                  *SDL_GameControllerGetButton*


NAME
       SDL_GameControllerGetButton -- Function

SYNOPSIS
       Use this function to get the current state of a button on a game controller.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────────────┐
       │ Uint8 SDL_GameControllerGetButton(SDL_GameController*       gamecontroller,  │
       │                                   SDL_GameControllerButton  button)          │
       └──────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ a game controller            │
       ├─────────────────┼──────────────────────────────┤
       │ button          │ a  button  index (one of the │
       │                 │ SDL_GameControllerButton     │
       │                 │ values)                      │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  1  for  pressed  state  or  0  for  not  pressed state or error; call
       SDL_GetError() for more information.

REMARKS
       The button indices start at index 0.

VERSION
       This function is available since SDL 2.0.0

RELATED FUNCTIONS
       SDL_GameControllerGetAxis

===============================================================================
                                        *SDL_GameControllerGetButtonFromString*


NAME
       SDL_GameControllerGetButtonFromString -- Function

SYNOPSIS
       Use this function to turn a string into a button mapping.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char* pchString)  │
       └────────────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────┐
       │ pchString  │ a string │
       └────────────┴──────────┘

RETURN VALUE
       Returns  a  button  mapping  (SDL_GameControllerButton) on success or SDL_CON‐
       TROLLER_BUTTON_INVALID on failure.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GameControllerGetAxisFromString

===============================================================================
                                                *SDL_GameControllerGetJoystick*


NAME
       SDL_GameControllerGetJoystick -- Function

SYNOPSIS
       Use this function to get the Joystick ID from a Game Controller. The game con‐
       troller builds on the Joystick API, but to be able to use the Joystick's func‐
       tions with a gamepad, you need to use this first to get the joystick object.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_Joystick SDL_GameControllerGetJoystick(SDL_GameController* gamecontroller)  │
       └─────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ the  game  controller object │
       │                 │ that you want to get a  joy‐ │
       │                 │ stick from                   │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns a SDL_Joystick object; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include <stdio.h>                                                                                      │
       │                                                                                                         │
       │ /* ... */                                                                                               │
       │                                                                                                         │
       │ SDL_GameController* ctrl;                                                                               │
       │ SDL_Joystick* joy;                                                                                      │
       │ int i;                                                                                                  │
       │                                                                                                         │
       │ for (i=0; i<SDL_NumJoysticks(); ++i)                                                                    │
       │ {                                                                                                       │
       │   if (SDL_IsGameController(i))                                                                          │
       │   {                                                                                                     │
       │     printf("Index '%i' is a compatible controller, named '%s'0, i, SDL_GameControllerNameForIndex(i));  │
       │     ctrl = SDL_GameControllerOpen(i);                                                                   │
       │     joy = SDL_GameControllerGetJoystick(ctrl);                                                          │
       │   }                                                                                                     │
       │   else                                                                                                  │
       │   {                                                                                                     │
       │     printf("Index '%i' is not a compatible controller0, i);                                             │
       │   }                                                                                                     │
       │ }                                                                                                       │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This  function  will  give  you a SDL_Joystick object, which allows you to use
       SDL_Joystick functions with a SDL_GameController object. This would be  useful
       for  getting  a joystick's position at any given time, even if it hasn't moved
       (moving it would produce an event, which would have the axis' value).

       The pointer returned is owned by the SDL_GameController. You should  not  call
       SDL_JoystickClose()  on  it, for example, since doing so will likely cause SDL
       to crash.

===============================================================================
                                           *SDL_GameControllerGetStringForAxis*


NAME
       SDL_GameControllerGetStringForAxis -- Function

SYNOPSIS
       Use this function to convert from an axis enum to string.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────────────┐
       │ const char* SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis)  │
       └──────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ axis  │ an  enum  value  for a given │
       │       │ SDL_GameControllerAxis       │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns a string for the given axis, or NULL if an invalid axis is  specified.
       The  string  returned  is  of  the  format  used by SDL_GameController mapping
       strings.

RELATED FUNCTIONS
       SDL_GameControllerGetAxisFromString

===============================================================================
                                         *SDL_GameControllerGetStringForButton*


NAME
       SDL_GameControllerGetStringForButton -- Function

SYNOPSIS
       Use this function to turn a button enum into a string mapping.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────────────────────┐
       │ const char* SDL_GameControllerGetStringForButton(SDL_GameControllerButton button)  │
       └────────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ button  │ a  button enum value (one of │
       │         │ the SDL_GameControllerButton │
       │         │ values)                      │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns a string mapping on success or NULL on failure.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GameControllerGetButtonFromString

===============================================================================
                                                    *SDL_GameControllerMapping*


NAME
       SDL_GameControllerMapping -- Function

SYNOPSIS
       Use this function to get the current mapping of a Game Controller.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────┐
       │ char* SDL_GameControllerMapping(SDL_GameController* gamecontroller)  │
       └──────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ the game controller you want │
       │                 │ to get the  current  mapping │
       │                 │ for                          │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  a  string  that has the controller's mapping or NULL if no mapping is
       available; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                                         │
       │                                                                                                          │
       │ /* ... */                                                                                                │
       │                                                                                                          │
       │ SDL_GameController* ctrl;                                                                                │
       │ int i;                                                                                                   │
       │                                                                                                          │
       │ SDL_Init(SDL_INIT_GAMECONTROLLER);                                                                       │
       │                                                                                                          │
       │ for (i=0; i<SDL_NumJoysticks(); ++i)                                                                     │
       │ {                                                                                                        │
       │   if (SDL_IsGameController(i))                                                                           │
       │   {                                                                                                      │
       │     char *mapping;                                                                                       │
       │     SDL_Log("Index '%i' is a compatible controller, named '%s'", i, SDL_GameControllerNameForIndex(i));  │
       │     ctrl = SDL_GameControllerOpen(i);                                                                    │
       │     mapping = SDL_GameControllerMapping(ctrl);                                                           │
       │     SDL_Log("Controller %i is mapped as                                                                  │
       │     SDL_Free(mapping);                                                                                   │
       │   }                                                                                                      │
       │   else                                                                                                   │
       │   {                                                                                                      │
       │     SDL_Log("Index '%i' is not a compatible controller.", i);                                            │
       │   }                                                                                                      │
       │ }                                                                                                        │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The returned string must be freed with SDL_free().

       More information about the mapping can be found on the page  for  SDL_GameCon‐
       trollerAddMapping().

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GameControllerAddMapping
       SDL_GameControllerMappingForGUID

===============================================================================
                                             *SDL_GameControllerMappingForGUID*


NAME
       SDL_GameControllerMappingForGUID -- Function

SYNOPSIS
       Use this function to get the game controller mapping string for a given GUID.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ char* SDL_GameControllerMappingForGUID(SDL_JoystickGUID guid)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ guid  │ a  structure  containing the │
       │       │ GUID for which a mapping  is │
       │       │ desired                      │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns a mapping string or NULL on error; call SDL_GetError() for more infor‐
       mation.

REMARKS
       The returned string must be freed with SDL_free().

RELATED FUNCTIONS
       SDL_JoystickGetDeviceGUID
       SDL_JoystickGetGUID

===============================================================================
                                                       *SDL_GameControllerName*


NAME
       SDL_GameControllerName -- Function

SYNOPSIS
       Use  this  function to get the implementation depenent name for an opened game
       controller.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────────────┐
       │ const char* SDL_GameControllerName(SDL_GameController* gamecontroller)  │
       └─────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ gamecontroller  │ a game controller identifier │
       │                 │ previously    returned    by │
       │                 │ SDL_GameControllerOpen()     │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the implementation dependent name for the game controller, or NULL  if
       there is no name or the identifier passed is invalid.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_GameController* controller = NULL;                                                │
       │ for (int i=0; i<SDL_NumJoysticks(); ++i)                                              │
       │ {                                                                                     │
       │   controller = SDL_GameControllerOpen(i);                                             │
       │   if (controller)                                                                     │
       │   {                                                                                   │
       │     break;                                                                            │
       │   }                                                                                   │
       │ }                                                                                     │
       │                                                                                       │
       │ if (controller)                                                                       │
       │ {                                                                                     │
       │   printf("Found a valid controller, named: %s0, SDL_GameControllerName(controller));  │
       │ }                                                                                     │
       └───────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This  is the same name as returned by SDL_GameControllerNameForIndex(), but it
       takes a controller identifier instead of the (unstable) device index.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GameControllerNameForIndex
       SDL_GameControllerOpen

===============================================================================
                                               *SDL_GameControllerNameForIndex*


NAME
       SDL_GameControllerNameForIndex -- Function

SYNOPSIS
       Use  this  function to get the implementation dependent name for the game con‐
       troller.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────┐
       │ const char* SDL_GameControllerNameForIndex(int joystick_index)  │
       └─────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ joystick_index  │ the device_index  of  a  de‐ │
       │                 │ vice,   up   to  SDL_NumJoy‐ │
       │                 │ sticks()                     │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the implementation dependent name for the game controller, or NULL  if
       there is no name or the index is invalid.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────┐
       │ for (int i=0; i<SDL_NumJoysticks(); ++i)                           │
       │ {                                                                  │
       │   const char* name = SDL_GameControllerNameForIndex(i);            │
       │   if (name)                                                        │
       │   {                                                                │
       │     printf("Joystick %i has game controller name '%s'0, i, name);  │
       │   }                                                                │
       │   else                                                             │
       │   {                                                                │
       │     printf("Joystick %i has no game controller name.0, i);         │
       │   }                                                                │
       │ }                                                                  │
       └────────────────────────────────────────────────────────────────────┘

REMARKS
       This function can be called before any controllers are opened.

       joystick_index is the same as the device_index passed to SDL_JoystickOpen().

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GameControllerName
       SDL_GameControllerOpen
       SDL_IsGameController

===============================================================================
                                                       *SDL_GameControllerOpen*


NAME
       SDL_GameControllerOpen -- Function

SYNOPSIS
       Use this function to open a gamecontroller for use.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────┐
       │ SDL_GameController* SDL_GameControllerOpen(int joystick_index)  │
       └─────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ joystick_index  │ the  device_index  of  a de‐ │
       │                 │ vice,  up   to   SDL_NumJoy‐ │
       │                 │ sticks()                     │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  a  gamecontroller  identifier  or  NULL  if  an  error occurred; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────┐
       │ /* Open the first available controller. */                                           │
       │ SDL_GameController *controller = NULL;                                               │
       │ for (int i=0; i < SDL_NumJoysticks(); ++i)                                           │
       │ {                                                                                    │
       │   if (SDL_IsGameController(i))                                                       │
       │   {                                                                                  │
       │     controller = SDL_GameControllerOpen(i);                                          │
       │     if (controller)                                                                  │
       │     {                                                                                │
       │        break;                                                                        │
       │     }                                                                                │
       │     else                                                                             │
       │     {                                                                                │
       │       fprintf(stderr, "Could not open gamecontroller %i: %s\n", i, SDL_GetError());  │
       │     }                                                                                │
       │   }                                                                                  │
       │ }                                                                                    │
       └──────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       joystick_index is the same as the device_index passed to SDL_JoystickOpen().

       The index passes as an argument refers to the N'th game controller on the sys‐
       tem. This index is not the value which will identify this controller in future
       controller events. The joystick's instance id (SDL_JoystickID)  will  be  used
       there instead.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GameControllerClose
       SDL_GameControllerNameForIndex
       SDL_IsGameController

===============================================================================
                                                     *SDL_GameControllerUpdate*


NAME
       SDL_GameControllerUpdate -- Function

SYNOPSIS
       Use  this  function  to manually pump game controller updates if not using the
       loop.

SYNTAX
       ┌──────────────────────────────────────┐
       │ void SDL_GameControllerUpdate(void)  │
       └──────────────────────────────────────┘

REMARKS
       This function is called automatically by the event loop if events are enabled.
       Under such circumstances, it will not be necessary to call this function.

===============================================================================
                                                              *SDL_GetAppState*


NAME
       SDL_GetAppState - Get the state of the application

SYNOPSIS
       #include "SDL.h"

       Uint8 SDL_GetAppState(void);

DESCRIPTION
       This function returns the current state of the application. The value returned
       is a bitwise combination of:

       SDL_APPMOUSEFOCUS   The application has mouse focus.

       SDL_APPINPUTFOCUS   The application has keyboard focus

       SDL_APPACTIVE       The application is visible

SEE ALSO
       SDL_ActiveEvent

===============================================================================
                                                      *SDL_GetAssertionHandler*


NAME
       SDL_GetAssertionHandler -- Function

SYNOPSIS
       Use this function to get the current assertion handler.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────┐
       │ SDL_AssertionHandler SDL_GetAssertionHandler(void** puserdata)  │
       └─────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ puserdata  │ pointer which is filled with │
       │            │ the "userdata" pointer  that │
       │            │ was  passed to SDL_SetAsser‐ │
       │            │ tionHandler();  see  Remarks │
       │            │ for details.                 │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the SDL_AssertionHandler that is called when an assert triggers.

REMARKS
       This  returns  the function pointer that is called when an assertion is trigg‐
       gered. This is either the value last passed to  SDL_SetAssertionHandler(),  or
       if no application-specified function is set, is equivalent to calling SDL_Get‐
       DefaultAssertionHandler().

       The parameter puserdata is a pointer to a void*, which will store  the  "user‐
       data"  pointer  that  was passed to SDL_SetAssertionHandler(). This value will
       always be NULL for the default handler. If you dont' care about this data,  it
       is safe to pass a NULL pointer to this function to ignore it.

VERSION
       This function is available since SDL 2.0.2.

RELATED FUNCTIONS
       SDL_SetAssertionHandler

===============================================================================
                                                       *SDL_GetAssertionReport*


NAME
       SDL_GetAssertionReport -- Function

SYNOPSIS
       Use this function to get a list of all assertion failures.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ cosnt SDL_AssertData* SDL_GetAssertionReport(void)  │
       └─────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  a  list  of  all failed assertions or NULL if the list is empty. This
       memory should not be modified or freed by the application.

CODE EXAMPLES
       The proper way to examine this data looks something like this

       ┌───────────────────────────────────────────────────────────────────────┐
       │ const SDL_AssertData *item = SDL_GetAssertionReport();                │
       │ while (item) {                                                        │
       │   printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.0,  │
       │     item->condition, item->function, item->filename,                  │
       │     item->linenum, item->trigger_count,                               │
       │     item->always_ignore ? "yes" : "no");                              │
       │   item = item->next;                                                  │
       │ }                                                                     │
       └───────────────────────────────────────────────────────────────────────┘

REMARKS
       This function gets all assertions triggered since the last call  to  SDL_Rese‐
       tAssertionReport(), or the start of the program.

RELATED FUNCTIONS
       SDL_ResetAssertionReport

===============================================================================
                                                       *SDL_GetAudioDeviceName*


NAME
       SDL_GetAudioDeviceName -- Function

SYNOPSIS
       Use this function to get the name of a specific audio device.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ const char* SDL_GetAudioDeviceName(int    index,      │
       │                                    int    iscapture)  │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ index      │ the  index  of the audio de‐ │
       │            │ vice; the value ranges  from │
       │            │ 0    to   SDL_GetNumAudioDe‐ │
       │            │ vices() - 1                  │
       ├────────────┼──────────────────────────────┤
       │ iscapture  │ non-zero to specify a device │
       │            │ that  has recording capabil‐ │
       │            │ ity                          │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the name of the audio device at the requested index, or NULL on error.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────┐
       │ int i, count = SDL_GetNumAudioDevices(0);                            │
       │                                                                      │
       │ for (i = 0; i<count; ++i)                                            │
       │ {                                                                    │
       │   SDL_Log("Audio device: %d: %s", i, SDL_GetAudioDeviceName(i, 0));  │
       │ }                                                                    │
       └──────────────────────────────────────────────────────────────────────┘

REMARKS
       This function is only valid after successfully initializing the audio  subsys‐
       tem.  The values returned by this function reflect the latest call to SDL_Get‐
       NumAudioDevices(); re-call that function to re-detet available hardware.

       The string returned by this function is UTF-8 encoded, read-only, and  managed
       internally.  You  are  not  to free it. If you need to keep the string for any
       length of time, you should make your own copy of it, as  it  will  be  invalid
       next time any of servral other SDL functions are called.

RELATED FUNCTIONS
       SDL_GetNumAudioDevices

===============================================================================
                                                     *SDL_GetAudioDeviceStatus*


NAME
       SDL_GetAudioDeviceStatus -- Function

SYNOPSIS
       Use this function to get the current audio state of an audio device.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────┐
       │ SDL_AudioStatus SDL_GetAudioDeviceStatus(SDL_AudioDeviceID dev)  │
       └──────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ dev  │ the  ID  of  an audio device │
       │      │ previously    opened    with │
       │      │ SDL_OpenAudioDevice()        │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns  the SDL_AudioStatus of the specified audio device which may be one of
       the following

       ┌────────────────────┬─────────────────────────┐
       │ SDL_AUDIO_STOPPED  │ audio device is stopped │
       ├────────────────────┼─────────────────────────┤
       │ SDL_AUDIO_PLAYING  │ audio device is playing │
       ├────────────────────┼─────────────────────────┤
       │ SDL_AUDIO_PAUSED   │ audio device is paused  │
       └────────────────────┴─────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────┐
       │ void printStatus(SDL_AudioDeviceID dev)                      │
       │ {                                                            │
       │   switch (SDL_GetAudioDeviceStatus(dev))                     │
       │   {                                                          │
       │     case SDL_AUDIO_STOPPED: printf("stopped\n"); break;      │
       │     case SDL_AUDIO_PLAYING: printf("playing\n"); break;      │
       │     case SDL_AUDIO_PAUSED: printf("paused\n"); break;        │
       │     default:L printf("???"); break;                          │
       │   }                                                          │
       │ }                                                            │
       │                                                              │
       │ // device starts paused                                      │
       │ SDL_AudioDeviceID dev;                                       │
       │ dev = SDL_OpenAudioDevice(NULL, 0, &desired, &obtained, 0);  │
       │ if (dev != 0)                                                │
       │ {                                                            │
       │   printStatus(dev);   // prints "paused"                     │
       │   SDL_PauseAudioDevice(dev, 0);                              │
       │   printStatus(dev);   // prints "playing"                    │
       │   SDL_PauseAudioDevice(dev, 1);                              │
       │   printStatus(dev);   // prints "paused"                     │
       │   SDL_CloseAudioDevice(dev);                                 │
       │   printStatus(dev);   // prints "stopped"                    │
       │ }                                                            │
       └──────────────────────────────────────────────────────────────┘

REMARKS
       Opened devices are always PLAYING or PAUSEED in normal circumstances. A  fail‐
       ing  device may change its status to STOPPED at any time, and closing a device
       will progress to STOPPED, too. Asking for the state on an unopened or  unknown
       device ID will report STOPPED.

RELATED FUNCTIONS
       SDL_PauseAudioDevice

===============================================================================
                                                           *SDL_GetAudioDriver*


NAME
       SDL_GetAudioDriver -- Function

SYNOPSIS
       Use this function to get the name of a built in audio driver.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ const char* SDL_GetAudioDriver(int index)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ index  │ the   index   of  the  audio │
       │        │ driver;  the  value   ranges │
       │        │ from  0  to SDL_GetNumAudio‐ │
       │        │ Drivers() - 1                │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns the name of the audio driver at the requested index, or NULL if an in‐
       valid index was specified.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────┐
       │ int i;                                                        │
       │                                                               │
       │ for (i = 0; i < SDL_GetNumAudioDrivers(); ++i)                │
       │ {                                                             │
       │   printf("Audio driver %d: %s\n", i, SDL_GetAudioDriver(i));  │
       │ }                                                             │
       └───────────────────────────────────────────────────────────────┘

REMARKS
       The  list  of  audio drivers is given in the order that they are normally ini‐
       tialized by default; the drivers that seem more reasonable to choose first (as
       far as the SDL developers believe) are earlier in the list.

       The  names  of  drivers  are  all  simple, low-ASCII identifiers, like "alsa",
       "coreaudio", or "xaudio2". These never have Unicode characters,  and  are  not
       meant to be proper names.

RELATED FUNCTIONS
       SDL_GetNumAudioDrivers

===============================================================================
                                                           *SDL_GetAudioStatus*


NAME
       SDL_GetAudioStatus -- Function

SYNOPSIS
       This  function  is  a  legacy means of querying the audio device. New programs
       might want to use SDL_GetAudioDeviceStatus() instead.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ SDL_AudioStatus SDL_GetAudioStatus(void)  │
       └───────────────────────────────────────────┘

RETURN VALUE
       Returns the SDL_AudioStatus of the specified audio device which may be one  of
       the following:

       ┌────────────────────┬─────────────────────────┐
       │ SDL_AUDIO_STOPPED  │ audio device is stopped │
       ├────────────────────┼─────────────────────────┤
       │ SDL_AUDIO_PLAYING  │ audio device is playing │
       ├────────────────────┼─────────────────────────┤
       │ SDL_AUDIO_PAUSED   │ audio device is paused  │
       └────────────────────┴─────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────┐
       │ void printStatus(void)                                   │
       │ {                                                        │
       │   switch (SDL_GetAudioStatus())                          │
       │   {                                                      │
       │     case SDL_AUDIO_STOPPED: printf("stopped\n"); break;  │
       │     case SDL_AUDIO_PLAYING: printf("playing\n"); break;  │
       │     case SDL_AUDIO_PAUSED: printf("paused\n"); break;    │
       │     default: pritnf("???"); break;                       │
       │   }                                                      │
       │ }                                                        │
       │                                                          │
       │ extern SDL_AudioSpec desired;                            │
       │ extern SDL_AudioSpec obtained;                           │
       │                                                          │
       │ // device status paused                                  │
       │ if (SDL_OpenAudio(&desired, &obtained) == 0)             │
       │ {                                                        │
       │   printStatus();    // prints "paused"                   │
       │   SDL_PauseAudio(0);                                     │
       │   printStatus();    // prints "playing"                  │
       │   SDL_PauseAudio(1);                                     │
       │   printStatus();    // prints "paused"                   │
       │   SDL_CloseAudio();                                      │
       │   printStatus();    // prints "stopped"                  │
       │ }                                                        │
       └──────────────────────────────────────────────────────────┘

REMARKS
       This function is equivalent to calling

       ┌──────────────────────────────┐
       │ SDL_GetAudioDeviceStatus(1)  │
       └──────────────────────────────┘
       and is only useful if you used the legacy SDL_OpenAudio() function.

RELATED FUNCTIONS
       SDL_GetAudioDeviceStatus

===============================================================================
                                                              *SDL_GetBasePath*


NAME
       SDL_GetBasePath -- Function

SYNOPSIS
       Use  this  function  to  get the directory where the application was run from.
       This is where the application data directory is.

SYNTAX
       ┌──────────────────────────────┐
       │ char* SDL_GetBasePath(void)  │
       └──────────────────────────────┘

RETURN VALUE
       Returns an absolute path in UTF-8 encoding to the application data  directory.
       NULL  will  be  returned  on error or when the platform doesn't implement this
       functionality, call SDL_GetError() for more information.

       The return path will be guaranteed to end with a path separator  (''  on  Win‐
       dows, '/' on most other platforms).

       The  pointer  returned  is owned by you. Please call SDL_free() on the pointer
       when you are done with it.

CODE EXAMPLES
       ┌─────────────────────────────────────────┐
       │ char *data_path = NULL;                 │
       │                                         │
       │ void InitializeDataPath()               │
       │ {                                       │
       │   char *base_path = SDL_GetBasePath();  │
       │   if (base_path)                        │
       │   {                                     │
       │     data_path = base_path;              │
       │   }                                     │
       │   else                                  │
       │   {                                     │
       │     data_path = SDL_strdup("./");       │
       │   }                                     │
       │ }                                       │
       └─────────────────────────────────────────┘

REMARKS
       This is not necessarily a fast call, though so you should call this once  near
       startup and save the string if you need it.

       macOS  and  iOS Specific Functionality: If the application is in a ".app" bun‐
       dle, this function returns the Resource directory (e.g. MyApp.app/Contents/Re‐
       sources/).  This  behavior  can  be  overriden  by  adding  a  property to the
       Info.plist  file.  Adding  a   string   key   with   the   name   SDL_FILESYS‐
       TEM_BASE_DIR_TYPE with a supported value will change the behavior.

       Supported  values  for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an ap‐
       plication in /Applications/SDLApp/MyApp.app):

       ┌───────────┬───────────────────────┬───────────────────────┐
       │  Value    │      Description      │ Example returned path │
       ├───────────┼───────────────────────┼───────────────────────┤
       │ resource  │ the  bundle  resource │ /Applications/SD‐     │
       │           │ directory   (the  de‐ │ LApp/MyApp.app/Con‐   │
       │           │ fault)                │ tents/Resources       │
       ├───────────┼───────────────────────┼───────────────────────┤
       │ bundle    │ the Bundle directory  │ /Applications/SD‐     │
       │           │                       │ LApp/MyApp.app/       │
       ├───────────┼───────────────────────┼───────────────────────┤
       │ parent    │ the containing direc‐ │ /Applications/SDLApp/ │
       │           │ tory of the bundle    │                       │
       └───────────┴───────────────────────┴───────────────────────┘

VERSION
       This function is available since SDL 2.0.1.

RELATED FUNCTIONS
       SDL_GetPrefPath

===============================================================================
                                                      *SDL_GetCPUCacheLineSize*


NAME
       SDL_GetCPUCacheLineSize -- Function

SYNOPSIS
       Use this function to determine the L1 cache line size of the CPU.

SYNTAX
       ┌────────────────────────────────────┐
       │ int SDL_GetCPUCacheLineSize(void)  │
       └────────────────────────────────────┘

RETURN VALUE
       Returns the L1 cache line size of the CPU, in bytes.

REMARKS
       This  is  useful  for  determining  multi-threaded  structure  padding or SIMD
       prefetch sizes.

VERSION
       This function is available since SDL 2.0.0.

===============================================================================
                                                              *SDL_GetCPUCount*


NAME
       SDL_GetCPUCount -- Function

SYNOPSIS
       Use this function to get the number of CPU cores available.

SYNTAX
       ┌────────────────────────────┐
       │ int SDL_GetCPUCount(void)  │
       └────────────────────────────┘

RETURN VALUE
       Returns  the total number of logical CPU cores. On CPUs that include technolo‐
       gies such as hyperthreading, the number of logical cores may be more than  the
       number of physical cores.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────┐
       │ SDL_Log("Number of logical CPU cores: %d", SDL_GetCPUCount());  │
       └─────────────────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

===============================================================================
                                                              *SDL_GetClipRect*


NAME
       SDL_GetClipRect -- Function

SYNOPSIS
       Use this function to get the clipping rectangle for a surface.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ void SDL_GetClipRect(SDL_Surface*   surface,  │
       │                      SDL_Rect*      rect)     │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the   SDL_Surface  structure │
       │          │ representing the surface  to │
       │          │ be clipped                   │
       ├──────────┼──────────────────────────────┤
       │ rect     │ an SDL_Rect structure filled │
       │          │ in with the clipping rectan‐ │
       │          │ gle for the surface; see Re‐ │
       │          │ marks for details            │
       └──────────┴──────────────────────────────┘

REMARKS
       When surface is the destination of a blit, only the area within the clip  rec‐
       tangle is drawn into.

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_SetClipRect

===============================================================================
                                                         *SDL_GetClipboardText*


NAME
       SDL_GetClipboardText -- Function

SYNOPSIS
       Use  this  function  to get UTF-8 text from the clipboard, which must be freed
       with SDL_free().

SYNTAX
       ┌───────────────────────────────────┐
       │ char* SDL_GetClipboardText(void)  │
       └───────────────────────────────────┘

RETURN VALUE
       Returns the clipboard text on success or NULL on failure; call  SDL_GetError()
       for more information.

REMARKS
       This  function  returns NULL if there was not enough memory left for a copy of
       the clipboard's content.

RELATED FUNCTIONS
       SDL_HasClipboardText
       SDL_SetClipboardText

===============================================================================
                                                    *SDL_GetClosestDisplayMode*


NAME
       SDL_GetClosestDisplayMode -- Function

SYNOPSIS
       Use this function to get the closest match to the requested display mode.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_DisplayMode* SDL_GetClosestDisplayMode(int                      displayIndex,  │
       │                                            const SDL_DisplayMode*   mode,          │
       │                                            SDL_DisplayMode*         closest)       │
       └────────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the  index of the display to │
       │               │ query                        │
       ├───────────────┼──────────────────────────────┤
       │ mode          │ an SDL_DisplayMode structure │
       │               │ containing  the desired dis‐ │
       │               │ play mode                    │
       ├───────────────┼──────────────────────────────┤
       │ closest       │ an SDL_DisplayMode structure │
       │               │ filled  in  with the closest │
       │               │ match of the available  dis‐ │
       │               │ play modes                   │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the  passed  in  value  closest or NULL if no matching video mode was
       available; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────┐
       │ // Using SDL2' SDL_GetClosestDisplayMode()                                                  │
       │                                                                                             │
       │ #include "SDL.h"                                                                            │
       │ #include <stdio.h>                                                                          │
       │                                                                                             │
       │ int main(int argc, char* argv[])                                                            │
       │ {                                                                                           │
       │   // Declare structures to be filled in.                                                    │
       │   SDL_DisplayMode target, closest;                                                          │
       │                                                                                             │
       │   SDL_Init(SDL_INIT_VIDEO);                                                                 │
       │                                                                                             │
       │   // Set the desired resolution, etc.                                                       │
       │   target.w = 600;                                                                           │
       │   target.h = 500;                                                                           │
       │   target.format = 0;  // don't care                                                         │
       │   target.refresh_rate = 0;  // don't care                                                   │
       │   target.driverdata = 0;    // initialize to 0                                              │
       │   printf("Requesting: \t%dx%dpx @ %dhz \n", target.w, target.h, target.refresh_rate);       │
       │                                                                                             │
       │   // Pass the display mode structures by reference to SDL_GetClosestDisplay                 │
       │   // and check whether the result is a null pointer.                                        │
       │   if (SDL_GetClosestDisplayMode(0, &target, &closest) == NULL)                              │
       │     // if the returned pointer is null, no match was found.                                 │
       │     printf("\nNo suitable display mode was found!\n\n");                                    │
       │   else                                                                                      │
       │     // Otherwise, a display mode close to the target is available.                          │
       │     // Access the SDL_DisplayMode structure to see what was received.                       │
       │     printf("  Received: \t%dx%dpx @ %dhz \n", closest.w, closest.h, closest.refresh_rate);  │
       │                                                                                             │
       │   // Clean up and exit the program.                                                         │
       │   SDL_Quit();                                                                               │
       │   return 0;                                                                                 │
       │ }                                                                                           │
       └─────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The available display modes are scanned and closest  is  filled  in  with  the
       closest mode matching the requested mode and returned. The mode format and re‐
       fresh rate default to the desktop mode if they are set to  0.  The  modes  are
       scanned  with size being first priority, format being second priority, and fi‐
       nally checking the refresh rate. If all the available  modes  are  too  small,
       then NULL is returned.

RELATED FUNCTIONS
       SDL_GetDisplayMode
       SDL_GetNumDisplayModes

===============================================================================
                                                              *SDL_GetColorKey*


NAME
       SDL_GetColorKey -- Function

SYNOPSIS
       Use this function to get the color key (transparent pixel) for a surface.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ int SDL_GetColorKey(SDL_Surface*  surface,  │
       │                     Uint32*       key)      │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ query                        │
       ├──────────┼──────────────────────────────┤
       │ key      │ a pointer filled in with the │
       │          │ transparent pixel            │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

       If the surface doesn't have color key enabled this function returns -1.

REMARKS
       The color key is a pixel of the format used by the surface,  as  generated  by
       SDL_MapRGB().

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_SetColorKey

===============================================================================
                                                    *SDL_GetCurrentAudioDriver*


NAME
       SDL_GetCurrentAudioDriver -- Function

SYNOPSIS
       Use this function to get the name of the current audio driver.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ const char* SDL_GetCurrentAudioDriver(void)  │
       └──────────────────────────────────────────────┘

RETURN VALUE
       Returns  the  name  of  the current audio driver or NULL if no driver has been
       initialized.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────┐
       │ const char* driver_name = SDL_GetCurrentAudioDriver();                 │
       │                                                                        │
       │ if (driver_name)                                                       │
       │ {                                                                      │
       │   pritnf("Audio subsystem initialized; driver = %s.\n", driver_name);  │
       │ }                                                                      │
       │ else                                                                   │
       │ {                                                                      │
       │   printf("Audio subsystem not initialized.\n");                        │
       │ }                                                                      │
       └────────────────────────────────────────────────────────────────────────┘

REMARKS
       The returned string points to internal static memory and  thus  never  becomes
       invalid, even if you quit the audio subsystem and initialize a new driver (al‐
       though such a case would return a different static string from another call to
       this function, of course). As such, you should not modify or free the returned
       stirng.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_AudioInit

===============================================================================
                                                    *SDL_GetCurrentDisplayMode*


NAME
       SDL_GetCurrentDisplayMode -- Function

SYNOPSIS
       Use this function to get information about the current display mode.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ int SDL_GetCurrentDisplayMode(int               displayIndex,  │
       │                               SDL_DisplayMode*  mode)          │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the  index of the display to │
       │               │ query                        │
       ├───────────────┼──────────────────────────────┤
       │ mode          │ an SDL_DisplayMode structure │
       │               │ filled  in  with the current │
       │               │ display mode                 │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ // Using SDL2's SDL_GetCurrentDisplayMode()                                                                            │
       │                                                                                                                        │
       │ #include "SDL.h"                                                                                                       │
       │                                                                                                                        │
       │ int main(int argc, char* argv[])                                                                                       │
       │ {                                                                                                                      │
       │   int i;                                                                                                               │
       │                                                                                                                        │
       │   // Declare display mode structure to be filled in.                                                                   │
       │   SDL_DisplayMode current;                                                                                             │
       │                                                                                                                        │
       │   SDL_Init(SDL_INIT_VIDEO);                                                                                            │
       │                                                                                                                        │
       │   // Get current display mode of all displays.                                                                         │
       │   for (i=0; i<SDL_GetNumVideoDisplays(); ++i)                                                                          │
       │   {                                                                                                                    │
       │     int should_be_zero = SDL_GetCurrentDisplayMode(i, &current);                                                       │
       │                                                                                                                        │
       │     if (should_be_zero != 0)                                                                                           │
       │     {                                                                                                                  │
       │       // In case of error...                                                                                           │
       │       SDL_Log("Could not get display mode for video display #%d: %s", i, SDL_GetError());                              │
       │     }                                                                                                                  │
       │     else                                                                                                               │
       │     {                                                                                                                  │
       │       // On success, print the current display mode.                                                                   │
       │       SDL_Log("Display #%d: current display mode is %dx%dpx @ %dhz.", i, current.w, current.h, current.refresh_rate);  │
       │     }                                                                                                                  │
       │   }                                                                                                                    │
       │                                                                                                                        │
       │   // Clean up and exit the program                                                                                     │
       │   SDL_Quit();                                                                                                          │
       │   return 0;                                                                                                            │
       │ }                                                                                                                      │
       └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       There's  a  difference  between  this function and SDL_GetDesktopDisplayMode()
       when SDL runs fullscreen and has changed the resolution.  In  that  case  this
       function  will  return  the  current display mode, and not the previous native
       display mode.

RELATED FUNCTIONS
       SDL_GetDesktopDisplayMode
       SDL_GetDisplayMode
       SDL_GetNumVideoDisplays
       SDL_SetWindowDisplayMode

===============================================================================
                                                    *SDL_GetCurrentVideoDriver*


NAME
       SDL_GetCurrentVideoDriver -- Function

SYNOPSIS
       Use this function to get the name of the currently initialized video driver.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ const char* SDL_GetCurrentVideoDriver(void)  │
       └──────────────────────────────────────────────┘

RETURN VALUE
       Returns  the  name  of  the current video driver or NULL if no driver has been
       initialized.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetNumVideoDrivers
       SDL_GetVideoDriver

===============================================================================
                                                                *SDL_GetCursor*


NAME
       SDL_GetCursor -- Function

SYNOPSIS
       Use this function to get the active cursor.

SYNTAX
       ┌──────────────────────────────────┐
       │ SDL_Cursor* SDL_GetCursor(void)  │
       └──────────────────────────────────┘

RETURN VALUE
       Returns the active cursor or NULL if there is no mouse.

REMARKS
       This  function  returns  a pointer to the current cursor which is owned by the
       library. It is not necessary to free the cursor with SDL_FreeCursor().

RELATED FUNCTIONS
       SDL_SetCursor

===============================================================================
                                               *SDL_GetDefaultAssertionHandler*


NAME
       SDL_GetDefaultAssertionHandler -- Function

SYNOPSIS
       Use this function to get the default assertion handler.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ SDL_AssertionHandler SDL_GetDefaultAssertionHandler(void)  │
       └────────────────────────────────────────────────────────────┘

RETURN VALUE
       Returns  the  default SDL_AssertionHandler that is called when an assert trig‐
       gers.

REMARKS
       This returns the function pointer that is called by default when an  assertion
       is  triggered.  This is an internal function provided by SDL, that is used for
       assertions when SDL_SetAssertionHandler() hasn't been used to provide  a  dif‐
       ferent function.

VERSION
       This function is available since SDL 2.0.2.

RELATED FUNCTIONS
       SDL_GetAssertionHandler

===============================================================================
                                                         *SDL_GetDefaultCursor*


NAME
       SDL_GetDefaultCursor -- Function

SYNOPSIS
       Use this function to get the default cursor.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ SDL_Cursor* SDL_GetDefaultCursor(void)  │
       └─────────────────────────────────────────┘

RETURN VALUE
       Returns the default cursor on success or NULL on failure.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_CreateSystemCursor

===============================================================================
                                                    *SDL_GetDesktopDisplayMode*


NAME
       SDL_GetDesktopDisplayMode -- Function

SYNOPSIS
       Use this function to get information about the desktop display mode.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────┐
       │ int SDL_GetDesktopDisplayMode(int                 displayIndex,  │
       │                               SDL_DisplayMode*    mode)          │
       └──────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the  index of the display to │
       │               │ query                        │
       ├───────────────┼──────────────────────────────┤
       │ mode          │ an SDL_DisplayMode structure │
       │               │ filled  in  with the current │
       │               │ display mode                 │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────┐
       │ SDL_DisplayMode dm;                                                 │
       │ if (SDL_GetDesktopDisplayMode(0, &dm) != 0)                         │
       │ {                                                                   │
       │   SDL_Log("SDL_GetDesktopDisplayMode failed: %s", SDL_GetError());  │
       │   return 1;                                                         │
       │ }                                                                   │
       └─────────────────────────────────────────────────────────────────────┘

REMARKS
       There's  a  difference  between  this function and SDL_GetCurrentDisplayMode()
       when SDL runs fullscreen and has changed the resolution.  In  that  case  this
       function  will  return  the  previous native display mode, and not the current
       display mode.

RELATED FUNCTIONS
       SDL_GetCurrentDisplayMode
       SDL_GetDisplayMode
       SDL_SetWindowDisplayMode

===============================================================================
                                                         *SDL_GetDisplayBounds*


NAME
       SDL_GetDisplayBounds -- Function

SYNOPSIS
       Use  this  function to get the desktop area represented by a display, with the
       primary display located at 0,0.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_GetDisplayBounds(int          displayIndex,  │
       │                          SDL_Rect*    rect)          │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the index of the display  to │
       │               │ query                        │
       ├───────────────┼──────────────────────────────┤
       │ rect          │ the    SDL_Rect    structure │
       │               │ filled in with  the  display │
       │               │ bounds                       │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────┐
       │ SDL_Rect r;                                                    │
       │ if (SDL_GetDisplayBounds(0, &r) != 0)                          │
       │ {                                                              │
       │   SDL_Log("SDL_GetDisplayBounds failed: %s", SDL_GetError());  │
       │   return 1;                                                    │
       │ }                                                              │
       └────────────────────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetNumVideoDisplays

===============================================================================
                                                            *SDL_GetDisplayDPI*


NAME
       SDL_GetDisplayDPI -- Function

SYNOPSIS
       Use this function to get dots/pixels-per-inch for a display.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ int SDL_GetDisplayDPI(int     displayIndex,  │
       │                       float*  ddpi,          │
       │                       float*  hdpi,          │
       │                       float*  vdpi)          │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the  index  of  the  display │
       │               │ from which  DPI  information │
       │               │ should be queried            │
       ├───────────────┼──────────────────────────────┤
       │ ddpi          │ a  pinter filled in with the │
       │               │ diagonal DPI of the display; │
       │               │ may be NULL                  │
       ├───────────────┼──────────────────────────────┤
       │ hdpi          │ a pointer filled in with the │
       │               │ horizontal DPI of  the  dis‐ │
       │               │ play; may be NULL            │
       ├───────────────┼──────────────────────────────┤
       │ vdpi          │ a pointer filled in with the │
       │               │ vertical DPI of the display; │
       │               │ may be NULL                  │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Diagonal, horizontal and vertical DPI can all be optionally  returned  if  the
       parameter is non-NULL.

       A  failure  of  this  function usually means that either no DPI information is
       available or the displayIndex is out of range.

VERSION
       This funtion is available since SDL 2.0.4.

RELATED FUNCTIONS
       SDL_GetNumVideoDisplays

===============================================================================
                                                           *SDL_GetDisplayMode*


NAME
       SDL_GetDisplayMode -- Function

SYNOPSIS
       Use this function to get information about a specific display mode.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ int SDL_GetDisplayMode(int                displayIndex,  │
       │                       int                 modeIndex,     │
       │                       SDL_DisplayMode*    mode)          │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the  index of the display to │
       │               │ query                        │
       ├───────────────┼──────────────────────────────┤
       │ modeIndex     │ the  index  of  the  display │
       │               │ mode to query                │
       ├───────────────┼──────────────────────────────┤
       │ mode          │ an SDL_DisplayMode structure │
       │               │ filled in with the  mode  at │
       │               │ modeIndex                    │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0  on  success or negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ int display_count = 0, display_index = 0, mode_index = 0;                                                       │
       │ SDL_DisplayMode mode = { SDL_PIXELFORMAT_UNKNOWN, 0, 0, 0, 0 };                                                 │
       │                                                                                                                 │
       │ if ((display_count = SDL_GetNumVideoDisplays()) < 1 )                                                           │
       │ {                                                                                                               │
       │   SDL_Log("SDL_GetNumVideoDisplays returned: %i", display_count);                                               │
       │   return 1;                                                                                                     │
       │ }                                                                                                               │
       │                                                                                                                 │
       │ if (SDL_GetDisplayMode(display_index, mode_index, &mode) != 0)                                                  │
       │ {                                                                                                               │
       │   SDL_Log("SDL_GetDisplayMode failed: %s", SDL_GetError());                                                     │
       │   return 1;                                                                                                     │
       │ }                                                                                                               │
       │                                                                                                                 │
       │ SDL_Log("SDL_GetDisplayMode(0, 0, &mode):\t\t%i bpp\t%i x %i", SDL_BITSPERPIXEL(mode.format), mode.w, mode.h);  │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The display modes are sorted in this priority:

       - width -> largest to smallest
       - height -> largest to smallest
       - bits per pixel -> more colors to fewer colors
       - packed pixel layout -> largest to smallest
       - refresh rate -> highest to lowest

RELATED FUNCTIONS
       SDL_GetNumDisplayModes

===============================================================================
                                                           *SDL_GetDisplayName*


NAME
       SDL_GetDisplayName -- Function

SYNOPSIS
       Use this function to get the name of a display in UTF-8 encoding.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ const char* SDL_GetDisplayName(int displayIndex)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the  index  of  display from │
       │               │ which  the  name  should  be │
       │               │ queried                      │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the name of a display or NULL for an invalid display index or failure;
       call SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetNumVideoDisplays

===============================================================================
                                                   *SDL_GetDisplayUsableBounds*


NAME
       SDL_GetDisplayUsableBounds -- Function

SYNOPSIS
       Use this function to get the usable desktop area reprsented by a display, with
       the primary display located at 0,0.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ int SDL_GetDisplayUsableBounds(int          displayIndex,  │
       │                                SDL_Rect*    rect)          │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the index of the display  to │
       │               │ query the usable bounds from │
       ├───────────────┼──────────────────────────────┤
       │ rect          │ the    SDL_Rect    structure │
       │               │ filled in with  the  display │
       │               │ bounds                       │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       This is the same area as SDL_GetDisplayBounds() reports, but with portions re‐
       served  by the system removed. For example, on Apple macOS, this subtracts the
       area occupied by the menu bar and dock.

       Setting a window to be fullscreen generally bypasses these unusable areas,  so
       these  are good guidelines for the maximum space available to a non-fullscreen
       window.

       The parameter rect is ignored if it is NULL.

       This function also returns -1 if the parameter displayIndex is out of range.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_GetDisplayBounds
       SDL_GetNumVideoDisplays

===============================================================================
                                                                 *SDL_GetError*


NAME
       SDL_GetError -- Function

SYNOPSIS
       Use this function to retrieve a message about the last error that occurred.

SYNTAX
       ┌─────────────────────────────────┐
       │ const char* SDL_GetError(void)  │
       └─────────────────────────────────┘

RETURN VALUE
       Returns  a message with information about the specific error that occurred, or
       an empty string if there hasn't been an error message set since the last  call
       to  SDL_ClearError().  The message is only applicable when an SDL function has
       signaled an error. You must check the return values of SDL function  calls  to
       determine when to appropriate call SDL_GetError().

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────┐
       │ if (SDL_Init(SDL_INIT_EVERYTHING) < 0)              │
       │ {                                                   │
       │   // Unrecoverable error, exit here.                │
       │   printf("SDL_Init failed: %s\n", SDL_GetError());  │
       │ }                                                   │
       └─────────────────────────────────────────────────────┘
       Note:  Although this example uses SDL_Init(), SDL_GetError() provides an error
       message for an failed SDL operation which supports error  reporting,  see  the
       wiki page for each particular SDL function.

REMARKS
       It  is  possible  for multiple errors to occcur before calling SDL_GetError().
       Only the last error is returned.

       The returned string is statically allocated and must not be freed by  the  ap‐
       plication.

RELATED FUNCTIONS
       SDL_ClearError
       SDL_SetError

===============================================================================
                                                           *SDL_GetEventFilter*


NAME
       SDL_GetEventFilter -- Function

SYNOPSIS
       Use this function to query the current event filter.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_GetEventFilter(SDL_EventFilter*    filter,    │
       │                             void**              userdata)  │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ filter    │ the  current  callback func‐ │
       │           │ tion will  be  stored  here; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ the  pointer  that is passed │
       │           │ to the current event  filter │
       │           │ will be stored here          │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE on success or SDL_FALSE if there is no event filter set.

REMARKS
       This function ca be used to "chain" filters, by saving the existing filter be‐
       fore replacing it with a function that will call that saved filter.

RELATED FUNCTIONS
       SDL_SetEventFilter

===============================================================================
                                                            *SDL_GetEventState*


NAME
       SDL_GetEventState -- Function

SYNOPSIS
       Use this macro to query the current processing state of a specified SDL_Event‐
       Type.

SYNTAX
       ┌───────────────────────────────────────┐
       │ Uint8 SDL_GetEventState(Uint32 type)  │
       └───────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬────────────────────────────┐
       │ type  │ the SDL_EventType to query │
       └───────┴────────────────────────────┘

RETURN VALUE
       Returns SDL_DISABLE or SDL_ENABLE.

RELATED FUNCTIONS
       SDL_EventState

===============================================================================
                                                                 *SDL_GetGamma*


NAME
       SDL_GetGamma - Gets the gamma of the display

SYNOPSIS
       #include "SDL.h"

       int SDL_GetGamma(float *red, float *green, float *blue);

DESCRIPTION
       Gets  the color gamma of the display. The gamma value for each color component
       will be place in the parameters red, green and blue. The values can range from
       0.1 to 10.

              Note:

              This function currently only works on XFreee 4.0 and up.

SEE ALSO
       SDL_SetGamma, SDL_SetVideoMode

===============================================================================
                                                             *SDL_GetGammaRamp*


NAME
       SDL_GetGammaRamp - Gets the color gamma lookup tables for the display

SYNOPSIS
       #include "SDL.h"

       int SDL_GetGammaRamp(Uint16 *redtable, Uint16 *greentable, Uint16 *bluetable);

DESCRIPTION
       Gets  the  gamma translation lookup tables currently used by the display. Each
       table is an array of 256 Uint16 values.

       Not all display hardware is able to change gamma.

RETURN VALUE
       Returns -1 on error.

SEE ALSO
       SDL_SetGamma SDL_SetGammaRamp

===============================================================================
                                                      *SDL_GetGlobalMouseState*


NAME
       SDL_GetGlobalMouseState -- Function

SYNOPSIS
       Use  this  function  to  get the current state of the mouse in relation to the
       desktop.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ Uint32 SDL_GetGlobalMouseState(int*   x,  │
       │                                int*   y)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ x  │ filled in with the current X │
       │    │ coord  relative to the desk‐ │
       │    │ top; call be NULL            │
       ├────┼──────────────────────────────┤
       │ y  │ filled in with the current Y │
       │    │ coord  relative to the desk‐ │
       │    │ top; can be NULL             │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns the current button state as a bitmask which can be  tested  using  the
       SDL_BUTTON(X) macros.

REMARKS
       This works just like SDL_GetMouseState(), but the coordinates will be reported
       relative to the top-left of the desktop. This can be useful  if  you  need  to
       track  the  mouse  outside of a specific window and SDL_CaptureMouse() doesn't
       fit your needs. For example, it could be useful if you need to track the mouse
       while  dragging  a window, where coordinates relative to a window might not be
       in sync at all times.

       Note: SDL_GetMouseState() returns the mouse position  as  SDL  understands  it
       from  the  last pump of the event queue. This function however, queries the OS
       for the current mouse position, and as such, might be a  slightly  less  effi‐
       cient function. Unless you know what you're doing and hae a good reason to use
       this function, you probably want SDL_GetMouseState() instead.

VERSION
       This function is available since SDL 2.0.4.

RELATED FUNCTIONS
       SDL_CaptureMouse

===============================================================================
                                                         *SDL_GetGrabbedWindow*


NAME
       SDL_GetGrabbedWindow -- Function

SYNOPSIS
       Use this function to get the window that currently has an input grab enabled.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ SDL_Window* SDL_GetGrabbedWindow(void)  │
       └─────────────────────────────────────────┘

RETURN VALUE
       Returns the window if input is grabbed or NULL otherwise.

VERSION
       This function is available since SDL 2.0.4.

RELATED FUNCTIONS
       SDL_GetWindowGrab
       SDL_GetWindowGrab

===============================================================================
                                                                  *SDL_GetHint*


NAME
       SDL_GetHint -- Function

SYNOPSIS
       Use this function to get the value of a hint.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ const char* SDL_GetHint(const char* name)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ name  │ the  hint  to query; see the │
       │       │ list of hints  on  Category‐ │
       │       │ Hints(Ihttps://wiki.lib‐     │
       │       │ sdl.org/CategoryHints#Hints) │
       │       │ for details.                 │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns the string value of a hint or NULL if the hint isn't set.

RELATED FUNCTIONS
       SDL_SetHint
       SDL_SetHintWithPriority

===============================================================================
                                                           *SDL_GetHintBoolean*


NAME
       SDL_GetHintBoolean -- Function

SYNOPSIS
       Use this function to get the boolean value of a hint variable.

SYNTAX
       ┌───────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_GetHintBoolean(const char*   name,           │
       │                             SDL_bool      default_value)  │
       └───────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────────┬──────────────────────────────┐
       │ name           │ the  name of the hint to get │
       │                │ the boolean value from       │
       ├────────────────┼──────────────────────────────┤
       │ default_value  │ the value to return  if  the │
       │                │ hint does not exist          │
       └────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the boolean value of a hint or the provided default value if the hint
       does not exist.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_GetHint
       SDL_SetHint

===============================================================================
                                                           *SDL_GetKeyFromName*


NAME
       SDL_GetKeyFromName -- Function

SYNOPSIS
       Use this function to get a key code from a human-readable name.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ SDL_Keycode SDL_GetKeyFromName(const char* name)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬─────────────────────────────┐
       │ name  │ the human-readable key name │
       └───────┴─────────────────────────────┘

RETURN VALUE
       Returns  key  code,  or  SDLK_UNKNOWN  if  the  name  wasn't  recognized; call
       SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_GetKeyFromScancode
       SDL_GetKeyName
       SDL_GetScancodeFromName

===============================================================================
                                                       *SDL_GetKeyFromScancode*


NAME
       SDL_GetKeyFromScancode -- Function

SYNOPSIS
       Use  this function to get the key code corresponding to the given scancode ac‐
       cording to the current keyboard layout.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode)  │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ scancode  │ the desired SDL_Scancode  to │
       │           │ query                        │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns the SDL_Keycode that corresponds to the given SDL_Scancode

REMARKS
       See SDL_Keycode for details.

RELATED FUNCTIONS
       SDL_GetKeyName
       SDL_GetScancodeFromKey

===============================================================================
                                                               *SDL_GetKeyName*


NAME
       SDL_GetKeyName -- Function

SYNOPSIS
       Use this function to get a human-readable name for a key.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ const char* SDL_GetKeyName(SDL_Keycode key)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ key  │ the  desired  SDL_Keycode to │
       │      │ query                        │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to a UTF-8 string that stays valid at least until  the  next
       call  to this function. If you need it around any longer, you must copy it. If
       the key doesn't have a name, this function returns an empty string ("").

REMARKS
       See SDL_Scancode and SDL_Keycode for details.

RELATED FUNCTIONS
       SDL_GetKeyFromName
       SDL_GetKeyFromScancode
       SDL_GetScancodeFromKey

===============================================================================
                                                              *SDL_GetKeyState*


NAME
       SDL_GetKeyState - Get a snapshot of the current keyboard state

SYNOPSIS
       #include "SDL.h"

       Uint8 *SDL_GetKeyState(int *numkeys);

DESCRIPTION
       Gets  a snapshot of the current keyboard state. The current state is return as
       a pointer to an array, the size of this array is stored in numkeys. The  array
       is  indexed by the SDLK_* symbols. A value of 1 means the key is pressed and a
       value of 0 means its not. The pointer returned is a pointer to an internal SDL
       array and should not be freed by the caller.

              Note:

              Use SDL_PumpEvents to update the state array.

EXAMPLE
       Uint8 *keystate = SDL_GetKeyState(NULL);
       if ( keystate[SDLK_RETURN] ) printf("Return Key Pressed.
       ");

SEE ALSO
       SDL Key Symbols, SDL_PumpEvents

===============================================================================
                                                         *SDL_GetKeyboardFocus*


NAME
       SDL_GetKeyboardFocus -- Function

SYNOPSIS
       Use this function to get the window which currently has keyboard focus.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ SDL_Window* SDL_GetKeyboardFocus(void)  │
       └─────────────────────────────────────────┘

RETURN VALUE
       Returns the window with keyboard focus.

===============================================================================
                                                         *SDL_GetKeyboardState*


NAME
       SDL_GetKeyboardState -- Function

SYNOPSIS
       Use this function to get a snapshot of the current state of the keyboard.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ const Uint8* SDL_GetKeyboardState(int* numkeys)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ numkeys  │ if  non-NULL,  receives  the │
       │          │ length of the returned array │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to an array of key states. A value of 1 menas that  the  key
       is  pressed and a value of 0 means that it is not. Indexes into this array are
       obtained by using SDL_Scancode values. The pointer returned is a pointer to an
       internal SDL array. It will be valid for the whole lifetime of the application
       and should not be freed by the caller.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────┐
       │ const Uint8* state = SDL_GetKeyboardState(NULL);          │
       │ if (state[SDL_SCANCODE_RETURN])                           │
       │ {                                                         │
       │   printf("<RETURN> is pressed.\n");                       │
       │ }                                                         │
       │ if (state[SDL_SCANCODE_RIGHT] && state[SDL_SCANCODE_UP])  │
       │ {                                                         │
       │   printf("Right and Up keys pressed.\n");                 │
       │ }                                                         │
       └───────────────────────────────────────────────────────────┘

REMARKS
       Note: Use SDL_PumpEvent() to update the state array.

       Note: This function gives you the current state after  all  events  have  been
       processed,  so  if  a  key  or button has been pressed and released before you
       process events, then the processed state will never show up in the  SDL_GeKey‐
       boardState() calls.

       Note:  This  function doesn't take into account whether shift has been pressed
       or not.

RELATED FUNCTIONS
       SDL_PumpEvents

===============================================================================
                                                              *SDL_GetModState*


NAME
       SDL_GetModState -- Function

SYNOPSIS
       Use this function to get the current key modifier state for the keyboard.

SYNTAX
       ┌───────────────────────────────────┐
       │ SDL_Keymod SDL_GetModState(void)  │
       └───────────────────────────────────┘

RETURN VALUE
       Returns  an  OR'd  combination  of  the  modifier  keys  for the keyboard. See
       SDL_Keymod for details.

RELATED FUNCTIONS
       SDL_GetKeyboardState
       SDL_SetModState

===============================================================================
                                                            *SDL_GetMouseFocus*


NAME
       SDL_GetMouseFocus -- Function

SYNOPSIS
       Use this function to get the window currently has mouse focus.

SYNTAX
       ┌──────────────────────────────────────┐
       │ SDL_Window* SDL_GetMouseFocus(void)  │
       └──────────────────────────────────────┘

RETURN VALUE
       Returns the window with mouse focus.

===============================================================================
                                                            *SDL_GetMouseState*


NAME
       SDL_GetMouseState -- Function

SYNOPSIS
       Use this function to retrieve the current state of the mouse.

SYNTAX
       ┌───────────────────────────────────┐
       │ Uint32 SDL_GetMouseState(int* x   │
       │                          int* y)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ x  │ the   x  coordinate  of  the │
       │    │ mouse cursor position  rela‐ │
       │    │ tive to the focus window     │
       ├────┼──────────────────────────────┤
       │ y  │ the   y  coordinate  of  the │
       │    │ mouse cursor position  rela‐ │
       │    │ tive to the focus window     │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns a 32-bit button bitmask of the current button state.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────┐
       │ SDL_PumpEvents();                                                │
       │ if (SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(SDL_BUTTON_LEFT)  │
       │ {                                                                │
       │   SDL_Log("Mouse BUtton 1 (left) is pressed.");                  │
       │ }                                                                │
       └──────────────────────────────────────────────────────────────────┘

REMARKS
       The  current button state is returned as a button bitmask, which can be tested
       using the SDL_BUTTON(X) macros (where X is generally 1 for  the  left,  2  for
       middle, 3 for the right button), and x and y are set to the mouse cursor posi‐
       tion relative to the focus window for the currently selected  mouse.  You  can
       pass NULL for either x and y.

RELATED FUNCTIONS
       SDL_GetGlobalMouseState
       SDL_GetRelativeMouseState
       SDL_PumpEvents

===============================================================================
                                                       *SDL_GetNumAudioDevices*


NAME
       SDL_GetNumAudioDevices -- Function

SYNOPSIS
       Use this function to get the number of built-in audio devices.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ int SDL_GetNumAudioDevices(int iscapture)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ iscapture  │ zero to request playback de‐ │
       │            │ vices, non-zero  to  request │
       │            │ recording devices            │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the number of available devices exposed by the current driver or -1 if
       an explicit list of devices can't be determined. A return value of -1 does not
       necessarily mean an error condition. See Remarks for details.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────┐
       │ int i, count = SDL_GetNumAudioDevices(0);                            │
       │ for (i = 0; i<count; ++i)                                            │
       │ {                                                                    │
       │   printf("Audio device %d: %s\n", i, SDL_GetAudioDeviceName(i, 0));  │
       │ }                                                                    │
       └──────────────────────────────────────────────────────────────────────┘

REMARKS
       This  function is only valid after successfully initializing the audio subsys‐
       tem.

       Note that audio capture support is not implemented as of SDL 2.0.4, so the is‐
       capture parameter is for future expansion and should always be zero for now.

       This  function  will  return -1 if an explicit list of devices can't be deter‐
       mined. Returning -1 is not an error. For example, if SDL is set up to talk  to
       a  remote audio server, it can't list every one available on the Internet, but
       it will still allow a specific host to be specified in SDL_OpenAudioDevice().

       In many common cases, when this funtion returns a value <=  0,  it  can  still
       successfully  open  the default device (NULL for first argument of SDL_OpenAu‐
       dioDevice()).

       This function may trigger a complete redetect of available hardware. It should
       not  be called for each iteration of a loop, but rather once at the start of a
       loop:

       ┌────────────────────────────────────────────────────────────────────────┐
       │ // Don't do this: for (int i = 0; i < SDL_GetNumAudioDevices(0); ++i)  │
       │ // do this instead:                                                    │
       │ const int count = SDL_GetNumAudioDevices(0);                           │
       │ for (int i = 0; i < count; ++i) { /* do something here. */ }           │
       └────────────────────────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetAudioDeviceName
       SDL_OpenAudioDevice

===============================================================================
                                                       *SDL_GetNumAudioDrivers*


NAME
       SDL_GetNumAudioDrivers -- Function

SYNOPSIS
       Use this function to get the number of built-in audio drivers.

SYNTAX
       ┌───────────────────────────────────┐
       │ int SDL_GetNumAudioDrivers(void)  │
       └───────────────────────────────────┘

RETURN VALUE
       Returns the number of built-in audio drivers.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────┐
       │ int i;                                                        │
       │ for (int i=0; i<SDL_GetNumAudioDrivers(); ++i)                │
       │ {                                                             │
       │   printf("Audio driver %d: %s\n", i, SDL_GetAudioDriver(i));  │
       │ }                                                             │
       └───────────────────────────────────────────────────────────────┘

REMARKS
       This function returns a hardcoded number. This never returns a negative value;
       if there are no drivers compiled into this build of SDL, this function returns
       zero. The presence of a driver in this list dose not mean it will function, it
       just means SDL is capable of interacting with that interface. For  example,  a
       build of SDL might have esound support, but if there's no esound server avail‐
       able, SDL's esound driver would fail if used.

       By default, SDL tries all drivers, in its preferred order, until one is  found
       to be usable.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetAudioDriver

===============================================================================
                                                       *SDL_GetNumDisplayModes*


NAME
       SDL_GetNumDisplayModes -- Function

SYNOPSIS
       Use this function to get the number of available display modes.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_GetNumDisplayModes(int displayIndex)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ displayIndex  │ the  index of the display to │
       │               │ query                        │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns a number >= 1 on success or a negative error  code  on  failure;  call
       SDL_GetError for more information.

REMARKS
       The  displayIndex needs to be in the range from 0 to SDL_GetNumVideoDisplays()
       - 1.

       This allows you to support multiple screens.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetDisplayMode
       SDL_GetNumVideoDisplays

===============================================================================
                                                      *SDL_GetNumRenderDrivers*


NAME
       SDL_GetNumRenderDrivers -- Function

SYNOPSIS
       Use  this function to get the number of 2D rendering drivers available for the
       current display.

SYNTAX
       ┌────────────────────────────────────┐
       │ int SDL_GetNumRenderDrivers(void)  │
       └────────────────────────────────────┘

RETURN VALUE
       Returns a number >= 0 on success or a negative error  code  on  failure;  call
       SDL_GetError() for more information.

REMARKS
       A render driver is a set of code that handles rendering and texture management
       on a particular display. Normally there is only one, but some drivers may have
       several available with different capabilities.

       There may be none if SDL was compiled without render support.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_CreateRenderer
       SDL_GetRenderDriverInfo

===============================================================================
                                                       *SDL_GetNumTouchDevices*


NAME
       SDL_GetNumTouchDevices -- Function

SYNOPSIS
       Use this function to get the number of registered touch devices.

SYNTAX
       ┌───────────────────────────────────┐
       │ int SDL_GetNumTouchDevices(void)  │
       └───────────────────────────────────┘

RETURN VALUE
       Returns the number of registered touch devices.

REMARKS
       On  some  platforms  SDL  first sees the touch device if it was actually used.
       Therefore SDL_GetNumTouchDevices() may return 0 although  devices  are  avail‐
       able. After using all devices at least once the number will be correct.

       This was fixed for Android in SDL 2.0.1.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetTouchDevice

===============================================================================
                                                       *SDL_GetNumTouchFingers*


NAME
       SDL_GetNumTouchFingers -- Function

SYNOPSIS
       Use this function to get the number of active fingers for a give touch device.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ int SDL_GetNumTouchFingers(SDL_TouchID touchID)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────┐
       │ touchID  │ the ID of a touch device │
       └──────────┴──────────────────────────┘

RETURN VALUE
       Returns  the number of active fingers for a given touch device on success or 0
       on failure; call SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetTouchFinger

===============================================================================
                                                      *SDL_GetNumVideoDisplays*


NAME
       SDL_GetNumVideoDisplays -- Function

SYNOPSIS
       Use this function to get the number of available video dispplays.

SYNTAX
       ┌────────────────────────────────────┐
       │ int SDL_GetNumVideoDisplays(void)  │
       └────────────────────────────────────┘

RETURN VALUE
       Returns a number >= 1 or a negative error code on failure; call SDL_GetError()
       for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetDisplayBounds

===============================================================================
                                                       *SDL_GetNumVideoDrivers*


NAME
       SDL_GetNumVideoDrivers -- Function

SYNOPSIS
       Use this function to get the number of video drivers compiled into SDL.

SYNTAX
       ┌───────────────────────────────────┐
       │ int SDL_GetNumVideoDrivers(void)  │
       └───────────────────────────────────┘

RETURN VALUE
       Returns  a  number  >=  1 on success or a negative error code on failure; call
       SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_GetVideoDriver

===============================================================================
                                                    *SDL_GetPerformanceCounter*


NAME
       SDL_GetPerformanceCounter -- Function

SYNOPSIS
       Use this function to get the current value of the high resolution counter.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ Uint64 SDL_GetPerformanceCounter(void)  │
       └─────────────────────────────────────────┘

REMARKS
       This function is typically used for polling.

       The counter values are only meaningful relative to each other. Differences be‐
       tween values can be converted to times by using SDL_GetPerformanceFrequency().

RELATED FUNCTIONS
       SDL_GetPerformanceFrequency

===============================================================================
                                                  *SDL_GetPerformanceFrequency*


NAME
       SDL_GetPerformanceFrequency -- Function

SYNOPSIS
       Use this function to get the count per second of the high resolution counter.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ Uint64 SDL_GetPerformanceFrequency(void)  │
       └───────────────────────────────────────────┘

RETURN VALUE
       Returns a platform-specific count per second.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include <SDL2/SDL.h>                                                                                                                                                     │
       │                                                                                                                                                                           │
       │ #define DEFAULT_RESOLUTION 1                                                                                                                                              │
       │                                                                                                                                                                           │
       │ static int ticks = 0;                                                                                                                                                     │
       │                                                                                                                                                                           │
       │ static Uint32 SDLCALL                                                                                                                                                     │
       │ ticktock(Uint32 interval, void* param)                                                                                                                                    │
       │ {                                                                                                                                                                         │
       │   ++ticks;                                                                                                                                                                │
       │   return interval;                                                                                                                                                        │
       │ }                                                                                                                                                                         │
       │                                                                                                                                                                           │
       │ static Uint32 SDLCALL                                                                                                                                                     │
       │ callback(Uint32 interval, void* param)                                                                                                                                    │
       │ {                                                                                                                                                                         │
       │   SDL_Log("Timer %d : param = %d", interval, (int)(uintptr_t)param);                                                                                                      │
       │   return interval;                                                                                                                                                        │
       │ }                                                                                                                                                                         │
       │                                                                                                                                                                           │
       │ int                                                                                                                                                                       │
       │ main(int argc, char* argv[])                                                                                                                                              │
       │ {                                                                                                                                                                         │
       │   int i, desired;                                                                                                                                                         │
       │   SDL_TimerID t1, t2, t3;                                                                                                                                                 │
       │   Uint32 start32, now32;                                                                                                                                                  │
       │   Uint64 start, now;                                                                                                                                                      │
       │                                                                                                                                                                           │
       │   /* Enable standard application logging */                                                                                                                               │
       │   SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_INFO);                                                                                                │
       │                                                                                                                                                                           │
       │   if (SDL_Init(SDL_INIT_TIMER) < 0)                                                                                                                                       │
       │   {                                                                                                                                                                       │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Counldn't initialize SDL: %s", SDL_GetError());                                                                           │
       │     return 1;                                                                                                                                                             │
       │   }                                                                                                                                                                       │
       │                                                                                                                                                                           │
       │   /* Start the timer */                                                                                                                                                   │
       │   desired = 0;                                                                                                                                                            │
       │   if (argv[1])                                                                                                                                                            │
       │   {                                                                                                                                                                       │
       │     desired = SDL_atoi(argv[1]);                                                                                                                                          │
       │   }                                                                                                                                                                       │
       │   if (desired == 0)                                                                                                                                                       │
       │   {                                                                                                                                                                       │
       │     desired = DEFAULT_RESOLUTION;                                                                                                                                         │
       │   }                                                                                                                                                                       │
       │   t1 = SDL_AddTimer(desired, ticktock, NULL);                                                                                                                             │
       │                                                                                                                                                                           │
       │   /* Wait 10 seconds */                                                                                                                                                   │
       │   SDL_Log("Waiting 10 seconds");                                                                                                                                          │
       │   SDL_Delay(10 * 1000);                                                                                                                                                   │
       │                                                                                                                                                                           │
       │   /* Stop the timer */                                                                                                                                                    │
       │   SDL_RemoveTimer(t1);                                                                                                                                                    │
       │                                                                                                                                                                           │
       │   /* Print the results */                                                                                                                                                 │
       │   if (ticks)                                                                                                                                                              │
       │   {                                                                                                                                                                       │
       │     SDL_Log("Timer resolution: desired = %d ms, actual = %f ms", desired , (double)(10 * 1000) / ticks);                                                                  │
       │   }                                                                                                                                                                       │
       │                                                                                                                                                                           │
       │   /* Test multiple timers */                                                                                                                                              │
       │   SDL_Log("Testing multiple times...");                                                                                                                                   │
       │   t1 = SDL_AddTimer(100, callback, (void*)1);                                                                                                                             │
       │   if (!t1)                                                                                                                                                                │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create timer 1: %s", SDL_GetError());                                                                           │
       │   t2 = SDL_AddTimer(50, callback, (void*)2);                                                                                                                              │
       │   if (!t2)                                                                                                                                                                │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create timer 2: %s", SDL_GetError());                                                                           │
       │   t3 = SDL_AddTimer(233, callback, (void*)3);                                                                                                                             │
       │   if (!t3)                                                                                                                                                                │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create timer 3: %s", SDL_GetError());                                                                           │
       │     SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not create timer 3: %s", SDL_GetError());                                                                           │
       │                                                                                                                                                                           │
       │   /* Wait 10 seconds */                                                                                                                                                   │
       │   SDL_Log("Waiting 10 seconds");                                                                                                                                          │
       │   SDL_Delay(10 * 1000);                                                                                                                                                   │
       │                                                                                                                                                                           │
       │   SDL_Delay(5 * 1000);                                                                                                                                                    │
       │                                                                                                                                                                           │
       │   SDL_RemoveTimer(t2);                                                                                                                                                    │
       │   SDL_RemoveTimer(t3);                                                                                                                                                    │
       │                                                                                                                                                                           │
       │   start = SDL_GetPerformanceCounter();                                                                                                                                    │
       │   for (i = 0; i < 1000000; ++i)                                                                                                                                           │
       │   {                                                                                                                                                                       │
       │     ticktock(0, NULL);                                                                                                                                                    │
       │   }                                                                                                                                                                       │
       │   now = SDL_GetPerformanceCounter();                                                                                                                                      │
       │   SDL_Log("1 million iterations of ticktock took %f ms", (double)((now - start) * 1000) / SDL_GetPerformanceFrequency());                                                 │
       │                                                                                                                                                                           │
       │   SDL_Log("Performance counter frequency: %"SDL_PRIu64"", (unsigned long long)SDL_GetPerformanceFrequency());                                                             │
       │   start32 = SDL_GetTicks();                                                                                                                                               │
       │   start = SDL_GetPerformanceCounter();                                                                                                                                    │
       │   SDL_Delay(1000);                                                                                                                                                        │
       │   now = SDL_GetPerformanceCounter();                                                                                                                                      │
       │   now32 = SDL_GetTicks();                                                                                                                                                 │
       │   SDL_Log("Delay 1 secodn = %d ms in ticks, %f ms according to performance counter", (now32 - start32), (double)((now - start) * 1000) / SDL_GetPerformanceFrequency());  │
       │                                                                                                                                                                           │
       │   SDL_Quit();                                                                                                                                                             │
       │   return 0;                                                                                                                                                               │
       │ }                                                                                                                                                                         │
       └───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetPerformanceCounter

===============================================================================
                                                       *SDL_GetPixelFormatName*


NAME
       SDL_GetPixelFormatName -- Function

SYNOPSIS
       Use this function to get the human readable name of a pixel format.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ const char* SDL_GetPixelFormatName(Uint32 format)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬───────────────────────────┐
       │ format  │ the pixel format to query │
       └─────────┴───────────────────────────┘

RETURN VALUE
       Returns  the  human  readable  name of the specified pixel format or "SDL_PIX‐
       ELFORMAT_UNKNOWN" if the format isn't recognized.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_Surface* surface = ...;   // a valid surface from wherever.                   │
       │ SDL_PixelFormat* pixelFormat = surface->format;                                   │
       │ Uint32 pixelFormatEnum = pixelFormat->format;                                     │
       │ const char* surfacePixelFormatName = SDL_GetPixelFormatName(pixelFormatEnum);     │
       │ SDL_Log("The surface's pixelformat is %s", surfacePixelFormatName);               │
       │ // prints something like "The surface's pixelformat is SDL_PIXELFORMAT_ARGB8888"  │
       └───────────────────────────────────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

===============================================================================
                                                              *SDL_GetPlatform*


NAME
       SDL_GetPlatform -- Function

SYNOPSIS
       Use this function to get the name of the platform.

SYNTAX
       ┌────────────────────────────────────┐
       │ const char* SDL_GetPlatform(void)  │
       └────────────────────────────────────┘

RETURN VALUE
       Returns  the  name of the platform. If the correct platform name is not avail‐
       able, returns a string beginning with the text "Unknown".

REMARKS
       Here are the names returned for some supported platforms:

       - Windows
       - macOS
       - Linux
       - iOS
       - Android

===============================================================================
                                                             *SDL_GetPowerInfo*


NAME
       SDL_GetPowerInfo -- Function

SYNOPSIS
       Use this function to get the current power supply details.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ SDL_PowerState SDL_GetPowerInfo(int*  secs,  │
       │                                 int*  pct)   │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ secs  │ seconds   of   battery  life │
       │       │ left, you can  pass  a  NULL │
       │       │ here if you don't care, will │
       │       │ return -1 if we can't deter‐ │
       │       │ mine  a  value, or we're not │
       │       │ running on a battery         │
       ├───────┼──────────────────────────────┤
       │ pct   │ percentage of  battery  life │
       │       │ left, between 0 and 100, you │
       │       │ can pass a NULL here if  you │
       │       │ don't  care,  will return -1 │
       │       │ if  we  can't  determine   a │
       │       │ value,  or we're not runnong │
       │       │ on a battery                 │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns the state of the battery, if any. Return values may be any of the fol‐
       lowing:

       ┌────────────────────────────┬──────────────────────────────┐
       │ SDL_POWERSTATE_UNKNOWN     │ cannot  determine power sta‐ │
       │                            │ tus                          │
       ├────────────────────────────┼──────────────────────────────┤
       │ SDL_POWERSTATE_ON_BATTERY  │ not plugged in,  runnong  on │
       │                            │ the battery                  │
       ├────────────────────────────┼──────────────────────────────┤
       │ SDL_POWERSTATE_NO_BATTERY  │ plugged   in,   no   battery │
       │                            │ available                    │
       ├────────────────────────────┼──────────────────────────────┤
       │ SDL_POWERSTATE_CHARGING    │ plugged in, charging battery │
       ├────────────────────────────┼──────────────────────────────┤
       │ SDL_POWERSTATE_CHARGED     │ plugged in, battery charged  │
       └────────────────────────────┴──────────────────────────────┘
       See SDL_PowerState for more info.

       Both parameters will return -1 if a value can't be determined, or if not  run‐
       ning on a battery.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────┐
       │ int secs, pct;                                                   │
       │ if (SDL_GetPowerInfo(&secs, &pct) == SDL_POWERSTATE_ON_BATTERY)  │
       │ {                                                                │
       │   printf("Battery is draining: ");                               │
       │   if (secs == -1)                                                │
       │   {                                                              │
       │     printf("(unknown time left)\n");                             │
       │   }                                                              │
       │   else                                                           │
       │   {                                                              │
       │     printf("(%d seconds left)\n", secs);                         │
       │   }                                                              │
       │                                                                  │
       │   if (pct == -1)                                                 │
       │   {                                                              │
       │     printf("(unknown percentage left)\n");                       │
       │   }                                                              │
       │   else                                                           │
       │   {                                                              │
       │     printf("(%d percent left)\n", pct);                          │
       │   }                                                              │
       │ }                                                                │
       └──────────────────────────────────────────────────────────────────┘

REMARKS
       You  should  never  take  a battery status as absolute truth. Batteries (espe‐
       cially failing batteries) are delicate hardware, adn the values reported  here
       are best estimates based on what that hardware reports. It's not uncommmon for
       older batteries to lose stored power much faster  than  it  reports,  or  com‐
       pletely drain when reporting it has 20 percent left, etc.

       Battery  status can change at any time; if you are concerned with power state,
       you should call this function frequently, and  perhaps  ignore  changes  until
       they seem to be stable for a few seconds.

===============================================================================
                                                              *SDL_GetPrefPath*


NAME
       SDL_GetPrefPath -- Function

SYNOPSIS
       Use  this function to get the "pref dir". This is meant to be where the appli‐
       cation can write personal files (Preferences and save games,  etc.)  that  are
       specific  to the application. This directory is unique per user and per appli‐
       cation.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ char* SDL_GetPrefPath(const char*   org,  │
       │                       const char*   app)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ org  │ the name of  your  organiza‐ │
       │      │ tion                         │
       ├──────┼──────────────────────────────┤
       │ app  │ the name of your application │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns  a  UTF-8 string of the user directory in platform-dependent notation.
       NULL if there's a problem (creating directory failed, etc.).

       The return path will be guaranteed to end with a path separator  (''  on  Win‐
       dows, '/' on most other platforms).

       The  pointer  returned  is owned by you. Please call SDL_free() on the pointer
       when you are done with it.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────┐
       │ char* pref_path = NULL;                                                      │
       │                                                                              │
       │ void InitializePrefPath()                                                    │
       │ {                                                                            │
       │   char* base_path = SDL_GetPrefPath("My Company", "My Awesome SDL 2 Game");  │
       │   if (base_path)                                                             │
       │   {                                                                          │
       │     pref_path = base_path;                                                   │
       │   }                                                                          │
       │   else                                                                       │
       │   {                                                                          │
       │     /* Do something to disable writing in-game */                            │
       │   }                                                                          │
       │ }                                                                            │
       └──────────────────────────────────────────────────────────────────────────────┘

REMARKS
       You should assume the path returned by this function is the only safe place to
       write  files  (and that SDL_GetBasePath(), while it might be writable, or even
       the parent of the returned path, aren't where you should be writing things)(.

       Both the org and app strings may become part of a directory  name,  so  please
       follow these rules:

       - Try to use the same org string (including case-sensitivity) for all your ap‐
       plications that use this function
       - Always use a unique app string for each one, and make sure it never  changes
       for an app once you've decide on it
       - Unicode characters are legal, as long as it's UTF-8 encoded, but...
       -  ...only use letters, numbers, and spaces. Avoid punctuation like "Game Name
       2: Bad Guys' Revenge!" ... "Game Name 2" is sufficient.

VERSION
       This function is available since SDL 2.0.1.

RELATED FUNCTIONS
       SDL_GetBasePath

===============================================================================
                                                       *SDL_GetQueuedAudioSize*


NAME
       SDL_GetQueuedAudioSize -- Function

SYNOPSIS
       Use this function to get the number of bytes of still-queued audio.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ Uint32 SDL_GetQueuedAudioSize(SDL_AudioDeviceID dev)  │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ dev  │ the  device  ID  of which we │
       │      │ will query queued audio size │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns the number of bytes (not samples!) of queued audio.

REMARKS
       This is  the  number  of  bytes  that  have  been  queued  for  playback  with
       SDL_QueueAudio(), but have not yet been sent to the hardware.

       Once  we've  sent  it  to the hardware, this function can nod decide the exact
       byte boundary of what has been played. It's possible that  we  just  gave  the
       hardware  several  kilobytes  right  before  you  called this function, but it
       hasn't played any of it yet, or maybe half of it, etc.

       You may not queue audio on a device  that  is  using  an  application-supplied
       callback; calling this function on such a device always returns 0. You have to
       use the audio callback or queue audio with SDL_QueueAudio(), but not both.

       You should not call SDL_LockAudio() on the device before querying; SDL handles
       locking internally for this function.

VERSION
       This function is available since SDL 2.0.4.

RELATED FUNCTIONS
       SDL_ClearQueuedAudio
       SDL_QueueAudio

===============================================================================
                                                                   *SDL_GetRGB*


NAME
       SDL_GetRGB -- Function

SYNOPSIS
       Use this function to get RGB values from a pixel in the specified format.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_GetRGB(Uint32                    pixel,   │
       │                 const SDL_PixelFormat*    format,  │
       │                 Uint8*                    r,       │
       │                 Uint8*                    g,       │
       │                 Uint8*                    b)       │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ pixel   │ a pixel value                │
       ├─────────┼──────────────────────────────┤
       │ format  │ an SDL_PixelFormat structure │
       │         │ describing the format of the │
       │         │ pixel                        │
       ├─────────┼──────────────────────────────┤
       │ r       │ a pointer filled in with the │
       │         │ red component                │
       ├─────────┼──────────────────────────────┤
       │ g       │ a pointer filled in with the │
       │         │ green component              │
       ├─────────┼──────────────────────────────┤
       │ b       │ a pointer filled in with the │
       │         │ blue component               │
       └─────────┴──────────────────────────────┘

REMARKS
       This function uses the entire 8-bit [0..255] range when converting color  com‐
       ponents  from  pixel  formats with less than 8-bits per RGB component (e.g., a
       completely white pixel in 16-bit RGB565 format would return [0xff, 0xff, 0xff]
       not [0xf8, 0xfc, 0xf8]).

RELATED FUNCTIONS
       SDL_GetRGBA
       SDL_MapRGB
       SDL_MapRGBA

===============================================================================
                                                                  *SDL_GetRGBA*


NAME
       SDL_GetRGBA -- Function

SYNOPSIS
       Use this function to get RGBA values from a pixel in the specified format.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_GetRGBA(Uint32                   pixel,   │
       │                  const SDL_PixelFormat*   format,  │
       │                  Uint8*                   r,       │
       │                  Uint8*                   g,       │
       │                  Uint8*                   b,       │
       │                  Uint8*                   a)       │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ pixel   │ a pixel value                │
       ├─────────┼──────────────────────────────┤
       │ format  │ an SDL_PixelFormat structure │
       │         │ describing the format of the │
       │         │ pixel                        │
       ├─────────┼──────────────────────────────┤
       │ r       │ a  pointer filled in with th │
       │         │ red component                │
       ├─────────┼──────────────────────────────┤
       │ g       │ a pointer filled in with the │
       │         │ green component              │
       ├─────────┼──────────────────────────────┤
       │ b       │ a pointer filled in with the │
       │         │ blue component               │
       ├─────────┼──────────────────────────────┤
       │ a       │ a pointer filled in with the │
       │         │ alpha component              │
       └─────────┴──────────────────────────────┘

REMARKS
       This function uses the entire 8-bit [0.255] range when converting color compo‐
       nents from pixel formats with lessthan 8-bits per RGB component (e.g., a  com‐
       pletely  white  pixel  in 16-bit RGB565 format would return [0xff, 0xff, 0xff]
       not [0xf8, 0xfc, 0xf8]).

       If the surface has no alpha component, the alpha  will  be  returned  as  0xff
       (100% opaque).

RELATED FUNCTIONS
       SDL_GetRGB
       SDL_MapRGB
       SDL_MapRGBA

===============================================================================
                                                     *SDL_GetRelativeMouseMode*


NAME
       SDL_GetRelativeMouseMode -- Function

SYNOPSIS
       Use this function to query whether relative mouse mode is enabled.

SYNTAX
       ┌──────────────────────────────────────────┐
       │ SDL_bool SDL_GetRelativeMouseMode(void)  │
       └──────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_SetRelativeMouseMode

===============================================================================
                                                    *SDL_GetRelativeMouseState*


NAME
       SDL_GetRelativeMouseState -- Function

SYNOPSIS
       Use this function to retrieve the relative state of the mouse.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ Uint32 SDL_GetRelativeMouseState(int*   x,  │
       │                                  int*   y)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ x  │ a  pointer  filled  with the │
       │    │ last recorded  x  coordinate │
       │    │ of the mouse                 │
       ├────┼──────────────────────────────┤
       │ y  │ a  poitner  filled  with the │
       │    │ last recorded  y  coordinate │
       │    │ of the mouse                 │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns a 32-bit button bitmask of the relative button state.

REMARKS
       The  current button state is returned as a button bitmask, which can be tested
       using the SDL_BUTTON(X) macros (where X is generally 1 for  the  left,  2  for
       middle, 3 for the right button), and x and y are set to the mouse deltas since
       the last call to SDL_GetRelativeMouseState() or  since  event  initialization.
       You can pass NULL for either x or y.

RELATED FUNCTIONS
       SDL_GetMouseState

===============================================================================
                                                   *SDL_GetRenderDrawBlendMode*


NAME
       SDL_GetRenderDrawBlendMode -- Function

SYNOPSIS
       Use this function to get the blend mode used for drawing operations.

SYNTAX
       ┌─────────────────────────────────────────────────────────────┐
       │ int SDL_GetRenderDrawBlendMode(SDL_Renderer*    renderer,   │
       │                                SDL_BlendMode*   blendMode)  │
       └─────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ renderer   │ the rendering context        │
       ├────────────┼──────────────────────────────┤
       │ blendMode  │ a pointer filled in with the │
       │            │ current  SDL_BlendMode;  see │
       │            │ Remarks for details          │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       blendMode will be filled in with one of the following:

       ┌──────────────────────┬──────────────────────────────┐
       │ SDL_BLENDMODE_NONE   │ no blending                  │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGBA = srcRGBA            │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE_BLEND  │ alpha blending               │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB = (srcRGB *  srcA)  + │
       │                      │ (dstRGB * (1 - srcA))        │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstA  =  srcA + (dstA * (1 - │
       │                      │ srcA))                       │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE_ADD    │ additive blending            │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB = (srcRGB *  srcA)  + │
       │                      │ dstRGB dstA = dstA           │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE_MOD    │ color modulate               │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB  =  srcRGB  *  dstRGB │
       │                      │ dstA = dstA                  │
       └──────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_SetRenderDrawBlendMode

===============================================================================
                                                       *SDL_GetRenderDrawColor*


NAME
       SDL_GetRenderDrawColor -- Function

SYNOPSIS
       Use this function to get the color used for drawing operations (Rect, Line and
       Clear).

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_GetRenderDrawColor(SDL_Renderer*    renderer,  │
       │                            Uint8*           r,         │
       │                            Uint8*           g,         │
       │                            Uint8*           b,         │
       │                            Uint8*           a)         │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ r         │ a pointer filled in with the │
       │           │ red  value  used  to draw on │
       │           │ the rendering target         │
       ├───────────┼──────────────────────────────┤
       │ g         │ a pointer filled in with the │
       │           │ green  value used to draw on │
       │           │ the rendering target         │
       ├───────────┼──────────────────────────────┤
       │ b         │ a pointer filled in with the │
       │           │ blue  value  used to draw on │
       │           │ the rendering target         │
       ├───────────┼──────────────────────────────┤
       │ a         │ a pointer filled in with the │
       │           │ alpha  value used to draw on │
       │           │ the rendering  target;  usu‐ │
       │           │ ally SDL_ALPHA_OPAQUE (255)  │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on succcess or a negative error code on failure; call SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_SetRenderDrawColor

===============================================================================
                                                      *SDL_GetRenderDriverInfo*


NAME
       SDL_GetRenderDriverInfo -- Function

SYNOPSIS
       Use  this function to get information about a specific 2D rendering driver for
       the current display.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ int SDL_GetRenderDriverInfo(int                 index,  │
       │                             SDL_RendererInfo*   info)   │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ index  │ the index of the  driver  to │
       │        │ query information about      │
       ├────────┼──────────────────────────────┤
       │ info   │ an  SDL_RendererInfo  struc‐ │
       │        │ ture to be filled  with  in‐ │
       │        │ formation  on  the rendering │
       │        │ driver                       │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_CreateRenderer
       SDL_GetNumRenderDrivers

===============================================================================
                                                          *SDL_GetRenderTarget*


NAME
       SDL_GetRenderTarget -- Function

SYNOPSIS
       Use this function to get the current render target.

SYNTAX
       ┌───────────────────────────────────────────────────────────┐
       │ SDL_Texture* SDL_GetRenderTarget(SDL_Renderer* renderer)  │
       └───────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬───────────────────────┐
       │ renderer  │ the rendering context │
       └───────────┴───────────────────────┘

RETURN VALUE
       Returns the current rendertarget or NULL for the default render target.

REMARKS
       The default render target is the window for which the renderer was created.

RELATED FUNCTIONS
       SDL_SetRenderTarget

===============================================================================
                                                              *SDL_GetRenderer*


NAME
       SDL_GetRenderer -- Function

SYNOPSIS
       Use this function to get the renderer associated with a window.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ SDL_Renderer* SDL_GetRenderer(SDL_Window* window)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns  the  rendering context on success or NULL on failure; call SDL_GetEr‐
       ror() for more information.

RELATED FUNCTIONS
       SDL_CreateRenderer

===============================================================================
                                                          *SDL_GetRendererInfo*


NAME
       SDL_GetRendererInfo -- Function

SYNOPSIS
       Use this function to get information about a rendering context.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_GetRendererInfo(SDL_Renderer*       renderer,  │
       │                         SDL_RendererInfo*   info)      │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ info      │ an  SDL_RendererInfo  struc‐ │
       │           │ ture filled with information │
       │           │ about the current renderer   │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       fore more information.

RELATED FUNCTIONS
       SDL_CreateRenderer

===============================================================================
                                                    *SDL_GetRendererOutputSize*


NAME
       SDL_GetRendererOutputSize -- Function

SYNOPSIS
       Use this function to get the output size in pixels of a rendering context.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ int SDL_GetRendererOutputSize(SDL_Renderer*   renderer,  │
       │                               int*            w,         │
       │                               int*            h)         │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ x         │ an int filled with the width │
       ├───────────┼──────────────────────────────┤
       │ h         │ an   int   filled  with  the │
       │           │ height                       │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_GetRenderer

===============================================================================
                                                              *SDL_GetRevision*


NAME
       SDL_GetRevision -- Function

SYNOPSIS
       Use  this function to get the code revision of SDL that is linked against your
       program.

SYNTAX
       ┌────────────────────────────────────┐
       │ const char* SDL_GetRevision(void)  │
       └────────────────────────────────────┘

RETURN VALUE
       Returns an arbitrary string, uniquely identifying the exact  revision  of  the
       SDL library in use.

REMARKS
       The  revision  is a string including sequential revision number that is incre‐
       mented with each commit, and a hash of the last code change.

       Example:hg-5344:94189aa89b54

       This value is the revision of the code you are linked with and may be  differ‐
       ent  from  the  code  you  are  compiling with, which is found in the constant
       SDL_REVISION.

RELATED FUNCTIONS
       SDL_GetVersion

===============================================================================
                                                        *SDL_GetRevisionNumber*


NAME
       SDL_GetRevisionNumber -- Function

SYNOPSIS
       Use  this  function  to  get the revision number of SDL that is linked against
       your program.

SYNTAX
       ┌──────────────────────────────────┐
       │ int SDL_GetRevisionNumber(void)  │
       └──────────────────────────────────┘

RETURN VALUE
       Returns a number uniquely identifying the exact revision of the SDL library in
       use.

REMARKS
       This is an incrementing number based on commits to hg.libsdl.org.

RELATED FUNCTIONS
       SDL_GetRevision

===============================================================================
                                                       *SDL_GetScancodeFromKey*


NAME
       SDL_GetScancodeFromKey -- Function

SYNOPSIS
       Use  this function to get the scancode corresponding to the given key code ac‐
       cording to the current keyboard layout.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ SDL_Cancode SDL_GetScancodeFromKey(SDL_Keycode key)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ key  │ the desired  SDL_Keycode  to │
       │      │ query                        │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns the SDL_Scancode that corresponding to the given SDL_Keycode.

REMARKS
       See SDL_Scancode for details.

RELATED FUNCTIONS
       SDL_GetKeyFromScancode
       SDL_GetScancodeName

===============================================================================
                                                      *SDL_GetScancodeFromName*


NAME
       SDL_GetScancodeFromName -- Function

SYNOPSIS
       Use this function to get a scancode from a human-readable name.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ SDL_Scancode SDL_GetScancodeFromName(const char* name)  │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ name  │ the  human-readable scancode │
       │       │ name                         │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns the SDL_Scancode, or SDL_SCANCODE_UNKNOWN if the  name  wasn't  recog‐
       nized; call SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetKeyFromName
       SDL_GetScancodeFromKey
       SDL_GetScancodeName

===============================================================================
                                                          *SDL_GetScancodeName*


NAME
       SDL_GetScancodeName -- Function

SYNOPSIS
       Use this function to get a human-readable name for a scancode.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ const char* SDL_GetScancodeName(SDL_Scancode scancode)  │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ scancode  │ the  desired SDL_Scancode to │
       │           │ query                        │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to the name for the scancode. If the scancode doesn't have a
       name, this function returns an empty string ("").

REMARKS
       See SDL_Scancode for details.

       Warning:  The returned name is by design not stable across platforms, e.g. the
       name for SDL_SCANCODE_LGUI is "Left GUI" under Linux but "Left Windows"  under
       Windows,  and  some  scancode  like SDL_SCANCODE_NONUSBACKSLASH don't have any
       name at all. There are even scancodes that share names, e.g.  SDL_SCANCODE_RE‐
       TURN  and SDL_SCANCODE_RETURN2 (both called "Return"). This function is there‐
       fore unsuitable for creating a stable cross-platform two-way  mapping  between
       strings and scancodes.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetScancodeFromKey
       SDL_GetScancodeFromName

===============================================================================
                                                       *SDL_GetSurfaceAlphaMod*


NAME
       SDL_GetSurfaceAlphaMod -- Function

SYNOPSIS
       Use this function to get the additional alpha value used in blit operations.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_GetSurfaceAlphaMod(SDL_Surface*   surface,  │
       │                            Uint8*         alpha)    │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ query                        │
       ├──────────┼──────────────────────────────┤
       │ alha     │ a pointer filled in with the │
       │          │ current alpha value          │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_GetSurfaceColorMod
       SDL_SetSurfaceAlphaMod

===============================================================================
                                                      *SDL_GetSurfaceBlendMode*


NAME
       SDL_GetSurfaceBlendMode -- Function

SYNOPSIS
       Use this function to get the blend mode used for blit operations.

SYNTAX
       ┌───────────────────────────────────────────────────────────┐
       │ int SDL_GetSurfaceBlendMode(SDL_Surface*      surface,    │
       │                             SDL_BlendMode*    blendMode)  │
       └───────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ surface    │ the SDL_Surface structure to │
       │            │ query                        │
       ├────────────┼──────────────────────────────┤
       │ blendMode  │ a pointer filled in with the │
       │            │ current  SDL_BlendMode;  see │
       │            │ Remarks for details          │
       └────────────┴──────────────────────────────┘

REMARKS
       blendMode will be filled in with one of the following:

       ┌──────────────────────┬──────────────────────────────────────────────────┐
       │ SDL_BLENDMODE_NONE   │ no blending                                      │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGBA = srcRGBA                                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_BLEND  │ alhpa blending                                   │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = (srcRGB * srcA) + (dstRGB * (1 - srcA)) │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = srcA + (dstA * (1 - srcA))                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_ADD    │ additive blending                                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = (srcRGB * srcA) + dstRGB                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = dstA                                      │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_MOD    │ color modulate                                   │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = srcRGB * dstRGB                         │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = dstA                                      │
       └──────────────────────┴──────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_SetSurfaceBlendMode

===============================================================================
                                                       *SDL_GetSurfaceColorMod*


NAME
       SDL_GetSurfaceColorMod -- Function

SYNOPSIS
       Use this function to get the additional color value multiplied into blit oper‐
       ations.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_GetSurfaceColorMod(SDL_Surface*   surface,  │
       │                            Uint8*         r,        │
       │                            Uint8*         g,        │
       │                            Uint8*         b)        │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ query                        │
       ├──────────┼──────────────────────────────┤
       │ r        │ a pointer filled in with the │
       │          │ current red color value      │
       ├──────────┼──────────────────────────────┤
       │ g        │ a pointer filled in with the │
       │          │ current green color value    │
       ├──────────┼──────────────────────────────┤
       │ b        │ a pointer filled in with the │
       │          │ current blue color value     │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_GetSurfaceAlphaMod
       SDL_SetSurfaceColorMod

===============================================================================
                                                             *SDL_GetSystemRAM*


NAME
       SDL_GetSystemRAM -- Function

SYNOPSIS
       Use this function ...

SYNTAX
       ┌─────────────────────────────┐
       │ int SDL_GetSystemRAM(void)  │
       └─────────────────────────────┘

RETURN VALUE
       Returns the amount of RAM configured in the system in MB.

VERSION
       This function is available since SDL 2.0.1.

===============================================================================
                                                       *SDL_GetTextureAlphaMod*


NAME
       SDL_GetTextureAlphaMod -- Function

SYNOPSIS
       Use  this  function  to  get the additional alpha value multiplied into render
       copy operations.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_GetTextureAlphaMod(SDL_Texture*   texture,  │
       │                            Uint8*         alpha)    │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to query         │
       ├──────────┼──────────────────────────────┤
       │ alpha    │ a pointer filled in with the │
       │          │ current alpha value          │
       └──────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetTextureColorMod
       SDL_SetTextureAlphaMod

===============================================================================
                                                      *SDL_GetTextureBlendMode*


NAME
       SDL_GetTextureBlendMode -- Function

SYNOPSIS
       Use this function to get the blend mode used for texture copy operations.

SYNTAX
       ┌───────────────────────────────────────────────────────────┐
       │ int SDL_GetTextureBlendMode(SDL_Texture*      texture,    │
       │                             SDL_BlendMode*    blendMode)  │
       └───────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ texture    │ the texture to query         │
       ├────────────┼──────────────────────────────┤
       │ blendMode  │ a pointer filled in with the │
       │            │ current  SDL_BlendMode;  see │
       │            │ Remarks for details          │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       blendMode will be filled in with one of the following:

       ┌──────────────────────┬──────────────────────────────────────────────────┐
       │ SDL_BLENDMODE_NONE   │ no blending                                      │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGBA = srcRGBA                                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_BLEND  │ alhpa blending                                   │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = (srcRGB * srcA) + (dstRGB * (1 - srcA)) │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = srcA + (dstA * (1 - srcA))                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_ADD    │ additive blending                                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = (srcRGB * srcA) + dstRGB                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = dstA                                      │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_MOD    │ color modulate                                   │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = srcRGB * dstRGB                         │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = dstA                                      │
       └──────────────────────┴──────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_SetTextureBlendMode

===============================================================================
                                                       *SDL_GetTextureColorMod*


NAME
       SDL_GetTextureColorMod -- Function

SYNOPSIS
       Use  this  function  to  get the additional color value multiplied into render
       copy operations.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_GetTextureColorMod(SDL_Texture*   texture,  │
       │                            Uint8*         r,        │
       │                            Uint8*         g,        │
       │                            Uint8*         b)        │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to query         │
       ├──────────┼──────────────────────────────┤
       │ r        │ a pointer filled in with the │
       │          │ current red color value      │
       ├──────────┼──────────────────────────────┤
       │ g        │ a pointer filled in with the │
       │          │ current green color value    │
       ├──────────┼──────────────────────────────┤
       │ b        │ a pointer filled in with the │
       │          │ current blue color value     │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0  on  success  or  a negative error code on failure; call SDL_GetEr‐
       ror()ffor more information.

RELATED FUNCTIONS
       SDL_GetTextureAlphaMod
       SDL_SetTextureColorMod

===============================================================================
                                                              *SDL_GetThreadID*


NAME
       SDL_GetThreadID -- Function

SYNOPSIS
       Use this function to get the thread identifier for the specified thread.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ SDL_threadID SDL_GetThreadID(SDL_Thread*    thread)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ thread  │ the thread to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns  the  ID  of  the specified thread, or the ID of the current thread if
       thread is NULL.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────┐
       │ #include <stdio.h>                                                      │
       │ #include "SDL.h"                                                        │
       │                                                                         │
       │ // Very simple thread - counts 0 to 9 delaying 50ms between increments  │
       │ int TestThread(void* ptr)                                               │
       │ {                                                                       │
       │   int cnt;                                                              │
       │   for (cnt = 0; cnt < 10; ++cnt)                                        │
       │   {                                                                     │
       │     printf("\nThread counter: %d", cnt);                                │
       │     SDL_Delay(50);                                                      │
       │   }                                                                     │
       │                                                                         │
       │   return cnt;                                                           │
       │ }                                                                       │
       │                                                                         │
       │ int main(int argc, char* argv[])                                        │
       │ {                                                                       │
       │   SDL_Thread    *thread;                                                │
       │   SDL_threadID  threadID;                                               │
       │   int           threadReturnValue;                                      │
       │                                                                         │
       │   printf("10imple SDL_CreateThread test:");                             │
       │                                                                         │
       │   /* Simply create a thread */                                          │
       │   thread = SDL_CreateThread(TestThread, "TestThread", (void*)NULL);     │
       │                                                                         │
       │   if (thread == NULL)                                                   │
       │   {                                                                     │
       │     printf("\nSDL_CreateThread failed: %s\n", SDL_GetError());          │
       │     exit(-1);                                                           │
       │   }                                                                     │
       │                                                                         │
       │   /* Retrieve the ID for the newly launched thread */                   │
       │   threadID = SDL_GetThreadID(thread);                                   │
       │                                                                         │
       │   /* Wait for the thread to complete and get the return code */         │
       │   SDL_WaitThread(thread, &threadReturnValue);                           │
       │   printf("\nThread returned value: %d", threadReturnValue);             │
       │                                                                         │
       │   return 0;                                                             │
       │ }                                                                       │
       └─────────────────────────────────────────────────────────────────────────┘

REMARKS
       This thread identifier is as reported by the underying  operating  system.  If
       SDL  is  running on a platform that does not support threads, the return value
       will always be zero.

RELATED FUNCTIONS
       SDL_ThreadID

===============================================================================
                                                            *SDL_GetThreadName*


NAME
       SDL_GetThreadName -- Function

SYNOPSIS
       Use  this  function  to  get  the  thread name as it was specified in SDL_Cre‐
       ateThread().

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ const char* SDL_GetThreadName(SDL_Thread*   thread)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ thread  │ the thread to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns a pointer to a UTF-8 string that names the specified thread,  or  NULL
       if it doesn't have a name.

REMARKS
       This  is internal memory, not to be freed by the caller, and remains valid un‐
       til the specified thread is cleaned up by SDL_WaitThread().

RELATED FUNCTIONS
       SDL_CreateThread

===============================================================================
                                                                 *SDL_GetTicks*


NAME
       SDL_GetTicks -- Function

SYNOPSIS
       Use this function to get the number of milliseconds since the SDL library ini‐
       tialization.

SYNTAX
       ┌────────────────────────────┐
       │ Uint32 SDL_GetTicks(void)  │
       └────────────────────────────┘

RETURN VALUE
       Returns an unsigned 32-bit value representing the number of milliseconds since
       the SDL library initialized.

CODE EXAMPLES
       ┌──────────────────────────────────────────┐
       │ unsigned int lastTime = 0, currentTime;  │
       │ while (!quit)                            │
       │ {                                        │
       │   // do stuff                            │
       │   // ...                                 │
       │                                          │
       │   // Print a report once per second      │
       │   currentTime = SDL_GetTicks();          │
       │   if (currentTime > lastTime + 1000)     │
       │   {                                      │
       │     printf("Report: %d\n", variable);    │
       │     lastTime = currentTime;              │
       │   }                                      │
       │ }                                        │
       └──────────────────────────────────────────┘

REMARKS
       This value wraps if the program runs for more than ~49 days.

RELATED FUNCTIONS
       SDL_TICKS_PASSED

===============================================================================
                                                           *SDL_GetTouchDevice*


NAME
       SDL_GetTouchDevice -- Function

SYNOPSIS
       Use this function to get the touch ID with the given index.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ SDL_TouchID SDL_GetTouchDevice(int index)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬────────────────────────┐
       │ index  │ the touch device index │
       └────────┴────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetNumTouchDevices

===============================================================================
                                                           *SDL_GetTouchFinger*


NAME
       SDL_GetTouchFinger -- Function

SYNOPSIS
       Use  this  function to get the finger object for specified touch device ID and
       finger index.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ SDL_Finger* SDL_GetTouchFinger(SDL_TouchID    touchID,  │
       │                                int            index)    │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ touchID  │ the  ID  of  the   requested │
       │          │ touch device                 │
       ├──────────┼──────────────────────────────┤
       │ index    │ the  index  of the requested │
       │          │ finger                       │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to the SDL_Finger object or NULL if no object at  the  given
       ID and index could be found.

REMARKS
       The returned resource is owned by SDL and should not be deallocated.

RELATED FUNCTIONS
       SDL_RecordGesture

===============================================================================
                                                               *SDL_GetVersion*


NAME
       SDL_GetVersion -- Function

SYNOPSIS
       Use  this  function to get the version of SDL that is linked against your pro‐
       gram.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ void SDL_GetVersion(SDL_version*    ver)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ ver  │ the  SDL_version   structure │
       │      │ that  contains  the  version │
       │      │ information                  │
       └──────┴──────────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_version compiled;                                                                                      │
       │ SDL_version linked;                                                                                        │
       │                                                                                                            │
       │ SDL_VERSION(&compiled);                                                                                    │
       │ SDL_GetVersion(&linked);                                                                                   │
       │ printf("We compiled against SDL version %d.%d.%d ...\n", compiled.major, compiled.minor, compiled.patch);  │
       │ printf("But we are linking against SDL version %d.%d.%d.\n", linked.major, linked.minor, linked.patch);    │
       └────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       If you are linking to SDL dynamically, then it is possible  that  the  current
       version will be different than the version you compiled against. This function
       returns the current version, while SDL_VERSION() is a  macro  that  tells  you
       what version you compiled with.

       This function may be called safely at any time, even before SDL_Init().

RELATED MACROS
       SDL_VERSION

RELATED FUNCTIONS
       SDL_GetRevision

===============================================================================
                                                           *SDL_GetVideoDriver*


NAME
       SDL_GetVideoDriver -- Function

SYNOPSIS
       Use this function to get the name of a built-in video driver.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ const char* SDL_GetVideoDriver(int index)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬─────────────────────────────┐
       │ index  │ the index of a video driver │
       └────────┴─────────────────────────────┘

RETURN VALUE
       Returns the name of the video driver with the given index.

REMARKS
       The  video  drivers  are  presented  in  the  order in which they are normally
       checked during initialization.

RELATED FUNCTIONS
       SDL_GetNumVideoDrivers

===============================================================================
                                                             *SDL_GetVideoInfo*


NAME
       SDL_GetVideoInfo - returns a pointer to information about the video hardware

SYNOPSIS
       #include "SDL.h"

       SDL_VideoInfo *SDL_GetVideoInfo(void);

DESCRIPTION
       This function returns a read-only pointer to information about the video hard‐
       ware. If this is called before SDL_SetVideoMode, the vfmt member  of  the  re‐
       turned structure will contain the pixel format of the "best" video mode.

SEE ALSO
       SDL_SetVideoMode, SDL_VideoInfo

===============================================================================
                                                          *SDL_GetVideoSurface*


NAME
       SDL_GetVideoSurface - returns a pointer to the current display surface

SYNOPSIS
       #include "SDL.h"

       SDL_Surface *SDL_GetVideoSurface(void);

DESCRIPTION
       This  function returns a pointer to the current display surface. If SDL is do‐
       ing format conversion on the display surface, this function returns  the  pub‐
       licly visible surface, not the real video surface.

SEE ALSO
       SDL_Surface

===============================================================================
                                                     *SDL_GetWindowBordersSize*


NAME
       SDL_GetWindowBordersSize -- Function

SYNOPSIS
       Use  this  function to get the size of a window's borders (decorations) around
       the client area.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_GetWindowBordersSize(SDL_Window*    window,  │
       │                              int*           top,     │
       │                              int*           left,    │
       │                              int*           bottom,  │
       │                              int*           right)   │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to query the size │
       │         │ values  of the border (deco‐ │
       │         │ rations) from                │
       ├─────────┼──────────────────────────────┤
       │ top     │ pointer  to   variable   for │
       │         │ storing  the size of the top │
       │         │ border; NULL is permitted    │
       ├─────────┼──────────────────────────────┤
       │ left    │ pointer  to   variable   for │
       │         │ storing the size of the left │
       │         │ border; NULL is permitted    │
       ├─────────┼──────────────────────────────┤
       │ bottom  │ pointer  to   variable   for │
       │         │ storing the size of the bot‐ │
       │         │ tom border; NULL is  permit‐ │
       │         │ ted                          │
       ├─────────┼──────────────────────────────┤
       │ right   │ pointer   to   variable  for │
       │         │ storing  the  size  of   the │
       │         │ right  border;  NULL is per‐ │
       │         │ mitted                       │
       └─────────┴──────────────────────────────┘

REMARKS
       Note: If this function fails (returns -1), the size values will be initialized
       to  0,  0, 0, 0 (if a non-NULL pointer is provided), as if the window in ques‐
       tion was borderless.

       This function also returns -1 if getting the information is not supported.

       This function is only supported on X11.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_GetWindowSize

===============================================================================
                                                      *SDL_GetWindowBrightness*


NAME
       SDL_GetWindowBrightness -- Function

SYNOPSIS
       Use this function to get the brightness (gamma mutiplier) for the display that
       owns a given window.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ float SDL_GetWindowBrightness(SDL_Window*   window)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window  used  to  select │
       │         │ the display whose brightness │
       │         │ will be queries              │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns the brightness for the display where 0.0 is completely dark and 1.0 is
       normal brightness.

REMARKS
       Despite  the  name  and signature, this method retrieves the brightness of the
       entire display, not an individual window. A window is considered to  be  owned
       by  the  display  that  contains the window's center pixel. (The index of this
       display can be retrieved using SDL_GetWindowDisplayIndex().)

RELATED FUNCTIONS
       SDL_SetWindowBrightness

===============================================================================
                                                            *SDL_GetWindowData*


NAME
       SDL_GetWindowData -- Function

SYNOPSIS
       Use this function to retrieve the data pointer associated with a window.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void* SDL_GetWindowData(SDL_Window*   window,  │
       │                         const char*   name)    │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────────┐
       │ window  │ the window to query     │
       ├─────────┼─────────────────────────┤
       │ name    │ the name of the pointer │
       └─────────┴─────────────────────────┘

RETURN VALUE
       Returns the value associated with name.

RELATED FUNCTIONS
       SDL_SetWindowData

===============================================================================
                                                    *SDL_GetWindowDisplayIndex*


NAME
       SDL_GetWindowDisplayIndex -- Function

SYNOPSIS
       Use this function to get the index of the display associated with a window.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_GetWindowDisplayIndex(SDL_Window*   window)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns  the  index of the display containing the center of the window on suc‐
       cess or a negative error code on failure; call SDL_GetError() for more  infor‐
       mation.

RELATED FUNCTIONS
       SDL_GetDisplayBounds
       SDL_GetNumVideoDisplays

===============================================================================
                                                     *SDL_GetWindowDisplayMode*


NAME
       SDL_GetWindowDisplayMode -- Function

SYNOPSIS
       Use  this function to fill in information about the display mode to use when a
       window is visible at fullscreen.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ int SDL_GetWindowDisplayMode(SDL_Window*        window,  │
       │                              SDL_DisplayMode    mode)    │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to query          │
       ├─────────┼──────────────────────────────┤
       │ mode    │ an SDL_DisplayMode structure │
       │         │ filled     in    with    the │
       │         │ fullscreen display mode      │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_SetWindowDisplayMode
       SDL_SetWindowFullscreen

===============================================================================
                                                           *SDL_GetWindowFlags*


NAME
       SDL_GetWindowFlags -- Function

SYNOPSIS
       Use this function to get the window flags.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ Uint32 SDL_GetWindowFlags(SDL_Window*   window)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns  a mask of the SDL_WindowFlags associated with window; see Remarks for
       details.

REMARKS
       The flags may be any of the following OR'd together:

       ┌────────────────────────────────┬──────────────────────────────┐
       │ SDL_WINDOW_FULLSCREEN          │ fullscreen window            │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_FULLSCREEN_DESKTOP  │ fullscreen  window  at   the │
       │                                │ current desktop resolution   │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_OPENGL              │ window  usable  with  OpenGL │
       │                                │ context                      │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_SHOWN               │ window is visible            │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_HIDDEN              │ window is not visible        │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_BORDERLESS          │ no window decoration         │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_RESIZABLE           │ window can be resized        │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MINIMIZED           │ window is minimized          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MAXIMIZED           │ window is maximized          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_INPUT_GRABBED       │ window has grabbed input fo‐ │
       │                                │ cus                          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_INPUT_FOCUS         │ window has input focus       │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MOUSE_FOCUS         │ window has mouse focus       │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_FOREIGN             │ window not created by SDL    │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_ALLOW_HIGHDPI       │ window  should be created in │
       │                                │ high-DPI mode  if  supported │
       │                                │ (>= SDL 2.0.1)               │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MOUSE_CAPTURE       │ window  has  mouse  captured │
       │                                │ (unrelated to INPUT_GRABBED, │
       │                                │ >= SDL 2.0.4)                │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_ALWAYS_ON_TOP       │ window   should   always  be │
       │                                │ above others (X11  only,  >= │
       │                                │ SDL 2.0.5)                   │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_SKIP_TASKBAR        │ window  should  not be added │
       │                                │ to the taskbar (X11 only, >= │
       │                                │ SLD 2.0.5)                   │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_UTILITY             │ window  should be treated as │
       │                                │ a utility window (X11  only, │
       │                                │ >= SDL 2.0.5)                │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_TOOLTIP             │ window  should be treated as │
       │                                │ a tooltip (X11 only, >=  SDL │
       │                                │ 2.0.5)                       │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_POPUP_MENU          │ window  should be treated as │
       │                                │ a popup menu (X11  only,  >= │
       │                                │ SDL 2.0.5)                   │
       └────────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_CreateWindow
       SDL_HideWindow
       SDL_MaximizeWindow
       SDL_MinimizeWindow
       SDL_SetWindowFullScreen
       SDL_SetWindowGrab
       SDL_ShowWindow

===============================================================================
                                                          *SDL_GetWindowFromID*


NAME
       SDL_GetWindowFromID -- Function

SYNOPSIS
       Use this function to get the numeric ID of a window, for logging purposes.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ Uint32 SDL_GetWindowFromID(SDL_Window*    window)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns  the  ID of the window on success or 0 on failure; call SDL_GetError()
       for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetWindowFromID

===============================================================================
                                                       *SDL_GetWindowGammaRamp*


NAME
       SDL_GetWindowGammaRamp -- Function

SYNOPSIS
       Use this function to get the gamma ramp for the display that owns a given win‐
       dow.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_GetWindowGammaRamp(SDL_Window*    window,  │
       │                            Uint16*        red,     │
       │                            Uint16*        green,   │
       │                            Uint16*        blue)    │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window  used  to  select │
       │         │ the display whose gamma ramp │
       │         │ will be queried              │
       ├─────────┼──────────────────────────────┤
       │ red     │ a  256  element   array   of │
       │         │ 16-bit  quantities filled in │
       │         │ with translation  table  for │
       │         │ the red channel, or NULL     │
       ├─────────┼──────────────────────────────┤
       │ green   │ a   256   element  array  of │
       │         │ 16-bit quantities filled  in │
       │         │ with  the  translation table │
       │         │ for the  green  channel,  or │
       │         │ NULL                         │
       ├─────────┼──────────────────────────────┤
       │ blue    │ a   256   element  array  of │
       │         │ 16-bit quantities filled  in │
       │         │ with  the  translation table │
       │         │ for  the  blue  channel,  or │
       │         │ NULL                         │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Despite the name and signature, this method retrieves the gamma  ramp  of  the
       entire  display,  not an individual window. A window is considered to be owned
       by the display that contains the window's center pixel.  (The  index  of  this
       display can be retrieved using SDL_GetWindowDisplayIndex().)

RELATED FUNCTIONS
       SDL_SetWindowGammaRamp

===============================================================================
                                                            *SDL_GetWindowGrab*


NAME
       SDL_GetWindowGrab -- Function

SYNOPSIS
       Use this function to get a window's input grab mode.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ SDL_bool SDL_GetWindowGrab(SDL_Window*    window)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.

RELATED FUNCTIONS
       SDL_SetWindowGrab

===============================================================================
                                                              *SDL_GetWindowID*


NAME
       SDL_GetWindowID -- Function

SYNOPSIS
       Use this function to get the numeric ID of a window, for logging purposes.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ Uint32 SDL_GetWindowID(SDL_Window*    window)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns  the  ID of the window on success or 0 on failure; call SDL_GetError()
       for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetWindowFromID

===============================================================================
                                                     *SDL_GetWindowMaximumSize*


NAME
       SDL_GetWindowMaximumSize -- Function

SYNOPSIS
       Use this function to get the maximum size of a window's client area.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ void SDL_GetWindowMaximumSize(SDL_Window*   window,  │
       │                               int*          w,       │
       │                               int*          h)       │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to query          │
       ├─────────┼──────────────────────────────┤
       │ w       │ a pointer filled in with the │
       │         │ maximum width of the window, │
       │         │ may be NULL                  │
       ├─────────┼──────────────────────────────┤
       │ h       │ a pointer filled in with the │
       │         │ maximum height of  the  win‐ │
       │         │ dow, may be NULL             │
       └─────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetWindowMinimumSize
       SDL_SetWindowMaximumSize

===============================================================================
                                                     *SDL_GetWindowMinimumSize*


NAME
       SDL_GetWindowMinimumSize -- Function

SYNOPSIS
       Use this function to get the minimum size of a window's client area.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ void SDL_GetWindowMinimumSize(SDL_Window*   window,  │
       │                               int*          w,       │
       │                               int*          h)       │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to query          │
       ├─────────┼──────────────────────────────┤
       │ w       │ a pointer filled in with the │
       │         │ minimum width of the window, │
       │         │ may be NULL                  │
       ├─────────┼──────────────────────────────┤
       │ h       │ a pointer filled in with the │
       │         │ minimum height of  the  win‐ │
       │         │ dow, may be NULL             │
       └─────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetWindowMaximumSize
       SDL_SetWindowMinimumSize

===============================================================================
                                                         *SDL_GetWindowOpacity*


NAME
       SDL_GetWindowOpacity -- Function

SYNOPSIS
       Use this function to get the opacity of a window.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ int SDL_GetWindowOpacity(SDL_Window*    window,   │
       │                          float*         opacity)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ window   │ the  window  to get the cur‐ │
       │          │ rent opacity value from      │
       ├──────────┼──────────────────────────────┤
       │ opacity  │ the float filled in (0.0f is │
       │          │ transparent, 1.0f is opaque) │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0  on  success or negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       If transparency isn't supported on this platform, opacity will be reported  as
       1.0f without error.

       The parameter opacity is ignored if it is NULL.

       This function also returns -1 if an invalid window was provided.

       This  function is only supported on DirectFB, X11, Cocoa (Apple macOS) and Mi‐
       crosoft Windows.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_SetWindowOpacity

===============================================================================
                                                     *SDL_GetWindowPixelFormat*


NAME
       SDL_GetWindowPixelFormat -- Function

SYNOPSIS
       Use this function to get the pixel format associated with the window.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ Uint32 SDL_GetWindowPixelFormat(SDL_Window*   window)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns  the  pixel format of the window on success or SDL_PIXELFORMAT_UNKNOWN
       on failure; call SDL_GetError() fore more information.

===============================================================================
                                                        *SDL_GetWindowPosition*


NAME
       SDL_GetWindowPosition -- Function

SYNOPSIS
       Use this function to get the position of a window.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_GetWindowPosition(SDL_Window*    window,  │
       │                            int*           x,       │
       │                            int*           y)       │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to query          │
       ├─────────┼──────────────────────────────┤
       │ x       │ a pointer filled in with the │
       │         │ x position of the window, in │
       │         │ screen  coordinates,  may be │
       │         │ NULL                         │
       ├─────────┼──────────────────────────────┤
       │ y       │ a pointer filled in with the │
       │         │ y position of the window, in │
       │         │ screen coordinates,  may  be │
       │         │ NULL                         │
       └─────────┴──────────────────────────────┘

REMARKS
       If  you do not need the value for one of the positions a NULL may be passed in
       the x or y parameter.

RELATED FUNCTIONS
       SDL_SetWindowPosition

===============================================================================
                                                            *SDL_GetWindowSize*


NAME
       SDL_GetWindowSize -- Function

SYNOPSIS
       Use this function to get the size of a window's client area.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_GetWindowSize(SDL_Window*    window,  │
       │                        int*           w,       │
       │                        int*           h)       │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the   window  to  query  the │
       │         │ width and height from        │
       ├─────────┼──────────────────────────────┤
       │ w       │ a pointer filled in with the │
       │         │ width   of  the  window,  in │
       │         │ screen coordinates,  may  be │
       │         │ NULL                         │
       ├─────────┼──────────────────────────────┤
       │ h       │ a  pointer filled in withthe │
       │         │ height  of  the  window,  in │
       │         │ screen  coordinates,  may be │
       │         │ NULL                         │
       └─────────┴──────────────────────────────┘

REMARKS
       NULL can safely be passed as the w or h parameter if the width or height value
       is not desired.

       The  window  size in screen coordinates may differ from the size in pixels, if
       the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with  high-
       dpi  support  (e.g.  iOS  or  macOS). Use SDL_GetDrawableSize() or SDL_GetRen‐
       dererOutputSize() to get the real client area size in pixels.

RELATED FUNCTIONS
       SDL_GL_GetDrawableSize
       SDL_SetWindowSize

===============================================================================
                                                         *SDL_GetWindowSurface*


NAME
       SDL_GetWindowSurface -- Function

SYNOPSIS
       Use this function to get the SDL surface associated with the window.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ SDL_Surface* SDL_GetWindowSurface(SDL_Window*   window)  │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns  the  surface  associated  with  the  window, or NULL on failure; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"    // include SDL header                                                                    │
       │                                                                                                              │
       │ int main(int argc, char* argv[])                                                                             │
       │ {                                                                                                            │
       │   SDL_Surface* screen;  // even with SDL2, we can still bring ancient code back                              │
       │   SDL_Window* window;                                                                                        │
       │   SDL_Surface* image;                                                                                        │
       │                                                                                                              │
       │   SDL_Init(SDL_INIT_VIDEO);   // init video                                                                  │
       │                                                                                                              │
       │   // create the window like normal                                                                           │
       │   window = SDL_CreateWindow("SDL2 Example", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 480, 0);  │
       │                                                                                                              │
       │   // but instead of creating a renderer, we can draw directly to the screen                                  │
       │   screen = SDL_GetWindowSurface(window);                                                                     │
       │                                                                                                              │
       │   // let's just show some classic code for reference                                                         │
       │   image = SDL_LoadBMP("box.bmp");   // loads image                                                           │
       │   SDL_BlitSurface(image, NULL, screen, NULL);   // blit it to the screen                                     │
       │   SDL_FreeSurface(image);                                                                                    │
       │                                                                                                              │
       │   // this works just like SDL_Flip() in SDL 1.2                                                              │
       │   SDL_UpdateWindowSurface(window);                                                                           │
       │                                                                                                              │
       │   // show image for 2 seconds                                                                                │
       │   SDL_Delay(2000);                                                                                           │
       │   SDL_DestroyWindow(window);                                                                                 │
       │   SDL_Quit();                                                                                                │
       │   return 0;                                                                                                  │
       │ }                                                                                                            │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       A new surface will be created with optimal format for the  window,  if  neces‐
       sary.  This  surface  will  be freed when the window is destroyed. Do not free
       this surface.

       This surface will be invalidated if the window is resized.  After  resizing  a
       window this function must be called again to return a valid surface.

       You may not combine this with 3D or the rendering API on this window.

       This function is affected by SDL_HINT_FRAMEBUFFER_ACCELERATION.

RELATED FUNCTIONS
       SDL_UpdateWindowSurface
       SDL_UpdateWindowSurfaceRects

===============================================================================
                                                           *SDL_GetWindowTitle*


NAME
       SDL_GetWindowTitle -- Function

SYNOPSIS
       Use this function to get the title of a window.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ const char* SDL_GetWindowTitle(SDL_Window*    window)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to query │
       └─────────┴─────────────────────┘

RETURN VALUE
       Returns the title of the window in UTF-8 format or "" if there is no title.

RELATED FUNCTIONS
       SDL_SetWindowTitle

===============================================================================
                                                          *SDL_GetWindowWMInfo*


NAME
       SDL_GetWindowWMInfo -- Function

SYNOPSIS
       Use this function to get driver specific information about a window.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_GetWindowWMInfo(SDL_Window*      window,  │
       │                              SDL_SysWMinfo*   info)    │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the  window  about which in‐ │
       │         │ formation is being requested │
       ├─────────┼──────────────────────────────┤
       │ info    │ an  SDL_SysWMinfo  structure │
       │         │ filled in with window infor‐ │
       │         │ mation; see Remarks for  de‐ │
       │         │ tails                        │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  SDL_TRUE if the function is implemented and the version member of the
       info struct is valid, or SDL_FALSE if the information could not be  retrieved;
       call SDL_GetError() fore more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                     │
       │ #include "SDL_syswm.h"                                                               │
       │                                                                                      │
       │ int main(int argc, char* argv[])                                                     │
       │ {                                                                                    │
       │   SDL_Window* window;                                                                │
       │   SDL_SysWMinfo info;                                                                │
       │                                                                                      │
       │   SDL_Init(0);                                                                       │
       │                                                                                      │
       │   window = SDL_CreateWindow("", 0, 0, 0, 0, SDL_WINDOW_HIDDEN);                      │
       │                                                                                      │
       │   SDL_VERSION(&info.version); /* initialize info structure with SDL version info */  │
       │                                                                                      │
       │   if (SDL_GetWindowWMInfo(window, &info)) /* the call returns true on succes */      │
       │   {                                                                                  │
       │     /* success */                                                                    │
       │     const char* subsystem = "an unknown system!";                                    │
       │     switch (info.subsystem)                                                          │
       │     {                                                                                │
       │       case SDL_SYSWM_UNKNOWN:                                         break;         │
       │       case SDL_SYSWM_WINDOWS:   subsystem = "Microsoft Windows(TM)";  break;         │
       │       case SDL_SYSWM_X11:       subsystem = "X Window System";        break;         │
       │ #if SDL_VERSION_ATLEAST(2, 0, 3)                                                     │
       │       case SDL_SYSWM_WINRT:     subsystem = "WinRT";                  break;         │
       │ #endif                                                                               │
       │       case SDL_SYSWM_DIRECTFB:  subsystem = "DirectFB";               break;         │
       │       case SDL_SYSWM_COCOA:     subsystem = "Apple macOS";            break;         │
       │       case SDL_SYSWM_UIKIT:     subsystem = "UIKit";                  break;         │
       │ #if SDL_VERSION_ATLEAST(2, 0, 2)                                                     │
       │       case SDL_SYSWM_WAYLAND:   subsystem = "Wayland";                break;         │
       │       case SDL_SYSWM_MIR:       subsystem = "Mir";                    break;         │
       │ #endif                                                                               │
       │ #if SDL_VERSION_ATLEAST(2, 0, 4)                                                     │
       │       case SDL_SYSWM_ANDROID:   subsystem = "Android";                break;         │
       │ #endif                                                                               │
       │ #if SDL_VERSION_ATLEAST(2, 0, 5)                                                     │
       │       case SDL_SYSWM_VIVANTE:   subsystem = "Vivante";                break;         │
       │ #endif                                                                               │
       │     }                                                                                │
       │                                                                                      │
       │     SDL_Log("This program is running SDL version %d.%d.%d on %s",                    │
       │             (int)info.version.major,                                                 │
       │             (int)info.version.minor,                                                 │
       │             (int)info.version.patch,                                                 │
       │             subsystem);                                                              │
       │   }                                                                                  │
       │   else                                                                               │
       │   {                                                                                  │
       │     /* call failed */                                                                │
       │     SDL_LogError(SDL_LOG_CATEGORY_ERROR, "Couldn't get window information: %s",      │
       │                  SDL_GetError());                                                    │
       │   }                                                                                  │
       │                                                                                      │
       │   SDL_DestroyWindow(window);                                                         │
       │   SDL_Quit();                                                                        │
       │                                                                                      │
       │   return 0;                                                                          │
       │ }                                                                                    │
       └──────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       You must include SDL_syswm.h for the declaration of SDL_SysWMinfo.

       The  info  structure  must  be  initialized  with the SDL version, and is then
       filled in with information about the given window, as shown in the Code  Exam‐
       ple.

VERSION
       This function is available since SDL 2.0.0.

===============================================================================
                                           *SDL_HINT_ACCELEROMETER_AS_JOYSTICK*


NAME
       SDL_HINT_ACCELEROMETER_AS_JOYSTICK -- Hints

SYNOPSIS
       Values

       0    list only real joysticks and accept input from them

       1    list  real  joysticks along with the accelerometer as if it were a 3 axis
            joystick (the default)

DESCRIPTION
       A hint that specifies whether the Android / iOS built-in accelerometer  should
       be listed as a joystick device, rather than listing actual.

       By  default SDL will list real joysticks along with the accelerometer as if it
       were a 3 axis joystick.

REMARKS
       The hint is supported for iOS since SDL 2.0.4

VERSION
       Since SDL 2.0.2

===============================================================================
                             *SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION*


NAME
       SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION -- Hints

SYNOPSIS
       A hint that specifies the Android APK expansion main file version

DESCRIPTION
       Values

       X    the  Android  APK  expansion main file version (should be a string number
            like "1", "2", etc.)

DEFAULT
       By default this hint is not set.

REMARKS
       This hint must be  set  together  with  the  hint  SDL_HINT_ANDROID_APK_EXPAN‐
       SION_PATCH_FILE_VERSION

       If  both  hints  were set then SDL_RWFromFile() will look into expansion files
       after a given relative path was not found in the internal storage and assets.

       By default this hint is not set and the APK expansion files are not searched.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                            *SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION*


NAME
       SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION -- Hints

SYNOPSIS
       A hint that specifies the Android APK expansion patch file version

DESCRIPTION
       Values

       X    the  Android  APK  expansion  patch file version (should be string number
            like "1", "2", etc.)

DEFAULT
       By default this hint is not set.

REMARKS
       This hint must be  set  together  with  the  hint  SDL_HINT_ANDROID_APK_EXPAN‐
       SION_MAIN_FILE_VERSION

       If  both  hints  were set then SDL_RWFromFile() will look into expansion files
       after a given relative path was not found in the internal storage and assets.

       By default this hint is not set and the APK expansion files are not searched.

VERSION
       Available since SDL 2.0.4.

NOTE
       Draft

===============================================================================
                                    *SDL_HINT_ANDROID_SEPARATE_MOUSE_AND_TOUCH*


NAME
       SDL_HINT_ANDROID_SEPARATE_MOUSE_AND_TOUCH-- Hints

SYNOPSIS
       A hint that specifies a variable to control whether mouse and touch events are
       to be treated together or separately.

DESCRIPTION
       Values

       0    mouse events will be handled as touch events and touch  will  raise  fake
            mouse events

       1    mouse events will be handled separatedly from pure touch events

DEFAULT
       By  default  mouse events will be handled as touch events and touch will raise
       fake mouse events

REMARKS
       The value of this hint is used at runtime, so it can be changed at any time.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                                     *SDL_HINT_API_VIDEO_LAYER*


NAME
       SDL_HINT_API_VIDEO_LAYER -- Hints

SYNOPSIS
       A hint tha specifies which Dispmanx layer SDL should use on Rasberry Pi.

DESCRIPTION
       Values

       X    the Dispmanx layer to use

DEFAULT
       By default the Dispmanx layer is "10000".

REMARKS
       This  is  also  known as Z-order. The variable can take a negative or positive
       value.

VERSION
       Available since SDL 2.0.5

NOTE
       Draft

===============================================================================
                                       *SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS*


NAME
       SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS -- Hints

SYNOPSIS
       A  hint  that  specifies whether controller used with the Apple TV generate UI
       events.

DESCRIPTION
       Values

       0    controller input does not generate UI events

       1    controller input generates UI events

DEFAULT
       By default controller input does not generate UI events.

REMARKS
       When UI events are generated by controller input, the app will be backgrounded
       when  the  Apple  TV  remote's menu button is pressed, and when the pause or B
       button on gamepads are pressed.

VERSION
       Available since SDL 2.0.5

NOTE
       Draft

===============================================================================
                                      *SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION*


NAME
       SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION -- Hints

SYNOPSIS
       A  hint  that specifies whether the Apple TV remote's joystick axes will auto‐
       matically match the rotation of the remote.

DESCRIPTION
       Values

       0    remote orientation does not affect joystick axes

       1    joystick axes are based on the orientation of the remote

DEFAULT
       By default remote orientation does not affect joystick axes.

VERSION
       Available since SDL 2.0.5

NOTE
       Draft

===============================================================================
                                              *SDL_HINT_BMP_SAVE_LEGACY_FORMAT*


NAME
       SDL_HINT_BMP_SAVE_LEGACY_FORMAT -- Hints

SYNOPSIS
       A  hint  that  specifies  whether  SDL  should not use version 4 of the bitmap
       header when saving BMPs.

DESCRIPTION
       Values

       0    version 4 of the bitmap header will be used when saving BMPs

       1    version 4 of the bitmap header will not be used when saving BMPs

DEFAULT
       By default SDL will use version 4 of the bitmap header when saving BMPs.

REMARKS
       The bitmap header version 4 is required for proper alpha channel  support  and
       SDL will use it when required. Should this not be desired, this hint can force
       the use of the 40 bytes header version which is supported everywhere.

       If the hint is not set then surfaces with a colorkey or an alpha  channel  are
       saved  to a 32-bit BMP file with an alpha mask. SDL will use the bitmap header
       version 4 and set the alpha mask accordingly. This  is  the  default  behavior
       since SDL 2.0.5.

       If the hint is set then surfaces with a colorkey or an alpha channel are saved
       to a 32-bit BMP file without an alpha mask. The alpha channel data will be  in
       the  file, but application are going to ignore it. This was the default behav‐
       ior before SDL 2.0.5.

VERSION
       Available since SDL 2.0.5

SEE ALSO
       SDL_SaveBMP, SDL_SaveBMP_RW

NOTE
       Draft

===============================================================================
                                         *SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT*


NAME
       SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT -- Hints

SYNOPSIS
       A hint that specifies a value to override the binding element for keyboard in‐
       puts for Emscripten builds.

DESCRIPTION
       Values

       #window     the JavaScript window object (this is the default)

       #document   the JavaScript document object

       #screen     the JavaScript window.screen object

       #canvas     the default WebGL canvas element

       Any other string without a leading # sign applies to the element on  the  page
       with that ID.

DEFAULT
       By default SDL will use the JavaScript window object.

REMARKS
       This hint only applies to the Emscripten platform.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                            *SDL_HINT_FRAMEBUFFER_ACCELERATION*


NAME
       SDL_HINT_FRAMEBUFFER_ACCELERATION -- Hints

SYNOPSIS
       A hint tha specifies how 3D acceleration is used with SDL_GetWindowSurface().

DESCRIPTION
       Values

       0    disable 3D acceleration

       1    enable 3D acceleration, using the default renderer

       X    enable  3D  acceleration,  using  X where X is one of the valid rendering
            drivers. (e.g. "direct3d", "opengl", etc.)

DEFAULT
       By default SDL tries to make a best guess whether to use accleration or not on
       each platform.

REMARKS
       SDL  can  try  to  accelerate the screen surface returned by SDL_GetWindowSur‐
       face() by using streaming textures with a 3D rendering engine.  This  variable
       controls whether and how this is done.

===============================================================================
                                                *SDL_HINT_GAMECONTROLLERCONFIG*


NAME
       SDL_HINT_GAMECONTROLLERCONFIG -- Hints

SYNOPSIS
       A hint that specifies extra gamecontroller db entries.

DESCRIPTION
       Values

       X    a  newline delimited rows of gamecontroller config data, see SDL_gamecon‐
            troller.h

DEFAULT
       By default no extra gamecontroller db entries are specified.

REMARKS
       This hint must be set before calling SDL_Init(SDL_INIT_GAMECONTROLLER).

       You can update mappings after the  system  is  initialized  with  SDL_GameCon‐
       trollerMappingForGUID() and SDL_GameControllerAddMapping().

NOTE
       Draft

===============================================================================
                                                       *SDL_HINT_GRAB_KEYBOARD*


NAME
       SDL_HINT_GRAB_KEYBOARD -- Hints

SYNOPSIS
       A hint that specifies whether grabbing input grabs the keyboard.

DESCRIPTION
       Values

       0    grab will affect only the mouse

       1    grab will affect mouse and keyboard

DEFAULT
       By default SDL will not grab the keyboard so system shortcuts still work.

NOTE
       Draft

===============================================================================
                                                 *SDL_HINT_IDLE_TIMER_DISABLED*


NAME
       SDL_HINT_IDLE_TIMER_DISABLED -- Hints

SYNOPSIS
       A  hint  that  specifies a variable controlling whether the idle timer is dis‐
       abled on iOS.

DESCRIPTION
       Values

       0    enable idle timer

       1    disable idle timer

DEFAULT
       By default the idle timer is enabled.

REMARKS
       When an iOS application does not receive touches for some time, the screen  is
       dimmed automatically. For games where the accelerometer is the only input this
       is problematic. This functionality can be disabled by setting this hint.

       As of SDL 2.0.4, SDL_EnableScreenSaver() and  SDL_DisableScreenSaver()  accom‐
       plish the same thing on iOS. They should be preferred over this hint.

NOTE
       Draft

===============================================================================
                                                *SDL_HINT_IME_INTERNAL_EDITING*


NAME
       SDL_HINT_IME_INTERNAL_EDITING -- Hints

SYNOPSIS
       A  hint  that specifies whether certain IMEs should handle text editing inter‐
       nally instead of sending SDL_TEXTEDITING events.

DESCRIPTION
       Values

       0         SDL_TEXTEDITING events are sent, and it is the application's respon‐
                 sibility  to  render the text from these events and differentiate it
                 somehow from committed text. (default)

       1         If supported by the IME then SDL_TEXTEDITING events  are  not  sent,
                 and text that is being composed will be rendered in its own UI.

DEFAULT
       By  default  SDL_TEXTEDITING events are sent, and it is the applications's re‐
       sponsibility to render the text from these events and differentiate it somehow
       forom committed text.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                    *SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS*


NAME
       SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS -- Hints

SYNOPSIS
       A hint that specifies if joystick (and gamecontroller) events are enabled even
       when the application is in the background.

DESCRIPTION
       Values

       0    disable joystick & gamecontroller input events when the application is in
            the background

       1    enable  joystick & gamecontroller input events when the application is in
            the background

DEFAULT
       By default joystick (and gamecontroller) events are not enabled when  the  ap‐
       plication is in the background.

REMARKS
       This hint may be set at any time.

NOTE
       Draft

===============================================================================
                                                  *SDL_HINT_MAC_BACKGROUND_APP*


NAME
       SDL_HINT_MAC_BACKGROUND_APP -- Hints

SYNOPSIS
       A  hint  that specifies if the SDL app should be forced to become a foreground
       process on macOS.

DESCRIPTION
       Values

       0    force the SDL app to become a foreground process (default)

       1    do not force the SDL app to become a foreground process

DEFAULT
       By default the SDL app will be forced to become a foreground process on macOS.

REMARKS
       This hint only applies to macOS.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                  *SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK*


NAME
       SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK -- Hints

SYNOPSIS
       A  hint  that specifies whether ctrl+click should generate a right-click event
       on macOS.

DESCRIPTION
       Values

       0    disable emulating right-click

       1    enable emulating right-click

DEFAULT
       By default holding ctrl while left clicking will not generate  a  right  click
       event when on macOS.

VERSION
       Available since SDL 2.0.2

===============================================================================
                                            *SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH*


NAME
       SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH -- Hints

SYNOPSIS
       A hint that specifies if mouse click events are sent when clicking to focus an
       SDL window.

DESCRIPTION
       Values

       0    no mouse click events are sent when clicking to focus

       1    mouse click events are sent when clicking to focus

DEFAULT
       By default no mouse click events are sent when clicking to focus.

VERSION
       Available since SDL 2.0.5

NOTE
       Draft

===============================================================================
                                            *SDL_HINT_MOUSE_RELATIVE_MODE_WARP*


NAME
       SDL_HINT_MOUSE_RELATIVE_MODE_WARP -- Hints

SYNOPSIS
       A  hint  that specifies whether relative mouse mode is implemented using mouse
       warping.

DESCRIPTION
       Values

       0    relative mouse mode uses the raw input

       1    relative mouse mose uses mouse warping

DEFAULT
       By default SDL will use raw input for relative mouse mode.

VERSION
       Available since SDL 2.0.2

===============================================================================
                                                  *SDL_HINT_NO_SIGNAL_HANDLERS*


NAME
       SDL_HINT_NO_SIGNAL_HANDLERS -- Hints

SYNOPSIS
       A hint that specifies not to catch the SIGINT or SIGTERM signals.

DESCRIPTION
       Values

       0    SDL  will install a SIGINT and SIGTERM handler, and when it caches a sig‐
            nal, convert it into an SDL_QUIT event

       1    SDL will not install a signal handler at all

DEFAULT
       By default install a SIGINT and SIGTERM handler, and when it catches a signal,
       convert it into an SDL_QUIT event.

REMARKS
       This hint only applies to Unix-like platforms.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                                        *SDL_HINT_ORIENTATIONS*


NAME
       SDL_HINT_ORIENTATIONS -- Hints

SYNOPSIS
       A hint that specifies a variable controlling which orientations are allowed on
       iOS.

DESCRIPTION
       Values

       LandscapeLeft            top of device left

       LandscapeRight           top of device right

       Portrait                 top of device up

       PortraitUpsideDown       top of device down

DEFAULT
       By default all orientations are allowed.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────┐
       │#include <stdio.h>                                                    │
       │                                                                      │
       │int main(int argc, char* argv[])                                      │
       │{                                                                     │
       │  SDL_SetHint(SDL_HINT_ORIENTATIONS, "LandscapeLeft LandscapeRight"); │
       │}                                                                     │
       └──────────────────────────────────────────────────────────────────────┘

REMARKS
       In some circumstances it is necessary to be able to explicitly  control  which
       UI orientations are allowed.

       This variable is a space delimited list of the above values.

NOTE
       Draft

===============================================================================
                                             *SDL_HINT_RENDER_DIRECT3D11_DEBUG*


NAME
       SDL_HINT_RENDER_DIRECT3D11_DEBUG -- Hints

SYNOPSIS
       A  hint that specifies a variable controlling whether to enable Direct3D 11+'s
       Debug layer.

DESCRIPTION
       Values

       0    disable Debug layer user

       1    enable Debug layer use

DEFAULT
       By default SDL does not use Direct3D Debug layer.

REMARKS
       This variable does not have any effect on the Direct3D 9 based renderer.

VERSION
       Available since SDL 2.0.3

NOTE
       Draft

===============================================================================
                                          *SDL_HINT_RENDER_DIRECT3D_THREADSAFE*


NAME
       SDL_HINT_RENDER_DIRECT3D_THREADSAFE -- Hints

SYNOPSIS
       A  hint  that specifies whether the Direct3D device is initialized for thread-
       safe operations.

DESCRIPTION
       Values

       0    disable thread-safety (faster)

       1    enable thread-safety (slower)

DEFAULT
       By default the Direct3D device is created with thread-safety disabled.

VERSION
       Available since SDL 2.0.1

NOTE
       Draft

===============================================================================
                                                       *SDL_HINT_RENDER_DRIVER*


NAME
       SDL_HINT_RENDER_DRIVER -- Hints

SYNOPSIS
       A hint that specifies which render driver to use.

DESCRIPTION
       Values

       direct3d

       opengl

       opengles2

       opengles

       metal

       software

DEFAULT
       By default the first one in the list that is available on the current platform
       is chosen.

REMARKS
       The values are case-insensitive.

       If the application doesn't pick a specific  renderer  to  use,  this  variable
       specifies  the name of the preferred renderer. If the preferred renderer can't
       be initialized, the normal default renderer is used.

===============================================================================
                                               *SDL_HINT_RENDER_OPENGL_SHADERS*


NAME
       SDL_HINT_RENDER_OPENGL_SHADERS -- Hints

SYNOPSIS
       A hint that specifies whether the OpenGL render driver uses shader.

DESCRIPTION
       Values

       0    disable shaders

       1    enable shaders, if they are available

DEFAULT
       By default shaders are used if OpenGL supports them.

===============================================================================
                                                *SDL_HINT_RENDER_SCALE_QUALITY*


NAME
       SDL_HINT_RENDER_SCALE_QUALITY -- Hints

SYNOPSIS
       A hint that specifies scaling quality.

DESCRIPTION
       Values

       0 or nearest        nearest pixel sampling

       1 or linear         linear filtering (supported by OpenGL and Direct3D)

       2 or best           anisotropic filtering (supported by Direct3D)

DEFAULT
       By default neartest pixel sampling is used.

REMARKS
       This  hint  is  checked  when a texture is created and it affects scaling when
       copying that texture.

===============================================================================
                                                        *SDL_HINT_RENDER_VSYNC*


NAME
       SDL_HINT_RENDER_VSYNC -- Hints

SYNOPSIS
       A  hint that specifies whether sync to vertical refresh is enabled or disabled
       in SDL_CreateRenderer() to avoid tearing.

DESCRIPTION
       Values

       0    disable vsync

       1    enable vsync

DEFAULT
       By default SDL uses the SDL_RENDERER_PRESENTVSYNC flag  passed  into  SDL_Cre‐
       ateRenderer().

REMARKS
       SDL_HINT_RENDER_VSYNC overrides the SDL_RENDERER_PRESENTVSYNC flag in SDL_Cre‐
       ateRenderer().

===============================================================================
                                                   *SDL_HINT_THREAD_STACK_SIZE*


NAME
       SDL_HINT_THREAD_STACK_SIZE -- Hints

SYNOPSIS
       A  hint that specifies a variable specifying SDL's threads stack size in bytes
       or "0" for the backend's default size.

DESCRIPTION
       Values

       0    use the backend's default threads stack size

       X    use the provided positive threads stack size

DEFAULT
       By default the backend's default threads stack size is used.

REMARKS
       Use this hint in case you need to set SDL's threads stack size to  other  than
       the  default.  This  is  specially useful if you build SDL against a non glibc
       libc library (such as musl) which provides a relatively small  default  thread
       stack size (a few kilobytes versus the default 8 MB glibc uses).

       Support  for this hint is currently available only in the pthread, Windows (>=
       SDL 2.0.5), and PSP (>= SDL 2.0.5) backend.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                                    *SDL_HINT_TIMER_RESOLUTION*


NAME
       SDL_HINT_TIMER_RESOLUTION -- Hints

SYNOPSIS
       A hint that specifies the timer resolution in millseconds.

DESCRIPTION
       Values

       X    the timer resolution in milliseconds.

DEFAULT
       By default the value is "1".

REMARKS
       The  higher  resolution  the timer, the more frequently the CPU services timer
       interrupts, and the more precise delays are, but this takes up power  and  CPU
       time. This hint is only used on Windows, but not supported on WinRT.

       See   this   blog   post   for   more   information:  http://randomascii.word‐
       press.com/2013/07/08/windows-timer-resolution-megawatts-wasted/

       If this variable is set to "0", the system timer resolution is not set.

       This hint may be set at any time.

NOTE
       Draft

===============================================================================
                                            *SDL_HINT_VIDEO_ALLOW_SCREEENSAVER*


NAME
       SDL_HINT_VIDEO_ALLOW_SCREEENSAVER -- Hints

SYNOPSIS
       A hint that specifies whether the screensaver is enabled.

DESCRIPTION
       Values

       0    disable screensaver

DEFAULT
       By default SDL will disable the screensaver.

VERSION
       Available since SDL 2.0.2

NOTE
       Draft

===============================================================================
                                              *SDL_HINT_VIDEO_HIGHDPI_DISABLED*


NAME
       SDL_HINT_VIDEO_HIGHDPI_DISABLED -- Hints

SYNOPSIS
       A  hint that specifies if high-DPI windows ("Retina" on macOS and iOS) are not
       allowed.

DESCRIPTION
       Values

       0    allow high-DPI windows

       1    do not allow high-DPI windows

DEFAULT
       By default high-DPI windows ("Retina" on macOS and iOS) are allowed.

REMARKS
       On Apple's macOS you must set the NSHighResolutionCapable in Info.plist  prop‐
       erty to YES, otherwise you will not receive a high-DPI OpenGL display.

       This hint is supported for iOS since SDL 2.0.4

VERSION
       Available since SDL 2.0.1

NOTE
       Draft

===============================================================================
                                         *SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES*


NAME
       SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES -- Hints

SYNOPSIS
       A hint that dictates policy for fullscreen Spaces on macOS.

DESCRIPTION
       Values

       0    disable  Spaces  support  (FULLSCREEN_DESKTOP won't use them and SDL_WIN‐
            DOW_RESIZABLE windows won't offer the "fullscreen" button on their title‐
            bars)

       1    enable  Spaces  support  (FULLSCREEN_DESKTOP  will  use them and SDL_WIN‐
            DOW_RESIZABLE windows will offer the "fullscreen" button on their  title‐
            bars)

DEFAULT
       By default Spaces supports is enabled.

REMARKS
       This hint only applies to macOS.

       Spaces  are  disabled  regardless  of this hint if the OS isn't at least macOS
       Lion (10.7). This hint must be set before any windows are created.

VERSION
       Available since SDL 2.0.2

NOTE
       Draft

===============================================================================
                                        *SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS*


NAME
       SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS -- Hints

SYNOPSIS
       A  hint that specifies if a SDL_Window is minimized if it loses key focus when
       in fullscreen mode.

DESCRIPTION
       Values

       0    do not minimize SDL_Window if it loses key focus when in fullscreen mode

       1    do minimize the SDL_Window if it loses key focus when in fullscreen mode

DEFAULT
       By default a SDL_Window is minimized if it loses key focus when in  fullscreen
       mode.

NOTE
       Draft

===============================================================================
                                     *SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT*


NAME
       SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT -- Hints

SYNOPSIS
       A hint that specifies the address of another SDL_Window* (as a hex string for‐
       matted with "%p").

DESCRIPTION
       Values

       X    the address (as a string "%p") of the SDL_Window* that new  windows  cre‐
            ated with SDL_CreateWindowFrom() should share a pixel format with

DEFAULT
       By default this hint is not set.

REMARKS
       If  this  hint  is set before SDL_CreateWindowFrom() and the SDL_Window* it is
       set to has SDL_WINDOW_OPENGL set (and running on WGL  only,  currently),  then
       two things will occur on the newly created SDL_Window:

       1.   Its pixel format will be set to the same pixel format as this SDL_Window.
            This is needed for example when sharing an OpenGL context across multiple
            windows.

       2.   The  flag  SDL_WINDOW_OPENGL  will  be set on the new window so it can be
            used for OpenGL rendering.

VERSION
       Available since SDL 2.0.2

===============================================================================
                                               *SDL_HINT_VIDEO_WIN_D3DCOMPILER*


NAME
       SDL_HINT_VIDEO_WIN_D3DCOMPILER -- Hints

SYNOPSIS
       A  hint  that specifies which shader compiler to preload when using the Chrome
       ANGLE binaries.

DESCRIPTION
       Values

       d3dcompiler_45.dll
            (default) best for Vista or later

       d3dcompiler_43.dll
            for XP support

       none do not load any library, useful if you compiled ANGLE from source and in‐
            cluded the compiler in your binaries.

DEFAULT
       By default "d3dcompiler_46.dll" will be used.

REMARKS
       SDL  has  EGL  and OpenGL ES2 support on Windows via the ANGLE project. It can
       use different sets of binaries, those compiled by  the  user  from  source  or
       those  provided  by  the Chrome browser. In the later case, these binaries re‐
       quire that SDL loads a DLL providing the shader compiler.

VERSION
       Available since SDL 2.0.2

===============================================================================
                                               *SDL_HINT_VIDEO_X11_NET_WM_PING*


NAME
       SDL_HINT_VIDEO_X11_NET_WM_PING -- Hints

SYNOPSIS
       A  hint  that  specifies  whether the X11 _NET_WM_PING protocol should be sup‐
       ported.

DESCRIPTION
       Values

       0    disable _NET_WM_PING

       1    enable _NET_WM_PING

DEFAULT
       By default SDL will use _NET_WM_PING, but for applications that know they will
       not  always  be  able  to repsond to ping requests in a timely manner they can
       turn it off to avoid the window manager thinking the app is hung.

REMARKS
       The hint is checked in SDL_CreateWindow().

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                                  *SDL_HINT_VIDEO_X11_XINERAMA*


NAME
       SDL_HINT_VIDEO_X11_XINERAMA -- Hints

SYNOPSIS
       A hint that specifies whether the X11 Xinerama extension should be used.

DESCRIPTION
       Values

       0    disable Xinerama

       1    enable Xinerama

DEFAULT
       By default SDL will use Xinerama if it is available.

NOTE
       Draft

===============================================================================
                                                    *SDL_HINT_VIDEO_X11_XRANDR*


NAME
       SDL_HINT_VIDEO_X11_XRANDR -- Hints

SYNOPSIS
       A hint that specifies whether the X11 XRandR extension should be used.

DESCRIPTION
       Values

       0    disable XRandR

       1    enable XRandR

DEFAULT
       By default SDL will not use XRandR because of window manager issues.

REMARKS
       For details about the referenced window manager issues, see the following mes‐
       sage (and its thread) on the SDL mailing list:  http://lists.libsdl.org/piper‐
       mail/sdl-libsdl.org/2012-October/651919.html

NOTE
       Draft

===============================================================================
                                                  *SDL_HINT_VIDEO_X11_XVIDMODE*


NAME
       SDL_HINT_VIDEO_X11_XVIDMODE -- Hints

SYNOPSIS
       A hint that specifies whether the X11 VidMode extension should be used.

DESCRIPTION
       Values

       0    disable XVidMode

       1    enable XVidMode

DEFAULT
       By default SDL will use XVidMode if it is available.

===============================================================================
                                       *SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING*


NAME
       SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING -- Hints

SYNOPSIS
       A  hint  that  specifies whether SDL should not name threads on Microsoft Win‐
       dows.

DESCRIPTION
       Values

       0    threads will be named

       1    threads will not be named

DEFAULT
       By default SDL will name threads on Microsoft Windows.

REMARKS
       If the hint is not set then SDL will raise the 0x406D1388  exception  to  name
       threads. This is the default behavior of SDL.

       If the hint is set then SDL will not raise this exception, and threads will be
       unnamed. For .NET languages this is required when running under a debugger.

VERSION
       Available since SDL 2.0.5

SEE ALSO
       SDL_CreateThread

NOTE
       Draft

===============================================================================
                                          *SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP*


NAME
       SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP -- Hints

SYNOPSIS
       A hint that specifies whether the windows message loop is processed by SDL.

DESCRIPTION
       Values

       0    the window message loop is not run

       1    the window message loop is processed in SDL_PumpEvent()

DEFAULT
       By default SDL will process the windows message loop.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                          *SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4*


NAME
       SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4 -- Hints

SYNOPSIS
       A  hint  that  specifies that SDL should not to generate SDL_WINDOWEVENT_CLOSE
       events for Alt+F4 on Microsoft Windows.

DESCRIPTION
       Values

       0    generate an SDL_WINDOWEVENT_CLOSE event for Alt+F4 (default)

       1    do not generate event and only do normal key handling for Alt+F4

DEFAULT
       By default SDL will generate an SDL_WINDOWEVENT_CLOSE event for Alt+F4.

REMARKS
       This hint must be set together with the hint ...

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                             *SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN*


NAME
       SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN -- Hints

SYNOPSIS
       A  hint  that specifies whether the window frame and title bar are interactive
       when the cursor is hidden.

DESCRIPTION
       Values

       0    the window frame is not interactive when the cursor is hidden  (no  move,
            resize, etc)

       1    the window frame is interactive when the cursor is hidden

DEFAULT
       By default SDL will allow interaction with the window frame when the cursor is
       hidden.

REMARKS
       This hint must be set together with the hint ...

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                            *SDL_HINT_WINRT_HANDLE_BACK_BUTTON*


NAME
       SDL_HINT_WINRT_HANDLE_BACK_BUTTON -- Hints

SYNOPSIS
       A  hint that specifies a variable to allow back-button-press events on Windows
       Phone to be marked as handled.

DESCRIPTION
       Values

       1    mark the button as handled

DEFAULT
       By default this hint is not set and the application will be terminated.

REMARKS
       Windows Phone devices typically feature a Back button. When  pressed,  the  OS
       will  emit  back-button-press  events, which apps are expected to handle in an
       appropriate manner. If apps do not explicitly mark these events as  "Handled",
       then  the  OS will invoke its default behavior for unhandled back-button-press
       events, which on Windows Phone 8 and 8.1 is to terminate the app (and  attempt
       to switch to the previous app, or to the device's home screen).

       Setting  the  SDL_HINT_WINTRT_HANDLE_BACK_BUTTON hint to "1" will cause SDL to
       mark back-button-press events as Handled, if and when one is sent to the app.

       Internally, Windows Phone sends back button events as  parameters  to  special
       back-button-press  callback  functions. Apps that need to respond to back-but‐
       ton-press events are expected to register one or more callback  functions  for
       such,  shortly  after  being launched (during the app's initialization phase).
       After the back button is pressed, the OS will invoke these callbacks.  If  the
       app's callback(s) do not explicitly mark the event as handled by the time they
       return, or if the app never registers one of these callback, the OS will  con‐
       sider the event un-handled, and it will apply its default back button behavior
       (terminate the app).

       SDL registers its own back-button-press callback with the  Windows  Phone  OS.
       This  callback  will  emit  a  pair  of  SDL key-press events (SDL_KEYDOWN and
       SDL_KEYUP), each with a scancode of SDL_SCANCODE_AC_BACK, after which it  will
       check  the  contents  of  the  hint, SDL_HINT_WINRT_HANDLE_BACK_BUTTON. If the
       hint's value is set to "1", the back button event's Handled property will  get
       set  to  "true". If the hint's value is set to something else, or if it is un‐
       set, SDL will leave the event's Handled property alone. (By  default,  the  OS
       sets this property to 'false' to note.)

       SDL  apps  can either set SDL_HINT_WINRT_HANDLE_BACK_BUTTON well before a back
       button is pressed, or can set it in direct response to  a  back  button  being
       presed.

       In order to get notified when a back button is pressed, SDL apps should regis‐
       ter a callback function with  SDL_AddEventWatch(),  and  have  it  listen  for
       SDL_KEYDOWN  events  that  have  a scancode of SDL_SCANCODE_AC_BACK. (Alterna‐
       tively, SDL_KEYUP events can be listened-for. Listening for either event  type
       is  suitable.)  Any  value  of SDL_HINT_WINRT_HANDLE_BACK_BUTTON set by such a
       callback, will be applied to the OS's current back-button-press event.

       More details on back button behavior in Windows Phone apps can be found at the
       following  page,  on Microsoft's developer site: http://msdn.microsoft.com/en-
       us/library/windowsphone/develop/jj247550(v=vs.105).aspx

VERSION
       Available since SDL 2.0.3

NOTE
       Draft

===============================================================================
                                          *SDL_HINT_WINRT_PRIVACY_POLICY_LABEL*


NAME
       SDL_HINT_WINRT_PRIVACY_POLICY_LABEL -- Hints

SYNOPSIS
       A hint that specifies a label text for a WinRT app's privacy policy link.

DESCRIPTION
       Values

       X    a label text for a WinRT app's privacy policy link

DEFAULT
       By default this hint's value is "Privacy Policy".

REMARKS
       Network-enabled  WinRT  apps  must include a privacy policy. On Windows 8, 8.1
       and RT, Microsoft mandates that this policy be available via the Windows  Set‐
       tings  charm. SDL provides code to add a link there, with its label text being
       set via the optional hint, SDL_HINT_WINRT_PRIVACY_POLICY_LABEL.

       Please note that a privacy policy's contents are not set via this hint. A sep‐
       arate  hint,  SDL_HINT_WINRT_PRIVACY_POLICY_URL, is used to link to the actual
       text of the policy.

       The contents of this hint should be encoded as a UTF8 string.

       The default value is "Privacy Policy". This hint should only be set during app
       initialization, preferably before any calls to SDL_Init().

       For additional information on linking to privacy policy, see the documentation
       for SDL_HINT_WINRT_PRIVACY_POLICY_URL.

VERSION
       Available since SDL 2.0.3

NOTE
       Draft

===============================================================================
                                            *SDL_HINT_WINRT_PRIVACY_POLICY_URL*


NAME
       SDL_HINT_WINRT_PRIVACY_POLICY_URL -- Hints

SYNOPSIS
       A hint that specifies a URL to a WinRT app's privacy policy.

DESCRIPTION
       Values

       X    a URL to a WinRT app's privacy policy

DEFAULT
       By default this hint is not set.

REMARKS
       All  network-enabled WinRT apps must make a privacy available to its users. On
       Windows 8, 8.1, and RT, Microsft mandates that this policy be available in the
       Windows  Settings charm, as accessed from within the app. SDL provides code to
       add a URL-based link there, which can point to the app's privacy policy.

       To setup a URL to an app's privacy policy, set SDL_HINT_WINRT_PRIVACY_URL  be‐
       fore  calling  any  SDL_Init() functions. The contents of the hint should be a
       valid URL. For example, " http://www.example.com".

       The default value is "", which will prevent SDL from adding a  privacy  policy
       link to the Settings charm. This hint should only be set during app init.

       The  label  text  of an app's "Privacy Policy" link may be  customized via an‐
       other hint, SDL_HINT_WINRT_PRIVACY_POLICY_LABEL.

       Please note that on Windows Phone, MIcrosoft does not provide standard UI  for
       displaying  a  privacy  policy  link, and as such, SDL_HINT_WINRT_PRIVACY_POL‐
       ICY_URL will not get used on that platform. Network-enabled phone apps  should
       display their privacy policy through some other, in-app means.

VERSION
       Available since SDL 2.0.3

NOTE
       Draft

===============================================================================
                                                      *SDL_HINT_XINPUT_ENABLED*


NAME
       SDL_HINT_XINPUT_ENABLED -- Hints

SYNOPSIS
       A hint that specifies if XInput gamepad devices are detected.

DESCRIPTION
       Values

       0    disable XInput detection (only uses direct input)

       1    enable XInput detection (the default)

DEFAULT
       By default XInput gamepad devices are detected.

===============================================================================
                                     *SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING*


NAME
       SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING -- Hints

SYNOPSIS
       A  hint that specifies that SDL should use the old axis and button mapping for
       XInput devices.

DESCRIPTION
       Values

       0    use the old axis and button mapping for XInput devices

       1    do not use old axis and button mapping for XInput devices

DEFAULT
       By default SDL does not use the old axis and button  mapping  for  XInput  de‐
       vices.

REMARKS
       This hint is for backwards compatibility only and will be removed in SDL 2.1.

VERSION
       Available since SDL 2.0.4

NOTE
       Draft

===============================================================================
                                                              *SDL_HapticClose*


NAME
       SDL_HapticClose -- Function

SYNOPSIS
       Use  this  function to close a haptic device previously opened with SDL_Hapti‐
       cOpen().

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ void SDL_HapticClose(SDL_Haptic*    haptic)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the  SDL_Haptic  device   to │
       │         │ close                        │
       └─────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_HapticOpen

===============================================================================
                                                          *SDL_HapticCondition*


NAME
       SDL_HapticCondition -- Structure

SYNOPSIS
       A structure that contains a template for a condition effect.

DATA FIELDS
       ┌────────────────────────────────────────────────────────────┐
       │                          Header                            │
       ├──────────────────────┬─────────────┬───────────────────────┤
       │ Uint16               │ type        │ one  of  the  effects │
       │                      │             │ handled    by    this │
       │                      │             │ structure;   see  Re‐ │
       │                      │             │ marks for details     │
       ├──────────────────────┼─────────────┼───────────────────────┤
       │ SDL_HapticDirection  │ direction   │ direction of the  ef‐ │
       │                      │             │ fect  -  not  used at │
       │                      │             │ the moment;  see  Re‐ │
       │                      │             │ marks for details     │
       ├──────────────────────┴─────────────┴───────────────────────┤
       │                          Replay                            │
       ├──────────────────────┬─────────────┬───────────────────────┤
       │ Uint32               │ length      │ duration  of  the ef‐ │
       │                      │             │ fect                  │
       ├──────────────────────┼─────────────┼───────────────────────┤
       │ Uint16               │ delay       │ delay before starting │
       │                      │             │ the effect            │
       ├──────────────────────┴─────────────┴───────────────────────┤
       │                          Trigger                           │
       ├──────────────────────┬─────────────┬───────────────────────┤
       │ Uint16               │ button      │ button  that triggers │
       │                      │             │ the effect            │
       ├──────────────────────┼─────────────┼───────────────────────┤
       │ Uint16               │ interval    │ how soon  it  can  be │
       │                      │             │ triggered again after │
       │                      │             │ button                │
       ├──────────────────────┴─────────────┴───────────────────────┤
       │                         Condition                          │
       ├──────────────────────┬─────────────┬───────────────────────┤
       │ Uint16               │ right_sat   │ level  when  joystick │
       │                      │             │ is  to  the  positive │
       │                      │             │ side; max 0xFFFF      │
       ├──────────────────────┼─────────────┼───────────────────────┤
       │ Uint16               │ left_sat    │ level  when  joystick │
       │                      │             │ is  to  the  negative │
       │                      │             │ side; max 0xFFFF      │
       ├──────────────────────┼─────────────┼───────────────────────┤
       │ Sint16               │ right_coeff │ how fast to  increase │
       │                      │             │ the force towards the │
       │                      │             │ positive side         │
       ├──────────────────────┼─────────────┼───────────────────────┤
       │ Sint16               │ left_coeff  │ how fast to  increase │
       │                      │             │ the force towards the │
       │                      │             │ negative side         │
       ├──────────────────────┼─────────────┼───────────────────────┤
       │ Uint16               │ deadband    │ size  of   the   dead │
       │                      │             │ zone;   max   0xFFFF: │
       │                      │             │ whole axis-range when │
       │                      │             │ 0-centered            │
       ├──────────────────────┼─────────────┼───────────────────────┤
       │ Sint16               │ center      │ position  of the dead │
       │                      │             │ zone                  │
       └──────────────────────┴─────────────┴───────────────────────┘

REMARKS
       type may be one of the following:

       ┌──────────────────────┬──────────────────────────────┐
       │ SDL_HAPTIC_SPRING    │ effect based on  axis  posi‐ │
       │                      │ tion                         │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_HAPTIC_DAMPER    │ effect  based on axis veloc‐ │
       │                      │ ity                          │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_HAPTIC_INERTIA   │ effect based on axis  accel‐ │
       │                      │ eration                      │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_HAPTIC_FRICTION  │ effect  based  on axis move‐ │
       │                      │ ment                         │
       └──────────────────────┴──────────────────────────────┘

       direction is (currently) handled by condition internals instead of a direction
       member. The condition effect specific members have three parameters. The first
       refers to the X axis, the second refers to the Y axis and the third refers  to
       the  Z  axis.  The  right terms refer to the positive side of the axis and the
       left terms refer to the negative  side  of  the  axis.  Please  refer  to  the
       SDL_HapticDirection diagram for which side is positive and which is negative.

RELATED STRUCTURES
       SDL_HapticDirection

RELATED FUNCTIONS
       SDL_HapticNewEffect

===============================================================================
                                                           *SDL_HapticConstant*


NAME
       SDL_HapticConstant -- Structure

SYNOPSIS
       A structure that contains a template for a constant effect.

DATA FIELDS
       ┌──────────────────────────────────────────────────────────────┐
       │                           Header                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ type          │ SDL_HAPTIC_CONSTANT   │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ SDL_HapticDirection  │ direction     │ direction  of the ef‐ │
       │                      │               │ fect                  │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Replay                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint32               │ length        │ duration of  the  ef‐ │
       │                      │               │ fect                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ delay         │ delay before starting │
       │                      │               │ the effect            │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Trigger                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ button        │ button that  triggers │
       │                      │               │ the effect            │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ interval      │ how  soon  it  can be │
       │                      │               │ triggered again after │
       │                      │               │ button                │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                          Constant                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Sint16               │ level         │ strength  of the con‐ │
       │                      │               │ stant effect          │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                          Envelope                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ attack_length │ duration of  the  at‐ │
       │                      │               │ tack                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ attack_level  │ level at the start of │
       │                      │               │ the attack            │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ fade_length   │ duration of the fade  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ fade_level    │ level at the  end  of │
       │                      │               │ the fade              │
       └──────────────────────┴───────────────┴───────────────────────┘

REMARKS
       This struct is exclusively for the SDL_HAPTIC_CONSTANT effect.

       A  constant  effect  applies a constant force to the joystick in the specified
       direction.

RELATED FUNCTIONS
       SDL_HapticNewEffect

===============================================================================
                                                             *SDL_HapticCustom*


NAME
       SDL_HapticCustom -- Structure

SYNOPSIS
       A  structure that contains a template for the SDL_HAPTIC_CUSTOM (a custom) ef‐
       fect.

DATA FIELDS
       ┌──────────────────────────────────────────────────────────────┐
       │                           Header                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ type          │ SDL_HAPTIC_CUSTOM     │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ SDL_HapticDirection  │ direction     │ direction of the  ef‐ │
       │                      │               │ fect (relative to the │
       │                      │               │ user)                 │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Replay                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint32               │ length        │ duration of  the  ef‐ │
       │                      │               │ fect                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ delay         │ delay before starting │
       │                      │               │ the effect            │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Trigger                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ button        │ button that  triggers │
       │                      │               │ the effect            │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ interval      │ how  soon  it  can be │
       │                      │               │ triggered again after │
       │                      │               │ button                │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Custom                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint8                │ channels      │ axes  to use, minimum │
       │                      │               │ of 1; see Remarks for │
       │                      │               │ details               │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ period        │ sample periods        │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ samples       │ amount   (number)  of │
       │                      │               │ samples               │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16*              │ data          │ should contain  chan‐ │
       │                      │               │ nels*samples   items; │
       │                      │               │ see Remarks  for  de‐ │
       │                      │               │ tails                 │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                          Envelope                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ attack_length │ duration  of  the at‐ │
       │                      │               │ tack                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ attack_level  │ level at the start of │
       │                      │               │ the attack            │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ fade_length   │ duration of the fade  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ fade_level    │ level  at  the end of │
       │                      │               │ the fade              │
       └──────────────────────┴───────────────┴───────────────────────┘

REMARKS
       This struct is exclusively for the SDL_HAPTIC_CUSTOM effect.

       A custom force feedback effect is much like a periodic effect, where  the  ap‐
       plication can define its exact shape. You will have to allocate the data your‐
       self.

       data should consist of channels * samples Uint16 samples.

       If channels is 1, the effect is rotated using the defined direction. Otherwise
       it uses the samples in data for the different axes.

RELATED STRUCTURES
       SDL_HapticDirection
       SDL_HapticEffect

RELATED FUNCTIONS
       SDL_HapticNewEffect

===============================================================================
                                                      *SDL_HapticDestroyEffect*


NAME
       SDL_HapticDestroyEffect -- Function

SYNOPSIS
       Use this function to destroy a haptic effect on the device.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ void SDL_HapticDestroyEffect(SDL_Haptic*    haptic,  │
       │                              int            effect)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the SDL_Haptic device to de‐ │
       │         │ stroy the effect on          │
       ├─────────┼──────────────────────────────┤
       │ effect  │ identifier of the haptic ef‐ │
       │         │ fect to destroy              │
       └─────────┴──────────────────────────────┘

REMARKS
       This will stop the effect if it's running. Effects are automatically destroyed
       when the device is closed.

RELATED FUNCTIONS
       SDL_HapticNewEffect

===============================================================================
                                                          *SDL_HapticDirection*


NAME
       SDL_HapticDirection -- Structure

SYNOPSIS
       A structure that contains a haptic direction.

DATA FIELDS
       ┌─────────┬──────┬───────────────────────┐
       │ Uint8   │ type │ the type of encoding; │
       │         │      │ see Remarks  for  de‐ │
       │         │      │ tails                 │
       ├─────────┼──────┼───────────────────────┤
       │ Sint32  │ dir  │ the  encoding  direc‐ │
       │         │      │ tion; see Remarks for │
       │         │      │ details               │
       └─────────┴──────┴───────────────────────┘

CODE EXAMPLES
       Example  of  force coming from the south with all encodings (force coming from
       the south means the user will have to pull the stick to counteract):

       ┌──────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_HapticDirection direction;                                                           │
       │                                                                                          │
       │ // Cartesian directions                                                                  │
       │ direction.type = SDL_HAPTIC_CARTESIAN;  // Using cartesian direction encoding.           │
       │ direction.dir[0] = 0;  // X position                                                     │
       │ direction.dir[1] = 1;  // Y position                                                     │
       │ // Assuming the device has 2 axes, we don't need to specify third parameter.             │
       │                                                                                          │
       │ // Polar directions                                                                      │
       │ direction.type = SDL_HAPTIC_POLAR;  // We'll be using polar direction encoding.          │
       │ direction.dir[0] = 18000;  // Polar only uses first parameter                            │
       │                                                                                          │
       │ // Spherical coordinates                                                                 │
       │ direction.type = SDL_HAPTIC_SPHERICAL;  // Spherical encoding                            │
       │ direction.dir[0] = 9000;  // Since we only have two axes we don't need more parameters.  │
       └──────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This is the direction where the force comes from, instead of the direction  in
       which the force is exerted.

       Cardinal  directions  of  the haptic device are relative to the positioning of
       the device. North is considered to be away from the user. South is toward  the
       user. East is right, and West is left of the user.

       The following diagram represents the cardinal directions:

       ┌──────────────────────────────────────────────┐
       │                .--.                          │
       │                |__| .-------.                │
       │                |=.| |.-----.|                │
       │                |--| ||     ||                │
       │                |  | |'-----'|                │
       │                |__|~')_____('                │
       │                 [ COMPUTER ]                 │
       │                                              │
       │                                              │
       │                  North (0,-1)                │
       │                       ^                      │
       │                       |                      │
       │                       |                      │
       │ (-1,0) West <----[ HAPTIC ]----> East (1,0)  │
       │                       |                      │
       │                       |                      │
       │                       v                      │
       │                  South (0,1)                 │
       │                                              │
       │                                              │
       │                  [ USER ]                    │
       │                    ||/                       │
       │                    (o o)                     │
       │              ---ooO-(_)-Ooo---               │
       └──────────────────────────────────────────────┘

       Directions can be specified by:

       ┌───────────────────────┬──────────────────────────────┐
       │ SDL_HAPTIC_POLAR      │ Specified  by  polar coordi‐ │
       │                       │ nates                        │
       ├───────────────────────┼──────────────────────────────┤
       │ SDL_HAPTIC_CARTESIAN  │ Specified by cartesian coor‐ │
       │                       │ dinates                      │
       ├───────────────────────┼──────────────────────────────┤
       │ SDL_HAPTIC_SPHERICAL  │ Specified by spherical coor‐ │
       │                       │ dinates                      │
       └───────────────────────┴──────────────────────────────┘

       If type is SDL_HAPTIC_POLAR, direction is encoded by hundredths  of  a  degree
       starting north and turning clockwise. SDL_HAPTIC_POLAR only uses the first dir
       parameter. The cardinal directions would be:

       ┌────────┬─────────────────────┐
       │ North  │ 0 (0 degrees)       │
       ├────────┼─────────────────────┤
       │ East   │ 9000 (90 degrees)   │
       ├────────┼─────────────────────┤
       │ South  │ 18000 (180 degrees) │
       ├────────┼─────────────────────┤
       │ West   │ 27000 (270 degrees) │
       └────────┴─────────────────────┘

       If type is SDL_HAPTIC_CARTESIAN, direction is encoded by  three  positions  (X
       axis, Y axis, and Z axis (with 3 axes)).
       DL_HAPTIC_CARTESIAN  uses  the first three dir parameters. The cardinal direc‐
       tions would be:

       ┌────────┬──────────┐
       │ North  │ 0,-1, 0  │
       ├────────┼──────────┤
       │ East   │ 1, 0, 0  │
       ├────────┼──────────┤
       │ South  │ 0, 1, 0  │
       ├────────┼──────────┤
       │ West   │ -1, 0, 0 │
       └────────┴──────────┘

              The Z axis represents the height of the effect if supported,  otherwise
              it's  unused.  In  cartesian encoding (1,2) would be the same as (2,4),
              you can use any multiple you want, only the direction matters.

       If type is SDL_HAPTIC_SPHERICAL, direction is encoded by  two  rotations.  The
       first two dir parameters are used. The dir parameters are as follows (all val‐
       ues are in hundredths of degrees):

       ┌───────────────────────────────────────────────────────────┐
       │ Degrees from (1,0) rotated towards (0,1)                  │
       ├───────────────────────────────────────────────────────────┤
       │ Degrees towards (0, 0, 1) (device needs at least 3 axes)  │
       └───────────────────────────────────────────────────────────┘

RELATED STRUCTURES
       SDL_HapticPeriodic

RELATED FUNCTIONS
       SDL_HapticNumAxes

===============================================================================
                                                             *SDL_HapticEffect*


NAME
       SDL_HapticEffect -- Structure

SYNOPSIS
       A union that contains the generic template of any haptic effect.

DATA FIELDS
       ┌──────────────────────┬───────────┬───────────────────────┐
       │ Uint16               │ type      │ effect    type;   see │
       │                      │           │ SDL_HapticPeriodic    │
       │                      │           │ for details           │
       ├──────────────────────┼───────────┼───────────────────────┤
       │ SDL_HapticConstant   │ constant  │ constant  effect; see │
       │                      │           │ Remarks for details   │
       ├──────────────────────┼───────────┼───────────────────────┤
       │ SDL_HapticPeriodic   │ periodic  │ periodic effect;  see │
       │                      │           │ Remarks for details   │
       ├──────────────────────┼───────────┼───────────────────────┤
       │ SDL_HapticCondition  │ condition │ condition effect; see │
       │                      │           │ Remarks for details   │
       ├──────────────────────┼───────────┼───────────────────────┤
       │ SDL_HapticRamp       │ ramp      │ ramp effect; see  Re‐ │
       │                      │           │ marks for details     │
       ├──────────────────────┼───────────┼───────────────────────┤
       │ SDL_HapticLeftRight  │ leftright │ left/right    effect; │
       │                      │           │ see Remarks  for  de‐ │
       │                      │           │ tails                 │
       ├──────────────────────┼───────────┼───────────────────────┤
       │ SDL_HapticCustom     │ custom    │ custom   effect;  see │
       │                      │           │ Remarks for details   │
       └──────────────────────┴───────────┴───────────────────────┘

REMARKS
       All structures in this union contain the following common parts:

       ┌─────────────────────────────────────────────────────────────────┐
       │        Replay (all effects except left-right have this)         │
       ├───────────────┬────────────────────┬────────────────────────────┤
       │    Uint32     │length              │ duration  of   effect      │
       │               │                    │ (ms)                       │
       ├───────────────┼────────────────────┼────────────────────────────┤
       │    Uint16     │delay               │ delay before starting      │
       │               │                    │ effect                     │
       ├───────────────┴────────────────────┴────────────────────────────┤
       │       Trigger (all effects except left-right have this)         │
       ├───────────────┬────────────────────┬────────────────────────────┤
       │    Uint16     │button              │ button that  triggers      │
       │               │                    │ effect                     │
       ├───────────────┼────────────────────┼────────────────────────────┤
       │    Uint16     │interval            │ how  soon  before ef‐      │
       │               │                    │ fect can be triggered      │
       │               │                    │ again                      │
       ├───────────────┴────────────────────┴────────────────────────────┤
       │ Envelope  (all effects except condition effects and left-right  │
       │ have this)                                                      │
       ├───────────────┬────────────────────┬────────────────────────────┤
       │    Uint16     │attack_length       │ duration of  the  at‐      │
       │               │                    │ tack (ms)                  │
       ├───────────────┼────────────────────┼────────────────────────────┤
       │    Uint16     │attack_level        │ level at the start of      │
       │               │                    │ the attack                 │
       ├───────────────┼────────────────────┼────────────────────────────┤
       │    Uint16     │fade_length         │ duration of the  fade      │
       │               │                    │ out (ms)                   │
       ├───────────────┼────────────────────┼────────────────────────────┤
       │    Uint16     │fade_level          │ level  at  the end of      │
       │               │                    │ the fade                   │
       └───────────────┴────────────────────┴────────────────────────────┘

       All values max at 32767 (0x7FFF). Signed values can be negative. Time  values,
       unless specified otherwise, are in millseconds.

       You can pass SDL_HAPTIC_INFINITY to length instead of a 0-32767 value. Neither
       delay, interval, attack_length, nor fade_length  support  SDL_HAPTIC_INFINITY.
       The SDL_HAPTIC_RAMP effect does not support a duration of SDL_HAPTIC_INFINITY.
       Fade will also not be used since effect never ends.

       Button triggers may not be supported on all devices. It is advised not to  use
       them  if  possible.  Buttons start at index 1 instead of index 0 like the joy‐
       stick.

       If both attack_length and fade_lendth are 0 the envelope is not  used,  other‐
       wise both values are used.

       Here is an example of a constant effect evolution in time:

       ┌──────────────────────────────────────────────────────────────────┐
       │ Strength                                                         │
       │ ^                                                                │
       │ |                                                                │
       │ |    effect level -->  _________________                         │
       │ |                     /                 \                        │
       │ |                    /                   \                       │
       │ |                   /                     \                      │
       │ |                  /                       \                     │
       │ | attack_level --> |                        \                    │
       │ |                  |                        |  <---  fade_level  │
       │ |                                                                │
       │ +--------------------------------------------------> Time        │
       │                                                                  │
       │                    [--]                 [---]                    │
       │                attack_length          fade_length                │
       │                                                                  │
       │ [------------------][-----------------------]                    │
       │        delay                 length                              │
       └──────────────────────────────────────────────────────────────────┘

       Note  that  either  the attack_level or the fade_level may be above the actual
       effect level.

RELATED STRUCTURES
       SDL_HapticCondition
       SDL_HapticConstant
       SDL_HapticCustom
       SDL_HapticLeftRight
       SDL_HapticPeriodic
       SDL_HapticRamp

RELATED FUNCTIONS
       SDL_HapticEffectSupported
       SDL_HapticNewEffect
       SDL_HapticUpdateEffect

===============================================================================
                                                    *SDL_HapticEffectSupported*


NAME
       SDL_HapticEffectSupported -- Function

SYNOPSIS
       Use  this  function  to check to see if an effect is supported by a haptic de‐
       vice.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ int SDL_HapticEffectSupported(SDL_Haptic*         haptic,  │
       │                               SDL_HapticEffect*   effect)  │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the  SDL_Haptic  device   to │
       │         │ check on                     │
       ├─────────┼──────────────────────────────┤
       │ effect  │ the  desired effect to check │
       │         │ to see if it is supported    │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a  negative
       error code on failure; call SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_HapticNewEffect
       SDL_HapticQuery

===============================================================================
                                                    *SDL_HapticGetEffectStatus*


NAME
       SDL_HapticGetEffectStatus -- Function

SYNOPSIS
       Use  this  function  to  get the status of the current effect on the specified
       haptic device.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_HapticGetEffectStatus(SDL_Haptic*   haptic,  │
       │                               int           effect)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the  SDL_Haptic  device   to │
       │         │ query  for the effect status │
       │         │ on                           │
       ├─────────┼──────────────────────────────┤
       │ effect  │ the identifier of the haptic │
       │         │ effect to query its status   │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 if it isn't playing, 1 if it is playing, or a negative error code on
       failure; call SDL_GetError()ffor more information.

REMARKS
       Device must support the SDL_HAPTIC_STATUS feature.

RELATED FUNCTIONS
       SDL_HapticRunEffect
       SDL_HapticStopEffect

===============================================================================
                                                              *SDL_HapticIndex*


NAME
       SDL_HapticIndex -- Function

SYNOPSIS
       Use this function to get the index of a haptic device.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ int SDL_HapticIndex(SDL_Haptic*   haptic)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the SDL_Haptic device to get │
       │         │ the index of                 │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns the index of the specified haptic device or a negative error  code  on
       failure; call SDL_GetError()ffor more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticOpen
       SDL_HapticOpened

===============================================================================
                                                          *SDL_HapticLeftRight*


NAME
       SDL_HapticLeftRight -- Structure

SYNOPSIS
       A structure that contains a template for a left/right effect.

DATA FIELDS
       ┌───────────────────────────────────────────────────┐
       │                      Header                       │
       ├─────────┬─────────────────┬───────────────────────┤
       │ Uint16  │ type            │ SDL_HAPTIC_LEFTRIGHT  │
       ├─────────┴─────────────────┴───────────────────────┤
       │                      Replay                       │
       ├─────────┬─────────────────┬───────────────────────┤
       │ Uint32  │ length          │ duration  of  the ef‐ │
       │         │                 │ fect                  │
       ├─────────┴─────────────────┴───────────────────────┤
       │                      Rumble                       │
       ├─────────┬─────────────────┬───────────────────────┤
       │ Uint16  │ large_magnitude │ control of the  large │
       │         │                 │ controller motor      │
       ├─────────┼─────────────────┼───────────────────────┤
       │ Uint16  │ small_magnitude │ control  of the small │
       │         │                 │ controller motor      │
       └─────────┴─────────────────┴───────────────────────┘

REMARKS
       The struct is exclusively for the SDL_HAPTIC_LEFTRIGHT effect.

       The left/right effect is used to explicitly control the large  and  small  mo‐
       tors,  commonly  found in modern game controller. One motor is high frequency,
       the other is low frequency.

RELATED STRUCTURES
       SDL_HapticEffect

RELATED FUNCTIONS
       SDL_HapticNewEffect

===============================================================================
                                                               *SDL_HapticName*


NAME
       SDL_HapticName -- Function

SYNOPSIS
       Use this function to get the implementation dependent name of a haptic device.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ const char* SDL_HapticName(int    device_index)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ device_index  │ index  of the device to gets │
       │               │ its name                     │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the name of the device or NULL on  failure;  call  SDL_GetError()  for
       more information.

REMARKS
       This  can  be called before any joysticks are opened. If no name can be found,
       this function returns NULL.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_NumHaptics

===============================================================================
                                                          *SDL_HapticNewEffect*


NAME
       SDL_HapticNewEffect -- Function

SYNOPSIS
       Use this function to create a new haptic effect on a specified device.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_HapticNewEffect(SDL_Haptic*         haptic,  │
       │                         SDL_HapticEffect*   effect)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ an SDL_Haptic device to cre‐ │
       │         │ ate the effect on            │
       ├─────────┼──────────────────────────────┤
       │ effect  │ an  SDL_HapticEffect  struc‐ │
       │         │ ture  containing the proper‐ │
       │         │ ties of the effect to create │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns the ID of the effect on success or a negative error code  on  failure;
       call SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_HapticDestroyEffect
       SDL_HapticRunEffect
       SDL_HapticUpdateEffect

===============================================================================
                                                            *SDL_HapticNumAxes*


NAME
       SDL_HapticNumAxes -- Function

SYNOPSIS
       Use this function to get the number of haptic axes the device has.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ int SDL_HapticNumAxes(SDL_Haptic*   haptic)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the   SDL_Haptic  device  to │
       │         │ query                        │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns the number of axes on success or a negative  error  code  on  failure;
       call SDL_GetError() for more information.

REMARKS
       The number of haptic axes might be useful if working with the SDL_HapticDirec‐
       tion effect.

===============================================================================
                                                         *SDL_HapticNumEffects*


NAME
       SDL_HapticNumEffects -- Function

SYNOPSIS
       Use this function to get the number of effects a haptic device can store.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ int SDL_HapticNumEffects(SDL_Haptic*    haptic)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the   SDL_Haptic  device  to │
       │         │ query                        │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns the number of effects the haptic device can store or a negative  error
       code on failure; call SDL_GetError() for more information.

REMARKS
       On  some  platforms this isn't fully supported, and therefore is an approxima‐
       tion. Always check to see if your created effect was actually created  and  do
       not rely solely on SDL_HapticNumEffects().

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticNumEffectsPlaying
       SDL_HapticQuery

===============================================================================
                                                  *SDL_HapticNumEffectsPlaying*


NAME
       SDL_HapticNumEffectsPlaying -- Function

SYNOPSIS
       Use this function to get the number of effects a haptic device can play at the
       same time.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_HapticNumEffectsPlaying(SDL_Haptic*   haptic)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the  SDL_Haptic  device   to │
       │         │ query  maximum  playing  ef‐ │
       │         │ fects                        │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns the number of effects the haptic device can play at the same time or a
       negative error code on failure; call SDL_GetError() for more information.

REMARKS
       This  is not supported on all platforms, but will always return a value. Added
       here for the sake of completeness.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticNumEffects
       SDL_HapticQuery

===============================================================================
                                                               *SDL_HapticOpen*


NAME
       SDL_HapticOpen -- Function

SYNOPSIS
       Use this function to open a haptic device for use.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ SDL_Haptic* SDL_HapticOpen(int    device_index)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬─────────────────────────────┐
       │ device_index  │ index of the device to open │
       └───────────────┴─────────────────────────────┘

RETURN VALUE
       Returns the device identifier or NULL on failure; call SDL_GetError() for more
       information.

REMARKS
       The index passed as an argument refers to the N'th haptic device on this  sys‐
       tem.

       When  opening  a haptic device, its gain will be set to maximum and autocenter
       will be disabled. To modify these values use SDL_HapticSetGain() and  SDL_Hap‐
       ticSetAutocenter().

VERSION
       This function is avilable since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticClose
       SDL_HapticIndex
       SDL_HapticOpenFromJoystick
       SDL_HapticOpenFromMouse
       SDL_HapticPause
       SDL_HapticSetAutocenter
       SDL_HapticSetGain
       SDL_HapticStopAll

===============================================================================
                                                   *SDL_HapticOpenFromJoystick*


NAME
       SDL_HapticOpenFromJoystick -- Function

SYNOPSIS
       Use this function to open a haptic device for use from a joystick device.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────┐
       │ SDL_Haptic* SDL_HapticOpenFromJoystick(SDL_Joystick*    joystick)  │
       └────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ the SDL_Joystick to create a │
       │           │ haptic device from           │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns a valid haptic device identifier on success or NULL on  failure;  call
       SDL_GetError() for more information.

REMARKS
       You  must still close the haptic device separately. It will not be closed with
       the joystick.

       When opened from a joystick you should first close the  haptic  device  before
       closing the joystick device. If not, on some implementations the haptic device
       will also get unallocated and you'll be unable to use force feedback  on  that
       device.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticClose
       SDL_HapticOpen
       SDL_JoystickHaptic

===============================================================================
                                                      *SDL_HapticOpenFromMouse*


NAME
       SDL_HapticOpenFromMouse -- Function

SYNOPSIS
       Use this function to try to open a haptic device from the current mouse.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ SDL_Haptic* SDL_HapticOpenFromMouse(void)  │
       └────────────────────────────────────────────┘

RETURN VALUE
       Returns  the  haptic device identifier or NULL on failure; call SDL_GetError()
       for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticOpen
       SDL_MouseIsHaptic

===============================================================================
                                                             *SDL_HapticOpened*


NAME
       SDL_HapticOpened -- Function

SYNOPSIS
       Use  this  function  to check if the haptic device at the designated index has
       been opened.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ int SDL_HapticOpened(int    device_index)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ device_index  │ the index to check to see if │
       │               │ it has been opened           │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 if it has been opened, 0 if it hasn't or on failure; call SDL_GetEr‐
       ror() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticIndex
       SDL_HapticOpen

===============================================================================
                                                              *SDL_HapticPause*


NAME
       SDL_HapticPause -- Function

SYNOPSIS
       Use this function to pause a haptic device.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ int SDL_HapticPause(SDL_Haptic*   haptic)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the   SDL_Haptic  device  to │
       │         │ pause                        │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       Device  must support the SDL_HAPTIC_PAUSE feature. Call SDL_HapticUnpause() to
       resume playback.

       Do not modify the effects nor add new ones while the device  is  paused.  That
       can cause all sorts of weird errors.

RELATED FUNCTIONS
       SDL_HapticUnpause

===============================================================================
                                                           *SDL_HapticPeriodic*


NAME
       SDL_HapticPeriodic -- Structure

SYNOPSIS
       A structure that contains

DATA FIELDS
       ┌──────────────────────────────────────────────────────────────┐
       │                           Header                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ type          │ the   shape   of  the │
       │                      │               │ waves;  see   Remarks │
       │                      │               │ for details           │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ SDL_HapticDirection  │ direction     │ direction  of the ef‐ │
       │                      │               │ fect (relative to the │
       │                      │               │ user)                 │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Replay                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint32               │ length        │ duration  of  the ef‐ │
       │                      │               │ fect                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ delay         │ delay before starting │
       │                      │               │ the effect            │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Trigger                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ button        │ button  that triggers │
       │                      │               │ the effect            │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ interval      │ how soon  it  can  be │
       │                      │               │ triggered again after │
       │                      │               │ button                │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                          Periodic                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ period        │ period of the wave    │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Sint16               │ magnitude     │ peak value; if  nega‐ │
       │                      │               │ tive,  equivalent  to │
       │                      │               │ 180   degrees   extra │
       │                      │               │ phase shift           │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Sint16               │ offset        │ mean   value  of  the │
       │                      │               │ wave                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ phase         │ positive phase  shift │
       │                      │               │ given by hundredth of │
       │                      │               │ a degree; see Remarks │
       │                      │               │ for details           │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                          Envelope                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ attack_length │ duration  of  the at‐ │
       │                      │               │ tack                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ attack_level  │ level at the start of │
       │                      │               │ the attack            │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ fade_length   │ duration of the fade  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ fade_level    │ level  at  the end of │
       │                      │               │ the fade              │
       └──────────────────────┴───────────────┴───────────────────────┘

REMARKS
       A periodic effect consists of a wave-shaped effect that  repeats  itself  over
       time.  The  type determines the shape of the wave and the other parameters de‐
       termine the dimensions of the wave.

       ┌──────────────────────────────────────────────────────┐
       │ button         period                                │
       │ press          |     |                               │
       │   ||      __    __    __    __    __    _            │
       │   ||     |  |  |  |  |  |  |  |  |  |   magnitude    │
       │   \/     |  |__|  |__|  |__|  |__|  |   _            │
       │     -----                                            │
       │       |            offset?                           │
       │     delay          phase?                            │
       │                                                      │
       │ -------------------------------------                │
       │               length                                 │
       │ ===================================================  │
       │                       interval                       │
       └──────────────────────────────────────────────────────┘

       type may be one of the following:

       ┌──────────────────────────┬──────────────────────────────┐
       │ SDL_HAPTIC_SINE          │   __      __      __      __ │
       │                          │  /  \    /  \    /  \    /   │
       │                          │ /    \__/    \__/    \__/    │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_HAPTIC_TRIANGLE      │   /\    /\    /\    /\    /\ │
       │                          │  /  \  /  \  /  \  /  \  /   │
       │                          │ /    \/    \/    \/    \/    │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_HAPTIC_SAWTOOTHUP    │   /|  /|  /|  /|  /|  /|  /| │
       │                          │  / | / | / | / | / | / | / | │
       │                          │ /  |/  |/  |/  |/  |/  |/  | │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_HAPTIC_SAWTOOTHDOWN  │ \  |\  |\  |\  |\  |\  |\  | │
       │                          │  \ | \ | \ | \ | \ | \ | \ | │
       │                          │   \|  \|  \|  \|  \|  \|  \| │
       └──────────────────────────┴──────────────────────────────┘

       phase  is  given  by  hundredths  of a degree, meaning that giving the phase a
       value of 9000 will displace it 25% of its period. Here are sample values:

       ┌────────┬──────────────────────────────┐
       │ 0      │ No phase displacement        │
       ├────────┼──────────────────────────────┤
       │ 9000   │ Displaced 25% of its period  │
       ├────────┼──────────────────────────────┤
       │ 18000  │ Displaced 50% of its period  │
       ├────────┼──────────────────────────────┤
       │ 27000  │ Displaced 76% of its period  │
       ├────────┼──────────────────────────────┤
       │ 36000  │ Displaced 100%  of  its  pe‐ │
       │        │ riod,  same  as  0, but 0 is │
       │        │ preferred                    │
       └────────┴──────────────────────────────┘

RELATED STRUCTURES
       SDL_HapticDirection

RELATED FUNCTIONS
       SDL_HapticNewEffect

===============================================================================
                                                              *SDL_HapticQuery*


NAME
       SDL_HapticQuery -- Function

SYNOPSIS
       Use  this  function  to  get the haptic device's supported features in bitwise
       manner.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ unsigned int SDL_HapticQuery(SDL_Haptic*    haptic)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the  SDL_Haptic  device   to │
       │         │ query                        │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  a list of supported haptic features in bitwise manner (OR'd), or 0 on
       failure; call SDL_GetError() fore more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────┐
       │ extern SDL_Haptic* haptic;                          │
       │ if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT)  │
       │ {                                                   │
       │   SDL_Log("We have constant haptic effect!");       │
       │ }                                                   │
       └─────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticEffectSupported
       SDL_HapticNumEffects

===============================================================================
                                                               *SDL_HapticRamp*


NAME
       SDL_HapticRamp -- Structure

SYNOPSIS
       A structure that contains a template for a ramp effect.

DATA FIELDS
       ┌──────────────────────────────────────────────────────────────┐
       │                           Header                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ type          │ SDL_HAPTIC_RAMP       │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ SDL_HapticDirection  │ direction     │ direction  of the ef‐ │
       │                      │               │ fect                  │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Replay                             │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint32               │ length        │ duration of  the  ef‐ │
       │                      │               │ fect                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ delay         │ delay before starting │
       │                      │               │ the effect            │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                           Trigger                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ button        │ button that  triggers │
       │                      │               │ the effect            │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ interval      │ how  soon  it  can be │
       │                      │               │ triggered again after │
       │                      │               │ button                │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                            Ramp                              │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Sint16               │ start         │ beginning    strength │
       │                      │               │ level                 │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Sint16               │ end           │ ending strength level │
       ├──────────────────────┴───────────────┴───────────────────────┤
       │                          Envelope                            │
       ├──────────────────────┬───────────────┬───────────────────────┤
       │ Uint16               │ attack_length │ duration of  the  at‐ │
       │                      │               │ tack                  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ attack_level  │ level at the start of │
       │                      │               │ the attack            │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ fade_length   │ duration of the fade  │
       ├──────────────────────┼───────────────┼───────────────────────┤
       │ Uint16               │ fade_level    │ level at the  end  of │
       │                      │               │ the fade              │
       └──────────────────────┴───────────────┴───────────────────────┘

REMARKS
       This struct is exclusively for the SDL_HAPTIC_RAMP effect.

       The ramp effect starts at start strength and ends at end strength. It augments
       in linear fashion. If you use attack and fade with  a  ramp  the  effects  get
       added to the ramp effect making the effect become quadratic instead of linear.

RELATED STRUCTURES
       SDL_HapticDirection

RELATED FUNCTIONS
       SDL_HapticNewEffect

===============================================================================
                                                         *SDL_HapticRumbleInit*


NAME
       SDL_HapticRumbleInit -- Function

SYNOPSIS
       Use this function to initialize the haptic device for simple rumble playback.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ int SDL_HapticRumbleInit(SDL_Haptic*    haptic)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the  haptic  device  to ini‐ │
       │         │ tialize  for  simple  rumble │
       │         │ playback                     │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticOpen
       SDL_HapticRumblePlay
       SDL_HapticRumbleStop
       SDL_HapticRumbleSupported

===============================================================================
                                                         *SDL_HapticRumblePlay*


NAME
       SDL_HapticRumblePlay -- Function

SYNOPSIS
       Use this function to run a simple rumble effect on a haptic device.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_HapticRumblePlay(SDL_Haptic*    haptic,    │
       │                          float          strength,  │
       │                          Uint32         length)    │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ haptic    │ the  haptic  device  to play │
       │           │ the rumble effect on         │
       ├───────────┼──────────────────────────────┤
       │ strength  │ strength of  the  rumble  to │
       │           │ play as 0-1 float value      │
       ├───────────┼──────────────────────────────┤
       │ length    │ length of the rumble to play │
       │           │ in milliseconds              │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       fore more information.

RELATED FUNCTIONS
       SDL_HapticRumbleInit
       SDL_HapticRumbleStop
       SDL_HapticRumbleSupported

===============================================================================
                                                         *SDL_HapticRumbleStop*


NAME
       SDL_HapticRumbleStop -- Function

SYNOPSIS
       Use this function to stop the simple rumble on a haptic device.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_HapticRumbleStop(SDL_Haptic* haptic)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the  haptic  device  to stop │
       │         │ the runble effect on         │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more informatin.

RELATED FUNCTIONS
       SDL_HapticRumbleInit
       SDL_HapticRumblePlay
       SDL_HapticRumbleSupported

===============================================================================
                                                    *SDL_HapticRumbleSupported*


NAME
       SDL_HapticRumbleSupported -- Function

SYNOPSIS
       Use this function to check whether rumble is supported on a haptic device

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_HapticRumbleSupported(SDL_Haptic*   haptic)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ haptic  device  to check for │
       │         │ rumble support               │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a  negative
       error code on failure; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────┐
       │ extern SDL_Haptic* dev;                   │
       │ if (SDL_HapticRumbleSupported(dev)) {     │
       │   SDL_HapticRumbleInit(dev);              │
       │   SDL_HapticRumblePlay(dev, 1.0f, 3000);  │
       │   SDL_Delay(3000);                        │
       │ }                                         │
       └───────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_HapticRumbleInit
       SDL_HapticRumblePlay
       SDL_HapticRumbleStop

===============================================================================
                                                          *SDL_HapticRunEffect*


NAME
       SDL_HapticRunEffect -- Function

SYNOPSIS
       Use this function to run the haptic effect on its associated haptic device.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_HapticRunEffect(SDL_Haptic*   haptic,      │
       │                         int           effect,      │
       │                         Uint32        iterations)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────┬──────────────────────────────┐
       │ haptic      │ the SDL_Haptic device to run │
       │             │ the effect on                │
       ├─────────────┼──────────────────────────────┤
       │ effect      │ the identifier of the haptic │
       │             │ effect to run                │
       ├─────────────┼──────────────────────────────┤
       │ iterations  │ the  number of iterations to │
       │             │ run the effect; use SDL_HAP‐ │
       │             │ TIC_INFINITY for infinity    │
       └─────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure call; call SDL_GetEr‐
       ror() for more information.

REMARKS
       If iterations are SDL_HAPTIC_INFINITY, it'll run the effect over and over  re‐
       peating the envelope (attack and fade) every time. If you only want the effect
       to last forever, set SDL_HAPTIC_INFINITY in the effect's length parameter.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticDestroyEffect
       SDL_HapticGetEffectStatus
       SDL_HapticStopEffect

===============================================================================
                                                      *SDL_HapticSetAutocenter*


NAME
       SDL_HapticSetAutocenter -- Function

SYNOPSIS
       Use this function to set the global autocenter of the device.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_HapticSetAutocenter(SDL_Haptic*   haptic,      │
       │                             int           autocenter)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────┬──────────────────────────────┐
       │ haptic      │ the SDL_Haptic device to set │
       │             │ autocentering on             │
       ├─────────────┼──────────────────────────────┤
       │ autocenter  │ value to set  autocenter  to │
       │             │ (0-100), 0 disables autocen‐ │
       │             │ tering; see Remarks for  de‐ │
       │             │ tails                        │
       └─────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Autocenter should be between 0 and 100. Setting it to 0 will disable  autocen‐
       tering.

RELATED FUNCTIONS
       SDL_HapticQuery

===============================================================================
                                                            *SDL_HapticSetGain*


NAME
       SDL_HapticSetGain -- Function

SYNOPSIS
       Use this function to set the global gain of the specified haptic device.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ int SDL_HapticSetGain(SDL_Haptic*   haptic,  │
       │                       int           gain)    │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the SDL_Haptic device to set │
       │         │ the gain on                  │
       ├─────────┼──────────────────────────────┤
       │ gain    │ value to set  the  gain  to, │
       │         │ should  be between 0 and 100 │
       │         │ (0-100)                      │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       Device must support the SDL_HAPTIC_GAIN feature.

       The  user  may  specify  the  maximum gain by setting the environment variable
       SDL_HAPTIC_GAIN_MAX which should be between 0 and 100. All calls  to  SDL_Hap‐
       ticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the maximum.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticQuery

===============================================================================
                                                            *SDL_HapticStopAll*


NAME
       SDL_HapticStopAll -- Function

SYNOPSIS
       Use this function to stop all currently playing effects on a haptic device.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ int SDL_HapticStopAll(SDL_Haptic* haptic)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the   SDL_Haptic  device  to │
       │         │ stop                         │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

===============================================================================
                                                         *SDL_HapticStopEffect*


NAME
       SDL_HapticStopEffect -- Function

SYNOPSIS
       Use this function to stop the haptic effect on its associated haptic device.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ int SDL_HapticStopEffect(SDL_Haptic*    haptic,  │
       │                          int            effect)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the   SDL_Haptic  device  to │
       │         │ stop the effect on           │
       ├─────────┼──────────────────────────────┤
       │ effect  │ the identifier of the haptic │
       │         │ effect to stop               │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_HapticDestroyEffect
       SDL_HapticRunEffect

===============================================================================
                                                            *SDL_HapticUnpause*


NAME
       SDL_HapticUnpause -- Function

SYNOPSIS
       Use this function to unpause a haptic device.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ int SDL_HapticUnpause(SDL_Haptic*   haptic)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the SDL_Haptic device to un‐ │
       │         │ pause                        │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       Call to unpause after SDL_HapticPause().

RELATED FUNCTIONS
       SDL_HapticPause

===============================================================================
                                                       *SDL_HapticUpdateEffect*


NAME
       SDL_HapticUpdateEffect -- Function

SYNOPSIS
       Use this function to update the properties of an effect.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ int SDL_HapticUpdateEffect(SDL_Haptic*          haptic,  │
       │                            int                  effect,  │
       │                            SDL_HapticEffect*    data)    │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ haptic  │ the  SDL_Haptic  device that │
       │         │ has the effect               │
       ├─────────┼──────────────────────────────┤
       │ effect  │ the identifier of the effect │
       │         │ to update                    │
       ├─────────┼──────────────────────────────┤
       │ data    │ an  SDL_HapticEffect  struc‐ │
       │         │ ture containing the new  ef‐ │
       │         │ fect to properties to use    │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Can be used dynamically, although behavior when dynamically changing direction
       may be strange. Specifically the effect may re-upload itself and start playing
       from the start. You also cannot change the type either when  running  SDL_Hap‐
       ticUpdateEffect().

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticDestroyEffect
       SDL_HapticNewEffect
       SDL_HapticRunEffect

===============================================================================
                                                                 *SDL_Has3DNow*


NAME
       SDL_Has3DNow -- Function

SYNOPSIS
       Use this function to determine whether the CPU has 3DNow! features.

SYNTAX
       ┌──────────────────────────────┐
       │ SDL_bool SDL_Has3DNow(void)  │
       └──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has 3DNow! features or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_HasAlticVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_HasSSE2
       SDL_HasSSE3
       SDL_HasSSE41
       SDL_HasSSE42

===============================================================================
                                                                   *SDL_HasAVX*


NAME
       SDL_HasAVX -- Function

SYNOPSIS
       Use this function to determine whether the CPU has AVX features.

SYNTAX
       ┌────────────────────────────┐
       │ SDL_bool SDL_HasAVX(void)  │
       └────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has AVX features or SDL_FALSE if not.

VERSION
       This function is available since SDL 2.0.2.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltVec
       SDL_HasAVX2
       SDL_HasMMX
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_SSE2
       SDL_SSE3
       SDL_HasSSE41
       SDL_HasSSE42

===============================================================================
                                                                  *SDL_HasAVX2*


NAME
       SDL_HasAVX2 -- Function

SYNOPSIS
       Use this function to determine whether the CPU has AVX2 features.

SYNTAX
       ┌─────────────────────────────┐
       │ SDL_bool SDL_HasAVX2(void)  │
       └─────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has AVX2 features or SDL_FALSE if not.

VERSION
       This function is available since SDL 2.0.4.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltiVec
       SDL_HasAVX
       SDL_HasMMX
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_HasSSE2
       SDL_HasSSE3
       SDL_HasSSE41
       SDL_HasSSE42

===============================================================================
                                                               *SDL_HasAltiVec*


NAME
       SDL_HasAltiVec -- Function

SYNOPSIS
       Use this function to determine whether the CPU has AltiVec features.

SYNTAX
       ┌────────────────────────────────┐
       │ SDL_bool SDL_HasAltiVec(void)  │
       └────────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has AltiVec features or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_HasAlticVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasMMX
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_HasSSE2
       SDL_HasSSE3
       SDL_HasSSE41
       SDL_HasSSE42

===============================================================================
                                                         *SDL_HasClipboardText*


NAME
       SDL_HasClipboardText -- Function

SYNOPSIS
       Use  this  function  to get a flag indicating whether the clipboard exists and
       contains a text string that is non-empty.

SYNTAX
       ┌──────────────────────────────────────┐
       │ SDL_bool SDL_HasClipboardText(void)  │
       └──────────────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the clipboard has text, or SDL_FALSE if it does not.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetClipboardText
       SDL_SetClipboardText

===============================================================================
                                                                 *SDL_HasEvent*


NAME
       SDL_HasEvent -- Function

SYNOPSIS
       Use  this  function  to  check for the existence of certain event types in the
       event queue.

SYNTAX
       ┌────────────────────────────────────────┐
       │ SDL_bool SDL_HasEvent(Uint32    type)  │
       └────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ type  │ the  type  of  event  to  be │
       │       │ queried;  see  SDL_EventType │
       │       │ for details                  │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if events matching type are present, or SDL_FALSE  if  events
       matching type are not present.

REMARKS
       If you need to check for a range of event types, use SDL_HasEvents() instead.

RELATED FUNCTIONS
       SDL_HasEvents

===============================================================================
                                                                *SDL_HasEvents*


NAME
       SDL_HasEvents -- Function

SYNOPSIS
       Use  this function to check for the existence of a range of event types in the
       event queue.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ SDL_bool SDL_HasEvents(Uint32   minType,  │
       │                        Uint3    maxType)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ minType  │ the minimum type of event to │
       │          │ be  queried;  see SDL_Event‐ │
       │          │ Type for details             │
       ├──────────┼──────────────────────────────┤
       │ maxType  │ the maximum type of event to │
       │          │ be  queried;  see SDL_Event‐ │
       │          │ Type for details             │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if events with types in the range between minType and maxType
       are present, SDL_FALSE if not.

REMARKS
       If  you  need to check for a single event type, you can use SDL_HasEvent() in‐
       stead.

RELATED FUNCTIONS
       SDL_HasEvent

===============================================================================
                                                          *SDL_HasIntersection*


NAME
       SDL_HasIntersection -- Function

SYNOPSIS
       Use this function to determine whether two rectangles intersect.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ SDL_bool SDL_HasIntersection(const SDL_Rect*    A,  │
       │                              const SDL_Rect*    B)  │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ A  │ an SDL_Rect structure repre‐ │
       │    │ senting the first rectangle  │
       ├────┼──────────────────────────────┤
       │ B  │ an SDL_Rect structure repre‐ │
       │    │ senting the second rectangle │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.

REMARKS
       If either pointer is NULL the function will return SDL_FALSE.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_IntersectRect

===============================================================================
                                                                   *SDL_HasMMX*


NAME
       SDL_HasMMX -- Function

SYNOPSIS
       Use this function to determine whether the CPU has MMX features.

SYNTAX
       ┌────────────────────────────┐
       │ SDL_bool SDL_HasMMX(void)  │
       └────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has MMX features or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltiVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_HasSSE2
       SDL_HasSSE3
       SDL_HasSSE41
       SDL_HasSSE42

===============================================================================
                                                                 *SDL_HasRDTSC*


NAME
       SDL_HasRDTSC -- Function

SYNOPSIS
       Use this function to determine whether the CPU has the RDTSC instruction.

SYNTAX
       ┌──────────────────────────────┐
       │ SDL_bool SDL_HasRDTSC(void)  │
       └──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has the RDTSC instruction or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltiVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasMMX
       SDL_HasSSE
       SDL_HasSSE2
       SDL_HasSSE3
       SDL_HasSSE41
       SDL_HasSSE42

===============================================================================
                                                                   *SDL_HasSSE*


NAME
       SDL_HasSSE -- Function

SYNOPSIS
       Use this function to determine whether the CPU has SSE features.

SYNTAX
       ┌────────────────────────────┐
       │ SDL_bool SDL_HasSSE(void)  │
       └────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has SSE features or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltiVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasMMX
       SDL_HasRDTSC
       SDL_HasSSE2
       SDL_HasSSE3
       SDL_HasSSE41
       SDL_HasSSE42

===============================================================================
                                                                  *SDL_HasSSE2*


NAME
       SDL_HasSSE2 -- Function

SYNOPSIS
       Use this function to determine whether the CPU has SSE2 features.

SYNTAX
       ┌─────────────────────────────┐
       │ SDL_bool SDL_HasSSE2(void)  │
       └─────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has SSE2 features or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltiVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasMMX
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_HasSSE3
       SDL_HasSSe41
       SDL_HasSSE42

===============================================================================
                                                                  *SDL_HasSSE3*


NAME
       SDL_HasSSE3 -- Function

SYNOPSIS
       Use this function to determine whether the CPU has SSE3 features.

SYNTAX
       ┌─────────────────────────────┐
       │ SDL_bool SDL_HasSSE3(void)  │
       └─────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has SSE3 features or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltiVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasMMX
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_HasSSE2
       SDL_HasSSe41
       SDL_HasSSE42

===============================================================================
                                                                 *SDL_HasSSE41*


NAME
       SDL_HasSSE41 -- Function

SYNOPSIS
       Use this function to determine whether the CPU has SSE4.1 features.

SYNTAX
       ┌──────────────────────────────┐
       │ SDL_bool SDL_HasSSE41(void)  │
       └──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has SSE41 features or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltiVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasMMX
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_HasSSE2
       SDL_HasSSE3
       SDL_HasSSE42

===============================================================================
                                                                 *SDL_HasSSE42*


NAME
       SDL_HasSSE42 -- Function

SYNOPSIS
       Use this function to determine whether the CPU has SSE4.2 features.

SYNTAX
       ┌──────────────────────────────┐
       │ SDL_bool SDL_HasSSE42(void)  │
       └──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the CPU has SSE42 features or SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_Has3DNow
       SDL_HasAltiVec
       SDL_HasAVX
       SDL_HasAVX2
       SDL_HasMMX
       SDL_HasRDTSC
       SDL_HasSSE
       SDL_HasSSE2
       SDL_HasSSE3
       SDL_HasSSE41

===============================================================================
                                                 *SDL_HasScreenKeyboardSupport*


NAME
       SDL_HasScreenKeyboardSupport -- Function

SYNOPSIS
       Use  this function to check whether the platform has some screen keyboard sup‐
       port.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ SDL_bool SDL_HasScreenKeyboardSupport(void)  │
       └──────────────────────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the platform has some screen keyboard support or SDL_FALSE
       if not.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_StartTextInput

===============================================================================
                                                               *SDL_HideWindow*


NAME
       SDL_HideWindow -- Function

SYNOPSIS
       Use this function to hide a window.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_HideWindow(SDL_Window*   window)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬────────────────────┐
       │ window  │ the window to hide │
       └─────────┴────────────────────┘

RELATED FUNCTIONS
       SDL_ShowWindow

===============================================================================
                                                             *SDL_HintPriority*


NAME
       SDL_HintPriority -- Enumerations

SYNOPSIS
       An enumeration of hint priorities.

DESCRIPTION
       Values

       ┌────────────────────┬──────────────────────────────┐
       │ SDL_HINT_DEFAULT   │ low  priority,  used for de‐ │
       │                    │ fault values                 │
       ├────────────────────┼──────────────────────────────┤
       │ SDL_HINT_NORMAL    │ medium priority              │
       ├────────────────────┼──────────────────────────────┤
       │ SDL_HINT_OVERRIDE  │ high priority                │
       └────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_SetHintWithPriority

===============================================================================
                                                            *SDL_HitTestResult*


NAME
       SDL_HitTestResult -- Enumerations

SYNOPSIS
       An enumeration of possible return values from the SDL_SetWindowHitTest() call‐
       back.

DESCRIPTION
       Values

       ┌─────────────────────────────────┬──────────────────────────────┐
       │ SDL_HITTEST_NORMAL              │ region is normal and has  no │
       │                                 │ special properties           │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_DRAGGABLE           │ region  can drag entire win‐ │
       │                                 │ dow                          │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_RESIZE_TOPLEFT      │ region can resize  top  left │
       │                                 │ window                       │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_RESIZE_TOP          │ region can resize top window │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_TOPRIGHT            │ region  can resize top right │
       │                                 │ window                       │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_RESIZE_RIGHT        │ region can resize right win‐ │
       │                                 │ dow                          │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_RESIZE_BOTTOMRIGHT  │ region   can  resize  bottom │
       │                                 │ right window                 │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_RESIZE_BOTTOM       │ region  can  resize   bottom │
       │                                 │ window                       │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_RESIZE_BOTTOMLEFT   │ region   can  resize  bottom │
       │                                 │ left window                  │
       ├─────────────────────────────────┼──────────────────────────────┤
       │ SDL_HITTEST_RESIZE_LEFT         │ region can resize left  win‐ │
       │                                 │ dow                          │
       └─────────────────────────────────┴──────────────────────────────┘

VERSION
       This enumeration is available since SDL 2.0.4

RELATED FUNCTIONS
       SDL_SetWindowHitTest

===============================================================================
                                                                     *SDL_Init*


NAME
       SDL_Init - API

SYNOPSIS
       int SDL_Init(Uint32 flags)

DESCRIPTION
       Use  this  function  to initialize the SDL library. This must be called before
       using most other SDL functions.

REMARKS
       SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the  two
       may  be used interchangeably. Though for readability of your code SDL_InitSub‐
       System() might be preferred.

       The file I/O and threading subsystem are intitialized  by  default.  You  must
       specifically initialize other subsystems if you use them in your application.

       Logging works without initialization too.

       flags may be any of the following OR'd together.

           SDL_INIT_TIMER timer subsystem
           SDL_INIT_AUDIO audio subsystem
           SDL_INIT_VIDEO  video subsystem; automatically initializes the events sub‐
           system
           SDL_INIT_JOYSTICK joystick subsystem; automatically initializes the events
           subsystem
           SDL_INIT_HAPTIC haptic (force feedback) subsystem
           SDL_INIT_GAMECONTROLLER  controller  subsystem; automatically intitializes
           the joystick subsystem
           SDL_INIT_EVENTS events subsytem
           SDL_INIT_EVERYTHING all of the above subsystems
           SDL_INIT_NOPARACHUTE compatibility; this flag is ignored

       If you want to initialize subsystems separately  you  would  call  SDL_Init(0)
       followed by SDL_InitSubSystem() with the desired subsystem flag.

SEE ALSO
       SDL_InitSubSystem, SDL_Quit, SDL_SetMainReady, SDL_WasInit

===============================================================================
                                                            *SDL_InitSubSystem*


NAME
       SDL_InitSubSystem -- Function

SYNOPSIS
       Use this function to initialize specific SDL subsystems.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ int SDL_InitSubSystem(Uint32    flags)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ flags  │ any  of  the  flags  used by │
       │        │ SDL_Init(); see Remarks  for │
       │        │ detials                      │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0  on  success  or  a negative error code on failure; call SDL_GetEr‐
       ror()ffor more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────┐
       │ /* Separating Joystick and Video initialization. */          │
       │ SDL_Init(SDL_INIT_VIDEO);                                    │
       │                                                              │
       │ SDL_Window* window = SDL_CreateWindow("A Window",            │
       │   SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,          │
       │   640, 480, SDL_WINDOW_FULLSCREEN);                          │
       │ SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, 0);  │
       │                                                              │
       │ /* Do some video stuff */                                    │
       │ SDL_InitSubSystem(SDL_INIT_JOYSTICK);                        │
       │                                                              │
       │ /* Do some stuff with video and joystick */                  │
       │                                                              │
       │ /* Shut them both down */                                    │
       │ SDL_Quit();                                                  │
       └──────────────────────────────────────────────────────────────┘

REMARKS
       After SDL has been initialized with SDL_Init() you may initialize unintialized
       subsystems with SDL_InitSubSystem().

       These are the flags which may be passed to SDL_InitSubSystem() and may be OR'd
       together to initialize multiple subsystems simultaneously.

       ┌──────────────────────────┬──────────────────────────────┐
       │ SDL_INIT_TIMER           │ time subsystem               │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_AUDIO           │ audio subsystem              │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_VIDEO           │ video  subsystem;  automati‐ │
       │                          │ cally initializes the events │
       │                          │ subsystem                    │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_JOYSTICK        │ joystick subsystem; automat‐ │
       │                          │ ically    initializes    the │
       │                          │ events subsystem             │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_HAPTIC          │ haptic (force feedback) sub‐ │
       │                          │ system                       │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_GAMECONTROLLER  │ controller  subsystem; auto‐ │
       │                          │ matically  initializes   the │
       │                          │ joystick subsystem           │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_EVENTS          │ events subsystem             │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_EVERYTHING      │ all of the above subsystems  │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_NOPARACHUTE     │ compatibility;  this flag is │
       │                          │ ignored                      │
       └──────────────────────────┴──────────────────────────────┘

       SDL_Init()  initializes  assertions  and  crash  protection  and  then   calls
       SDL_InitSubSystems().  If  you  want  to bypass those protections you can call
       SDL_InitSubSystem() directly.

       Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem() for
       each  SDL_InitSubSystem()  to correctly shutdown a subsystem manually (or call
       SDL_Quit() to force shutdown). If a subsystem is already loaded then this call
       will increase the ref-count and return.

RELATED FUNCTIONS
       SDL_Init
       SDL_Quit
       SDL_QuitSubSystem

===============================================================================
                                                            *SDL_IntersectRect*


NAME
       SDL_IntersectRect -- Function

SYNOPSIS
       Use this function to calculate the intersection of two rectangles.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_IntersectRect(const SDL_Rect*    A,       │
       │                            const SDL_Rect*    B,       │
       │                            SDL_Rect*          result)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ A  │ an SDL_Rect structure repre‐ │
       │    │ senting the first rectangle  │
       ├────┼──────────────────────────────┤
       │ B  │ an SDL_Rect structure repre‐ │
       │    │ senting the second rectangle │
       ├────┼──────────────────────────────┤
       │ C  │ an SDL_Rect structure filled │
       │    │ in with the intersection  of │
       │    │ rectangles A and B           │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.

REMARKS
       If result is NULL then this function will return SDL_FALSE.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HasIntersection

===============================================================================
                                                     *SDL_IntersectRectAndLine*


NAME
       SDL_IntersectRectAndLine -- Function

SYNOPSIS
       Use  this  function to calculate the intersection of a rectangle and line seg‐
       ment.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_IntersectRectAndLine(const SDL_Rect*   rect,  │
       │                                   int*              X1,    │
       │                                   int*              Y1,    │
       │                                   int*              X2,    │
       │                                   int*              Y2)    │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ rect  │ an SDL_Rect structure repre‐ │
       │       │ senting the rectangle to in‐ │
       │       │ tersect                      │
       ├───────┼──────────────────────────────┤
       │ X1    │ a pointer to the starting X- │
       │       │ coordinate of the line       │
       ├───────┼──────────────────────────────┤
       │ Y1    │ a pointer to the starting Y- │
       │       │ coordinate of the line       │
       ├───────┼──────────────────────────────┤
       │ X2    │ a pointer to the  ending  X- │
       │       │ coordinate of the line       │
       ├───────┼──────────────────────────────┤
       │ Y2    │ a  pointer  to the ending Y- │
       │       │ coordinate of the line       │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.

REMARKS
       This function is used to clip a line segment to a rectangle.  A  line  segment
       contained entirely within the rectangle or that does not intersect will remain
       unchanged. A line segment that crosses the rectangle at either  or  both  ends
       will be clipped to the boundary of the rectangle and the new coordinates saved
       in X1, Y1, X2, and/or Y2 as necessary.

===============================================================================
                                                         *SDL_IsGameController*


NAME
       SDL_IsGameController -- Function

SYNOPSIS
       Use this function to check if the given joystick is supported by the game con‐
       troller interface.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ SDL_bool SDL_IsGameController(int joystick_index)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ joystick_index  │ the device_index  of  a  de‐ │
       │                 │ vice,   up   to  SDL_NumJoy‐ │
       │                 │ sticks()                     │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the given joystick is supported by the game controller in‐
       terface, SDL_FALSE if it isn't or it's an invalid index.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────┐
       │ for (int i=0; i<SDL_NumJoysticks(); ++i)                                        │
       │ {                                                                               │
       │   if (SDL_IsGameController(i))                                                  │
       │   {                                                                             │
       │     printf("Joystick %i is supported by the game controller interface!\n", i);  │
       │   }                                                                             │
       │ }                                                                               │
       └─────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       joystick_index is the same as the device_index passed to SDL_JoystickOpen().

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GameControllerNameForIndex
       SDL_GameControllerOpen

===============================================================================
                                                    *SDL_IsScreenKeyboardShown*


NAME
       SDL_IsScreenKeyboardShown -- Function

SYNOPSIS
       Use this function to check whether the screen keyboard is shown for given win‐
       dow.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_IsScreenKeyboardShown(SDL_Window*    window)  │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window for which  screen │
       │         │ keyboard should be quried    │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HasScreenKeyboardSuport

===============================================================================
                                                     *SDL_IsScreenSaverEnabled*


NAME
       SDL_IsScreenSaverEnabled -- Function

SYNOPSIS
       Use this function to check whether the screensaver is currently enabled.

SYNTAX
       ┌──────────────────────────────────────────┐
       │ SDL_bool SDL_IsScreenSaverEnabled(void)  │
       └──────────────────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is enabled.

REMARKS
       The  screensaver  is disabled by default since SDL 2.0.2. Before SDL 2.0.2 the
       screensaver was enabled by default.

       The default can also be changed using SDL_HINT_VIDEO_ALLOW_SCREENSAVER.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_DisableScreenSaver
       SDL_EnableScreenSaver

===============================================================================
                                                        *SDL_IsTextInputActive*


NAME
       SDL_IsTextInputActive -- Function

SYNOPSIS
       Use  this  function  to check whether or not Unicode text input events are en‐
       abled.

SYNTAX
       ┌───────────────────────────────────────┐
       │ SDL_bool SDL_IsTextInputActive(void)  │
       └───────────────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if text input events are enabled else SDL_FALSE.

REMARKS
       There is a tutorial (https://wiki.libsdl.org/Tutorials/TextInput).

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_StartTextInput

===============================================================================
                                                             *SDL_JoyAxisEvent*


NAME
       SDL_JoyAxisEvent -- Structure

SYNOPSIS
       A structure that contains joystick axis motion event information.

DATA FIELDS
       ┌─────────────────┬───────────┬───────────────────────┐
       │ Uint32          │ type      │ SDL_JOYAXISMOTION     │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint32          │ timestamp │ timestamp    of   the │
       │                 │           │ event                 │
       ├─────────────────┼───────────┼───────────────────────┤
       │ SDL_JoystickID  │ which     │ the  instance  id  of │
       │                 │           │ the joystick that re‐ │
       │                 │           │ ported the event      │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ axis      │ the index of the axis │
       │                 │           │ that changed          │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Sint16          │ value     │ the  current position │
       │                 │           │ of the  axis  (range: │
       │                 │           │ -32768 to 32767)      │
       └─────────────────┴───────────┴───────────────────────┘

REMARKS
       SDL_JoyAxisEvent  is a member of the SDL_Event union and is used when an event
       of type SDL_JOYAXISMOTION is reported. You would access it through the event's
       jaxis field.

       An  SDL_JOYAXISMOTION  event  occurs whenever a user moves an axis on the joy‐
       stick.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_JoyBallEvent
       SDL_JoyButtonEvent
       SDL_JoyHatEvent

RELATED FUNCTIONS
       SDL_JoystickEventState
       SDL_JoystickGetAxis

===============================================================================
                                                             *SDL_JoyBallEvent*


NAME
       SDL_JoyBallEvent -- Structure

SYNOPSIS
       A structure that contains joystick trackball motion event information.

DATA FIELDS
       ┌─────────────────┬───────────┬───────────────────────┐
       │ Uint32          │ type      │ SDL_JOYBALLMOTION     │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint32          │ timestamp │ timestamp    of   the │
       │                 │           │ event                 │
       ├─────────────────┼───────────┼───────────────────────┤
       │ SDL_JoystickID  │ which     │ the  instance  id  of │
       │                 │           │ the joystick that re‐ │
       │                 │           │ ported the event      │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ ball      │ the  index   of   the │
       │                 │           │ trackball        that │
       │                 │           │ changed               │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Sint16          │ xrel      │ the  relative  motion │
       │                 │           │ in the X direction    │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Sint16          │ yrel      │ the  relative  motion │
       │                 │           │ in the Y direction    │
       └─────────────────┴───────────┴───────────────────────┘

REMARKS
       SDL_JoyBallEvent is a member of the SDL_Event union and is used when an  event
       of type SDL_JOYBALLMOTION is reported. You would access it through the event's
       jball field.

       An SDL_JOYBALLMOTION event occurs when a user moves a trackball  on  the  joy‐
       stick.

       Trackballs  only return relative motion. This is the change in position of the
       ball since it was last polled (last cycle of the event loop).

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_JoyAxisEvent
       SDL_JoyButtonEvent
       ISDL_JoyHatEvent

===============================================================================
                                                           *SDL_JoyButtonEvent*


NAME
       SDL_JoyButtonEvent -- Structure

SYNOPSIS
       A structure that contains joystick button event information.

DATA FIELDS
       ┌─────────────────┬───────────┬───────────────────────┐
       │ Uint32          │ type      │ the     event    type │
       │                 │           │ SDL_JOYBUTTONDOWN  or │
       │                 │           │ SDL_JOYBUTTONUP       │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint32          │ timestamp │ timestamp    of   the │
       │                 │           │ event                 │
       ├─────────────────┼───────────┼───────────────────────┤
       │ SDL_JoystickID  │ which     │ the  instance  id  of │
       │                 │           │ the joystick that re‐ │
       │                 │           │ ported the event      │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ button    │ the index of the but‐ │
       │                 │           │ ton that changed      │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ state     │ the state of the but‐ │
       │                 │           │ ton;  SDL_PRESSED  or │
       │                 │           │ SDL_RELEASED          │
       └─────────────────┴───────────┴───────────────────────┘

REMARKS
       SDL_JoyButtonEvent  is  a  member  of  the SDL_Event union and is used when an
       event of type SDL_JOYBUTTONDOWN or SDL_JOYBUTTONUP is reported. You would  ac‐
       cess it through the event's jbutton field.

       An  SDL_JOYBUTTONDOWN  or SDL_JOYBUTTONUP event occurs whenever a user presses
       or releases a button on a joystick.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_JoyAxisEvent
       SDL_JoyBallEvent
       SDL_JoyHatEvent

RELATED FUNCTIONS
       SDL_JoystickEventState
       SDL_JoystickGetButton

===============================================================================
                                                           *SDL_JoyDeviceEvent*


NAME
       SDL_JoyDeviceEvent -- Structure

SYNOPSIS
       A structure that contains joystick device event information.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ SDL_JOYDEVICEADDED or │
       │         │           │ SDL_JOYDEVICEREMOVED  │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ the timestamp of  the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ which     │ the  joystick  device │
       │         │           │ index     for     the │
       │         │           │ SDL_JOYDEVICEADDED    │
       │         │           │ event or the instance │
       │         │           │ id for the SDL_JOYDE‐ │
       │         │           │ VICEREMOVED event     │
       └─────────┴───────────┴───────────────────────┘

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

RELATED FUNCTIONS
       SDL_JoystickOpen

===============================================================================
                                                              *SDL_JoyHatEvent*


NAME
       SDL_JoyHatEvent -- Structure

SYNOPSIS
       A structure that contains joystick hat position change event information.

DATA FIELDS
       ┌─────────────────┬───────────┬───────────────────────┐
       │ Uint32          │ type      │ SDL_JOYHATMOTION      │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint32          │ timestamp │ timestamp    of   the │
       │                 │           │ event                 │
       ├─────────────────┼───────────┼───────────────────────┤
       │ SDL_JoystickID  │ which     │ the  instance  id  of │
       │                 │           │ the joystick that re‐ │
       │                 │           │ ported the event      │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ hat       │ the index of the  hat │
       │                 │           │ that changed          │
       ├─────────────────┼───────────┼───────────────────────┤
       │ Uint8           │ value     │ the  new  position of │
       │                 │           │ the hat; see  Remarks │
       │                 │           │ for details           │
       └─────────────────┴───────────┴───────────────────────┘

REMARKS
       SDL_JoyHatEvent  is  a member of the SDL_Event union and is used when an event
       of type SDL_JOYHATMOTION is reportedl. You would access it through the event's
       jhat field.

       An SDL_JOYHATMOTION event occurs whenever a user moves a hat on the joystickk.

       value may be one of the following:

       ┌───────────────────┬──────────────────┬───────────────────┐
       │ SDL_HAT_LEFTUP    │ SDL_HAT_UP       │ SDL_HAT_RIGHTUP   │
       ├───────────────────┼──────────────────┼───────────────────┤
       │ SDL_HAT_LEFT      │ SDL_HAT_CENTERED │ SDL_HAT_RIGHT     │
       ├───────────────────┼──────────────────┼───────────────────┤
       │ SDL_HAT_LEFTDOWN  │ SDL_HAT_DOWN     │ SDL_HAT_RIGHTDOWN │
       └───────────────────┴──────────────────┴───────────────────┘

       Note that zero means the POV is centered.

RELATED ENUMERATIONS
       SDL_EventType

RELATAED STRUCTURES
       SDL_Event
       SDL_JoyAxisEvent
       SDL_JoyBallEvent
       SDL_JoyButtonEvent

RELATED FUNCTIONS
       SDL_JoystickEventState
       SDL_JoystickGetHat

===============================================================================
                                                            *SDL_JoystickClose*


NAME
       SDL_JoystickClose -- Function

SYNOPSIS
       Use  this  function  to  close a joystick previously opened with SDL_Joystick‐
       Open().

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ void SDL_JoystickClose(SDL_Joystick* joystick)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an  SDL_Joystick   structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       └───────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_JoystickOpen

===============================================================================
                                                *SDL_JoystickCurrentPowerLevel*


NAME
       SDL_JoystickCurrentPowerLevel -- Function

SYNOPSIS
       Use this function to get the battery level of a joystick as SDL_JoystickPower‐
       Level.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_JoystickPowerLevel SDL_JoystickCurrentPowerLevel(SDL_Joystick*    joystick)  │
       └──────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬───────────────────────────┐
       │ joystick  │ the SDL_Joystick to query │
       └───────────┴───────────────────────────┘

RETURN VALUE
       Returns the current library level  as  SDL_JoystickPowerLevel  on  success  or
       SDL_JOYSTICK_POWER_UNKONOWN if it is unknown; call SDL_GetError() for more in‐
       formation.

VERSION
       This function is available since SDL 2.0.4.

===============================================================================
                                                       *SDL_JoystickEventState*


NAME
       SDL_JoystickEventState -- Function

SYNOPSIS
       Use this function to enable/disable joystick event polling.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ int SDL_JoystickEventState(int    state)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ state  │ can  be  one  of  SDL_QUERY, │
       │        │ SDL_IGNORE, or SDL_ENABLE    │
       └────────┴──────────────────────────────┘
       Note: You may use -1, 0, or 1 in place of SDL_QUERY, SDL_IGNORE, or SDL_ENABLE
       respectively.

RETURN VALUE
       Returns 1 if enabled, 0 if disabled, or a negative error code on failure; call
       SDL_GetError() for more information.

       If state is SDL_QUERY then the current state is returned,  otherwise  the  new
       processing state is returned.

CODE EXAMPLE
       ┌───────────────────────────────────────────────────────────────────────┐
       │ printf("%i\n", SDL_JoystickEventState(SDL_QUERY)); /* prints 1 */     │
       │ printf("%i\n", SDL_JoystickEventState(SDL_IGNORE));  /*  prints 0 */  │
       │ printf("%i\n", SDL_JoystickEventState(SDL_QUERY)); /* prints 0 */     │
       └───────────────────────────────────────────────────────────────────────┘

REMARKS
       If  joystick  events are disabled, you must call SDL_JoystickUpdate() yourself
       and manually check the state of the joystick when you want  joystick  informa‐
       tion.

       Note: It is recommended that you leave joystick event handling enabled.

       WARNING:  Calling this function may delete all events currently in SDL's event
       queue.

RELATED FUNCTIONS
       SDL_GetControllerEventState

===============================================================================
                                                   *SDL_JoystickFromInstanceID*


NAME
       SDL_JoystickFromInstanceID -- Function

SYNOPSIS
       Use this function to get the SDL_Joystick associated with an instance id.

SYNTAX
       ┌───────────────────────────────────────────────────────────────────┐
       │ SDL_Joystick* SDL_JoystickFromInstanceID(SDL_JoystickID   joyid)  │
       └───────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ joyid  │ the  instance  id to ge tthe │
       │        │ SDL_Joystick for             │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns an SDL_Joystick on success or NULL on failure; call SDL_GetError() for
       more information.

VERSION
       This function is available since SDL 2.0.4.

===============================================================================
                                                      *SDL_JoystickGetAttached*


NAME
       SDL_JoystickGetAttached -- Function

SYNOPSIS
       Use this function to get the status of specified joystick.

SYNTAX
       ┌──────────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_JoystickGetAttached(SDL_Joystick*    joystick)  │
       └──────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬───────────────────────┐
       │ joystick  │ the joystick to query │
       └───────────┴───────────────────────┘

RETURN VALUE
       Returns  SDL_TRUE  if the joystick has been opened, SDL_FALSE if has not; call
       SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_JoystickClose
       SDL_JoystickOpen

===============================================================================
                                                          *SDL_JoystickGetAxis*


NAME
       SDL_JoystickGetAxis -- Function

SYNOPSIS
       Use this function to get the current state of an axis control on a joystick.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ Sint16 SDL_JoystickGetAxis(SDL_Joystick*    joystick,  │
       │                            int              axis)      │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an   SDL_Joystick  structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       ├───────────┼──────────────────────────────┤
       │ axis      │ the  axis to query; the axis │
       │           │ indices start  at  index  0; │
       │           │ see Remarks for details      │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  a 16-bit signed integer representing the current position of the axis
       or 0 on failure; call SDL_GetError() for more information.

       The state is a value ranging from -32768 to 32767.

CODE EXAMPLES
       ┌─────────────────────────────────────────┐
       │ extern SDL_Joystick*  joy1;             │
       │ Sint16  x_move, y_move;                 │
       │                                         │
       │ x_move = SDL_JoystickGetAxis(joy1, 0);  │
       │ y_move = SDL_JoystickGetAxis(joy1, 1);  │
       └─────────────────────────────────────────┘

REMARKS
       On most modern joysticks the X axis is usually represented by axis 0 and the Y
       axis  by axis 1. The value returned by SDL_JoystickGetAxis() is a signed inte‐
       ger (-32768 to 32767) representing the current position of the axis. It may be
       necessary to impose certain tolerances on these values to account for jitter.

       Some joysticks use axes 2 and 3 for extra buttons.

RELATED FUNCTIONS
       SDL_JoystickNumAxes

===============================================================================
                                                          *SDL_JoystickGetBall*


NAME
       SDL_JoystickGetBall -- Function

SYNOPSIS
       Use this function to get the ball axis change since the last poll.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_JoystickGetBall(SDL_Joystick*   joystick,  │
       │                         int             ball,      │
       │                         int*            dx,        │
       │                         int*            dy)        │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ the SDL_Joystick to query    │
       ├───────────┼──────────────────────────────┤
       │ ball      │ the  ball  index  to  query; │
       │           │ ball indices start at  index │
       │           │ 0                            │
       ├───────────┼──────────────────────────────┤
       │ dx        │ the difference in the x axis │
       │           │ position since the last poll │
       ├───────────┼──────────────────────────────┤
       │ dy        │ the difference in the y axis │
       │           │ position since the last poll │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       fore more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────┐
       │ int delta_x, delta_y;                                       │
       │ SDL_Joystick* joy;                                          │
       │ SDL_JoystickUpdate();                                       │
       │ if (SDL_JoystickGetBall(joy, 0, &delta_x, &delta_y) == -1)  │
       │ {                                                           │
       │   printf("TrackBall Read Error!\n");                        │
       │ }                                                           │
       │ printf("TrackBall Delta X:%d, Y:%d\n", delta_x, delta_y);   │
       └─────────────────────────────────────────────────────────────┘

REMARKS
       Trackballs can only return relative motion since the  last  call  to  SDL_Joy‐
       stickGetBall(), these motion deltas are placed into dx and dy.

RELATED FUNCTIONS
       SDL_JoystickNumBalls

===============================================================================
                                                        *SDL_JoystickGetButton*


NAME
       SDL_JoystickGetButton -- Function

SYNOPSIS
       Use this function to get the current state of a button on a joystick.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ Uint8 SDL_JoystickGetButton(SDL_Joystick*   joystick,  │
       │                             int             button)    │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an   SDL_Joystick  structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       ├───────────┼──────────────────────────────┤
       │ button    │ the  button index to get the │
       │           │ state from; indices start at │
       │           │ index 0                      │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 if the specified button is pressed, 0 otherwise.

RELATED FUNCTIONS
       SDL_JoystickNumButtons

===============================================================================
                                                    *SDL_JoystickGetDeviceGUID*


NAME
       SDL_JoystickGetDeviceGUID -- Function

SYNOPSIS
       Use this function to get the implementation-dependent GUID for the joystick at
       a given device index.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ SDL_JoysickGUID SDL_JoystickGetDeviceGUID(int   device_index)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ device_index  │ the index of the joystick to │
       │               │ query  (the N'th joystick on │
       │               │ the system)                  │
       └───────────────┴──────────────────────────────┘

REMARKS
       This function can be called before any joysticks are opened.

RELATED FUNCTIONS
       SDL_JoystickGetGUID
       SDL_JoystickGetGUIDString

===============================================================================
                                                          *SDL_JoystickGetGUID*


NAME
       SDL_JoystickGetGUID -- Function

SYNOPSIS
       Use this function to get the implementation-dependent GUID for the joystick.

SYNTAX
       ┌──────────────────────────────────────────────────────────────┐
       │ SDL_Joystick SDL_JoystickGetGUID(SDL_Joystick*    joystick)  │
       └──────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────┐
       │ joystick  │ an open joystick │
       └───────────┴──────────────────┘

RETURN VALUE
       Returns  the  GUID  of the given joystick. If called on an invalid index, this
       function returns a zero GUID; call SDL_GetError() for more information.

REMARKS
       This function requires an open joystick.

RELATED FUNCTIONS
       SDL_JoystickGetDeviceID
       SDL_JoystickGetGUIDString

===============================================================================
                                                *SDL_JoystickGetGUIDFromString*


NAME
       SDL_JoystickGetGUIDFromString -- Function

SYNOPSIS
       Use this function to convert a GUID string into a SDL_JoystickGUID structure.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────────────┐
       │ SDL_JoystickGUID SDL_JoystickGetGUIDFromString(const char*    pchGUID)  │
       └─────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ pchGUID  │ string  containing  an ASCII │
       │          │ representation of a GUID     │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns a SDL_JoystickGUID structure.

REMARKS
       Performs no error checking. If this function is given a string  containing  an
       invalid  GUID, the function will silently succeed, but the GUID generated will
       not be useful.

RELATED FUNCTIONS
       SDL_JoystickGetGUIDString

===============================================================================
                                                    *SDL_JoystickGetGUIDString*


NAME
       SDL_JoystickGetGUIDString -- Function

SYNOPSIS
       Use  this  function to get an ASCII string representation for a given SDL_Joy‐
       stickGUID.

SYNTAX
       ┌─────────────────────────────────────────────────────────────┐
       │ void SDL_JoystickGetGUIDString(SDL_JoystickGUID   guid,     │
       │                                char*              pszGUID,  │
       │                                int                cbGUID)   │
       └─────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ guid     │ the   SDL_JoystickGUID   you │
       │          │ wish to convert to string    │
       ├──────────┼──────────────────────────────┤
       │ pszGUID  │ buffer in which to write the │
       │          │ ASCII string                 │
       ├──────────┼──────────────────────────────┤
       │ cbGUID   │ the size of pszGUID          │
       └──────────┴──────────────────────────────┘

REMARKS
       You should supply at least 33 bytes for pszGUID.

RELATED FUNCTIONS
       SDL_JoystickGetDeviceGUID
       SDL_JoystickGetGUID
       SDL_JoystickGetGUIDFromString

===============================================================================
                                                           *SDL_JoystickGetHat*


NAME
       SDL_JoystickGetHat -- Function

SYNOPSIS
       Use this function to get the current state of a POV hat on a joystick.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ Uint8 SDL_JoystickGetHat(SDL_Joystick*    joystick,  │
       │                          int              hat)       │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an   SDL_Joystick  structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       ├───────────┼──────────────────────────────┤
       │ hat       │ the  hat  index  to  get the │
       │           │ state  from;   hat   indices │
       │           │ start at index 0             │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns one of the following positions:

       ┌────────────────────┐
       │ SDL_HAT_CENTERED   │
       ├────────────────────┤
       │ SDL_HAT_UP         │
       ├────────────────────┤
       │ SDL_HAT_RIGHT      │
       ├────────────────────┤
       │ SDL_HAT_DOWN       │
       ├────────────────────┤
       │ SDL_HAT_LEFT       │
       ├────────────────────┤
       │ SDL_HAT_RIGHTUP    │
       ├────────────────────┤
       │ SDL_HAT_RIGHTDOWN  │
       ├────────────────────┤
       │ SDL_HAT_LEFTUP     │
       ├────────────────────┤
       │ SDL_HAT_LEFTDOWN   │
       └────────────────────┘

       ┌───────────────────┬────────────────────┬─────────────────────┐
       │ SDL_HAT_LEFTUP    │  SDL_HAT_UP        │  SDL_HAT_RIGHTUP    │
       ├───────────────────┼────────────────────┼─────────────────────┤
       │ SDL_HAT_LEFT      │  SDL_HAT_CENTERED  │  SDL_HAT_RIGHT      │
       ├───────────────────┼────────────────────┼─────────────────────┤
       │ SDL_HAT_LEFTDOWN  │  SDL_HAT_DOWN      │  SDL_HAT_RIGHTDOWN  │
       └───────────────────┴────────────────────┴─────────────────────┘

RELATED FUNCTIONS
       SDL_JoystickNumHats

===============================================================================
                                                            *SDL_JoystickIndex*


NAME
       SDL_JoystickIndex - Get the index of an SDL_Joystick.

SYNOPSIS
       #include "SDL.h"

       int SDL_JoystickIndex(SDL_Joystick *joystick);

DESCRIPTION
       Returns the index of a given SDL_Joystick structure.

RETURN VALUE
       Index number of the joystick.

SEE ALSO
       SDL_JoystickOpen

===============================================================================
                                                       *SDL_JoystickInstanceID*


NAME
       SDL_JoystickInstanceID -- Function

SYNOPSIS
       Use this function to get the instance ID of an opened joystick.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ SDL_JoystickID SDL_JoystickInstanceID(SDL_Joystick* joystick)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an   SDL_Joystick  structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns the instance ID of the specified joystick on success or a negative er‐
       ror code on failure; call SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_JoystickOpen

===============================================================================
                                                         *SDL_JoystickIsHaptic*


NAME
       SDL_JoystickIsHaptic -- Function

SYNOPSIS
       Use this function to check to see if a joystick has haptic features.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_JoystickIsHaptic(SDL_Joystick*    joystick)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ the SDL_Joystick to test for │
       │           │ haptic capabilities          │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't, or a  nega‐
       tive error code on failure; call SDL_GetError().

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticOpenFromJoystick

===============================================================================
                                                             *SDL_JoystickName*


NAME
       SDL_JoystickName -- Function

SYNOPSIS
       Use this function to get the implementation dependent name of a joystick.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ const char* SDL_JoystickName(SDL_Joystick*    joystick)  │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ the   SDL_Joystick  obtained │
       │           │ from SDL_JoystickOpen()      │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns the name of the selected joystick. If no name can be found, this func‐
       tion returns NULL; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────┐
       │ /* Print the names of all attached joysticks */  │
       │ int num_joy, i;                                  │
       │ num_joy = SDL_NumJoysticks();                    │
       │ printf("%d joysticks found\n", num_joy);         │
       │ for (i = 0; i < num_joy; ++i)                    │
       │ {                                                │
       │   SDL_Joystick *joystick = SDL_JoystickOpen(i);  │
       │   printf("%s\n", SDL_JoystickName(joystick));    │
       │ }                                                │
       └──────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_JoystickNameForIndex
       SDL_JoystickOpen

===============================================================================
                                                     *SDL_JoystickNameForIndex*


NAME
       SDL_JoystickNameForIndex -- Function

SYNOPSIS
       Use this function to get the implementation dependent name of a joystick.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ const char* SDL_JoystickNameForIndex(int    device_index)  │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ device_index  │ the index of the joystick to │
       │               │ query (the N'the joystick on │
       │               │ the system)                  │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the name of the selected joystick. If no name can be found, this func‐
       tion returns NULL; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────┐
       │ /* Print the names of all attached joysticks */  │
       │ int num_joy, i;                                  │
       │ num_joy = SDL_NumJoysticks();                    │
       │ printf("%d joysticks found\n", num_joy);         │
       │ for (i = 0; i < num_joy; ++i)                    │
       │ {                                                │
       │   printf("%s\n", SDL_JoystickNameForIndex(i));   │
       │ }                                                │
       └──────────────────────────────────────────────────┘

REMARKS
       This can be called before any joysticks are opened.

RELATED FUNCTIONS
       SDL_JoystickName
       SDL_JoystickOpen

===============================================================================
                                                          *SDL_JoystickNumAxes*


NAME
       SDL_JoystickNumAxes -- Function

SYNOPSIS
       Use this function to get the number of general axis controls on a joystick.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_JoystickNumAxes(SDL_Joystick*   joystick)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an   SDL_Joystick  structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the  number  of axis controls/number of axes on success or a negative
       error code on failure; call SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_JoystickGetAxis
       SDL_JoystickOpen

===============================================================================
                                                         *SDL_JoystickNumBalls*


NAME
       SDL_JoystickNumBalls -- Function

SYNOPSIS
       Use this function to get the number of trackballs on a joystick.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_JoystickNumBalls(SDL_Joystick*    joystick)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an   SDL_Joystick  structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the number of trackballs on success or a negative error code on fail‐
       ure; call SDL_GetError() for more information.

REMARKS
       Joystick trackballs have only relative motion events associated with them  and
       their state cannot be polled.

RELATED FUNCTIONS
       SDL_JoystickGetBall

===============================================================================
                                                       *SDL_JoystickNumButtons*


NAME
       SDL_JoystickNumButtons -- Function

SYNOPSIS
       Use this function to get the number of buttons on a joystick.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_JoystickNumButtons(SDL_Joystick*    joystick)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an   SDL_Joystick  structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       └───────────┴──────────────────────────────┘

REMARKS
       Returns  the  number  of buttons on success or negative error code on failure;
       call SDL_GetErorr() for more information.

RELATED FUNCTIONS
       SDL_JoystickGetButton
       SDL_JoystickOpen

===============================================================================
                                                          *SDL_JoystickNumHats*


NAME
       SDL_JoystickNumHats -- Function

SYNOPSIS
       Use this function to get the number of POV hats on a joystick.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_JoystickNumHats(SDL_Joystick*   joystick)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ joystick  │ an   SDL_Joystick  structure │
       │           │ containing joystick informa‐ │
       │           │ tion                         │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns the number of POV hats on success or a negative error code on failure;
       call SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_JoystickGetHat
       SDL_JoystickOpen

===============================================================================
                                                             *SDL_JoystickOpen*


NAME
       SDL_JoystickOpen -- Function

SYNOPSIS
       Use this function to open a joystick for use.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ SDL_Joystick* SDL_JoystickOpen(int device_index)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ device_index  │ the index of the joystick to │
       │               │ query                        │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns a joystick identifier or NULL if an error  occurred;  call  SDL_GetEr‐
       ror() for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────┐
       │ SDL_Joystick *joy;                                                 │
       │                                                                    │
       │ // Initialize the joystick subsystem                               │
       │ SDL_InitSubSystem(SDL_INIT_JOYSTICK);                              │
       │                                                                    │
       │ // Check for joystick                                              │
       │ if (SDL_NumJoysticks() > 0)                                        │
       │ {                                                                  │
       │   // Open joystick                                                 │
       │   joy = SDL_JoystickOpen(0);                                       │
       │                                                                    │
       │   if (joy)                                                         │
       │   {                                                                │
       │     printf("Opened Joystick 00);                                   │
       │     printf("Name: %s0, SDL_JoystickNameForIndex(joy));             │
       │     printf("Number of Axes: %d0, SDL_JoystickNumAxes(joy));        │
       │     printf("Number of Buttons: %d0, SDL_JoystickNumButtons(joy));  │
       │     printf("Number of Balls: %d0, SDL_JoystickNumBalls(joy));      │
       │   }                                                                │
       │   else                                                             │
       │   {                                                                │
       │     printf("Couldn't open Joystick 00);                            │
       │   }                                                                │
       │                                                                    │
       │   // Close if opened                                               │
       │   if (SDL_JoystickGetAttached(joy))                                │
       │   {                                                                │
       │     SDL_JoystickClose(joy);                                        │
       │   }                                                                │
       │ }                                                                  │
       └────────────────────────────────────────────────────────────────────┘

REMARKS
       The  device_index  passed as an argument refers to the N'th joystick presently
       recognized by SDL on the system. It is NOT the same as the instance ID used to
       identify  the joystick in future events. See SDL_JoystickInstanceID() for more
       details about instance IDs.

       The joystick subsystem must be initialized befeore a joystick  can  be  opened
       for use.

RELATED FUNCTIONS
       SDL_JoystickClose
       SDL_JoystickInstanceID

===============================================================================
                                                           *SDL_JoystickOpened*


NAME
       SDL_JoystickOpened - Determine if a joystick has been opened

SYNOPSIS
       #include "SDL.h"

       int SDL_JoystickOpened(int index);

DESCRIPTION
       Determines  whether a joystick has already been opened within the application.
       index refers to the N'th joystick on the system.

RETURN VALUE
       Returns 1 if the joystick has been opened, or 0 if it has not.

SEE ALSO
       SDL_JoystickOpen, SDL_JoystickClose

===============================================================================
                                                       *SDL_JoystickPowerLevel*


NAME
       SDL_JoystickPowerLevel -- Enumerations

SYNOPSIS
       An enumeration of battery levels of a joystick.

DESCRIPTION
       Values

       ┌─────────────────────────────┬────┐
       │ SDL_JOYSTICK_POWER_UNKNOWN  │ -- │
       ├─────────────────────────────┼────┤
       │ SDL_JOYSTICK_POWER_EMPTY    │ -- │
       ├─────────────────────────────┼────┤
       │ SDL_JOYSTICK_POWER_LOW      │ -- │
       ├─────────────────────────────┼────┤
       │ SDL_JOYSTICK_POWER_MEDIUM   │ -- │
       ├─────────────────────────────┼────┤
       │ SDL_JOYSTICK_POWER_FULL     │ -- │
       ├─────────────────────────────┼────┤
       │ SDL_JOYSTICK_POWER_WIRED    │ -- │
       ├─────────────────────────────┼────┤
       │ SDL_JOYSTICK_POWER_MAX      │ -- │
       └─────────────────────────────┴────┘

VERSION
       This enumeration is available since SDL 2.0.4

RELATED FUNCTIONS
       SDL_JoystickCurrentPowerLevel

===============================================================================
                                                           *SDL_JoystickUpdate*


NAME
       SDL_JoystickUpdate -- Function

SYNOPSIS
       Use this function to update the current state of the open joysticks.

SYNTAX
       ┌────────────────────────────────┐
       │ void SDL_JoystickUpdate(void)  │
       └────────────────────────────────┘

REMARKS
       This  is called automatically by the event loop if any joystick events are en‐
       abled.

RELATED FUNCTIONS
       SDL_JoystickEventState

===============================================================================
                                                            *SDL_KeyboardEvent*


NAME
       SDL_KeyboardEvent -- Structure

SYNOPSIS
       A structure that contains keyboard button event information.

DATA FIELDS
       ┌─────────────┬───────────┬───────────────────────┐
       │ Uint32      │ type      │ the    event    type; │
       │             │           │ SDL_KEYDOWN        or │
       │             │           │ SDL_KEYUP             │
       ├─────────────┼───────────┼───────────────────────┤
       │ Uint32      │ timestamp │ timestamp    of   the │
       │             │           │ event                 │
       ├─────────────┼───────────┼───────────────────────┤
       │ Uint32      │ windowID  │ the window with  key‐ │
       │             │           │ board focus, if any   │
       ├─────────────┼───────────┼───────────────────────┤
       │ Uint8       │ state     │ the state of the key; │
       │             │           │ SDL_PRESSED        or │
       │             │           │ SDL_RELEASED          │
       ├─────────────┼───────────┼───────────────────────┤
       │ Uint8       │ repeat    │ non-zero if this is a │
       │             │           │ key repeat            │
       ├─────────────┼───────────┼───────────────────────┤
       │ SDL_Keysym  │ keysym    │ the SDL_Keysym repre‐ │
       │             │           │ senting  the key that │
       │             │           │ was  pressed  or  re‐ │
       │             │           │ leased                │
       └─────────────┴───────────┴───────────────────────┘

REMARKS
       SDL_KeyboardEvent is a member of the SDL_Event union and is used when an event
       of type SDL_KEYDOWN or SDL_KEYUP is reported. You would access it through  the
       event's key field.

       An SDL_KEYDOWN or SDL_KEYUP event occurs whenever a user presses or releases a
       button on a keyboard. The information on what key was pressed or  released  is
       in the keysym member.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

RELATED FUNCTIONS
       SDL_GetKeyboardState
       SDL_GetModState

===============================================================================
                                                                  *SDL_Keycode*


NAME
       SDL_Keycode -- Enumerations

SYNOPSIS
       The SDL virtual key representation.

DESCRIPTION
       Values

       ┌────────────────────────┬─────────────────────────────────┬─────────────────────────┐
       │       Key Name         │       SDL_Scancode Value        │    SDL_Keycode Value    │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "0"                    │ SDL_SCANCODE_0                  │ SDLK_0                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "1"                    │ SDL_SCANCODE_1                  │ SDLK_1                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "2"                    │ SDL_SCANCODE_2                  │ SDLK_2                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "3"                    │ SDL_SCANCODE_3                  │ SDLK_3                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "4"                    │ SDL_SCANCODE_4                  │ SDLK_4                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "5"                    │ SDL_SCANCODE_5                  │ SDLK_5                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "6"                    │ SDL_SCANCODE_6                  │ SDLK_6                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "7"                    │ SDL_SCANCODE_7                  │ SDLK_7                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "8"                    │ SDL_SCANCODE_8                  │ SDLK_8                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "9"                    │ SDL_SCANCODE_9                  │ SDLK_9                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "A"                    │ SDL_SCANCODE_A                  │ SDLK_a                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AC  Back"  (the Back  │ SDL_SCANCODE_AC_BACK            │ SDLK_AC_BACK            │
       │ key (application con‐  │                                 │                         │
       │ trol keypad))          │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AC  Bookmarks"  (the  │ SDL_SCANCODE_AC_BOOKMARKS       │ SDLK_AC_BOOKMARKS       │
       │ Bookmarks key (appli‐  │                                 │                         │
       │ cation  control  key‐  │                                 │                         │
       │ pad))                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AC   Forward"   (the  │ SDL_SCANCODE_AC_FORWARD         │ SDLK_AC_FORWARD         │
       │ Forward key (applica‐  │                                 │                         │
       │ tion control keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AC Home"  (the  Home  │ SDL_SCANCODE_AC_HOME            │ SDLK_AC_HOME            │
       │ key (application con‐  │                                 │                         │
       │ trol keypad))          │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AC Refresh" (the Re‐  │ SDL_SCANCODE_AC_REFRESH         │ SDLK_AC_REFRESH         │
       │ fresh  key  (applica‐  │                                 │                         │
       │ tion control keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AC   Search"    (the  │ SDL_SCANCODE_AC_SEARCH          │ SDLK_AC_SEARCH          │
       │ Search  key (applica‐  │                                 │                         │
       │ tion control keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AC Stop"  (the  Stop  │ SDL_SCANCODE_AC_STOP            │ SDLK_AC_STOP            │
       │ key (application con‐  │                                 │                         │
       │ trol keypad))          │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Again"  (the   Again  │ SDL_SCANCODE_AGAIN              │ SDLK_AGAIN              │
       │ key (Redo))            │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AltErase"    (Erase-  │ SDL_SCANCODE_ALTERASE           │ SDLK_ALTERASE           │
       │ Eaze)                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""                     │ SDL_SCANCODE_APOSTROPHE         │ SDLK_QUOTE              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Application"    (the  │ SDL_SCANCODE_APPLICATION        │ SDLK_APPLICATION        │
       │ Application / Compose  │                                 │                         │
       │ / Context Menu  (Win‐  │                                 │                         │
       │ dows) key)             │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AudioMute" (the Mute  │ SDL_SCANCODE_AUDIOMUTE          │ SDLK_AUDIOMUTE          │
       │ volume key)            │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AudioNext" (the Next  │ SDL_SCANCODE_AUDIONEXT          │ SDLK_AUDIONEXT          │
       │ Track media key)       │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AudioPlay" (the Play  │ SDL_SCANCODE_AUDIOPLAY          │ SDLK_AUDIOPLAY          │
       │ media key)             │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AudioPrev" (the Pre‐  │ SDL_SCANCODE_AUDIOPREV          │ SDLK_AUDIOPREV          │
       │ vious   Track   media  │                                 │                         │
       │ key)                   │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "AudioStop" (the Stop  │ SDL_SCANCODE_AUDIOSTOP          │ SDLK_AUDIOSTOP          │
       │ media key)             │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "B"                    │ SDL_SCANCODE_B                  │ SDLK_a                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "\"  (Located  at the  │ SDL_SCANCODE_BACKSLASH          │ SDLK_BACKSLASH          │
       │ lower left of the re‐  │                                 │                         │
       │ turn  key on ISO key‐  │                                 │                         │
       │ boards  and  at   the  │                                 │                         │
       │ right  end of the QW‐  │                                 │                         │
       │ ERTY row on ANSI key‐  │                                 │                         │
       │ boards.  Produces RE‐  │                                 │                         │
       │ VERSE SOLIDUS  (back‐  │                                 │                         │
       │ slash)  and  VERTICAL  │                                 │                         │
       │ LINE in a US  layout,  │                                 │                         │
       │ REVERSE  SOLIDUS  and  │                                 │                         │
       │ VERTICAL LINE in a UI  │                                 │                         │
       │ Mac   Layout,  NUMBER  │                                 │                         │
       │ SIGN and TILDE  in  a  │                                 │                         │
       │ UK   WIndows  layout,  │                                 │                         │
       │ DOLLAR SIGN and POUND  │                                 │                         │
       │ SIGN  in a Swiss Ger‐  │                                 │                         │
       │ man  layout,   NUMBER  │                                 │                         │
       │ SIGN  and  APOSTROPHE  │                                 │                         │
       │ in a  German  layout,  │                                 │                         │
       │ GRAVE    ACCENT   and  │                                 │                         │
       │ POUNG   SIGN   in   a  │                                 │                         │
       │ French   Mac  layout,  │                                 │                         │
       │ and ASTERISK and  MI‐  │                                 │                         │
       │ CRO  SIGN in a French  │                                 │                         │
       │ Windows layout)        │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Backsapce"            │ SDL_SCANCODE_BACKSPACE          │ SDLK_BACKSPACE          │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "BrightnessDown" (the  │ SDL_SCANCODE_BRIGHTNESSDOWN     │ SDLK_BRIGHTNESSDOWN     │
       │ Brightness Down key)   │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "BrightnessUp"   (the  │ SDL_SCANCODE_BRIGHTNESSUP       │ SDLK_BRIGHTNESSUP       │
       │ Brightness Up key)     │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "C"                    │ SDL_SCANCODE_C                  │ SDLK_c                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Calculator"     (the  │ SDL_SCANCODE_CALCULATOR         │ SDLK_CALCULATOR         │
       │ Calculator key)        │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Cancel"               │ SDL_SCANCODE_CANCEL             │ SDLK_CANCEL             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "CapsLock"             │ SDL_SCANCODE_CAPSLOCK           │ SDLK_CAPSLOCK           │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Clear"                │ SDL_SCANCODE_CLEAR              │ SDLK_CLEAR              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Clear / Again"        │ SDL_SCANCODE_CLEARAGAIN         │ SDLK_CLEARAGAIN         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ","                    │ SDL_SCANCODE_COMMA              │ SDLK_COMMA              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Computer"   (the  My  │ SDL_SCANCODE_COMPUTER           │ SDLK_COMPUTER           │
       │ Computer key)          │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Copy"                 │ SDL_SCANCODE_COPY               │ SDLK_COPY               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "CrSel"                │ SDL_SCANCODE_CRSEL              │ SDLK_CRSEL              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "CurrencySubUnit"      │ SDL_SCANCODE_CURRENCYSUBUNIT    │ SDLK_CURRENCYSUBUNIT    │
       │ (the   Currency  Sub‐  │                                 │                         │
       │ unit)                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "CurrcencyUnit"  (the  │ SDL_SCANCODE_CURRENCYUNIT       │ SDLK_CURRENCYUNIT       │
       │ Currency Unit key)     │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Cut"                  │ SDL_SCANCODE_CUT                │ SDLK_CUT                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "D"                    │ SDL_SCANCODE_D                  │ SDLK_d                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "DecimalSeparator"     │ SDL_SCANCODE_DECIMALSEPARATOR   │ SDLK_DECIMALSEPARATOR   │
       │ (the Decimal  Separa‐  │                                 │                         │
       │ tor key)               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Delete"               │ SDL_SCANCODE_DELETE             │ SDLK_DELETE             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "DisplaySwitch" (dis‐  │ SDL_SCANCODE_DISPLAYSWITCH      │ SDLK_DISPLAYSWITCH      │
       │ play   mirroring/dual  │                                 │                         │
       │ display switch, video  │                                 │                         │
       │ mode switch)           │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Down" (the Down  ar‐  │ SDL_SCANCODE_DOWN               │ SDLK_DOWN               │
       │ row  key  (navigation  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "E"                    │ SDL_SCANCODE_E                  │ SDLK_e                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Eject"  (the   Eject  │ SDL_SCANCODE_EJECT              │ SDLK_EJECT              │
       │ key)                   │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "End"                  │ SDL_SCANCODE_END                │ SDLK_END                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "="                    │ SDL_SCANCODE_EQUALS             │ SDLK_EQUALS             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Escape"   (the   Esc  │ SDL_SCANCODE_ESCAPE             │ SDLK_ESCAPE             │
       │ key)                   │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Execute"              │ SDL_SCANCODE_EXECUTE            │ SDLK_EXECUTE            │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "ExSel"                │ SDL_SCANCODE_EXSEL              │ SDLK_EXSEL              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F"                    │ SDL_SCANCODE_F                  │ SDLK_f                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F1"                   │ SDL_SCANCODE_F1                 │ SDLK_F1                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F10"                  │ SDL_SCANCODE_F10                │ SDLK_F10                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F11"                  │ SDL_SCANCODE_F11                │ SDLK_F11                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F12"                  │ SDL_SCANCODE_F12                │ SDLK_F12                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F13"                  │ SDL_SCANCODE_F13                │ SDLK_F13                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F14"                  │ SDL_SCANCODE_F14                │ SDLK_F14                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F15"                  │ SDL_SCANCODE_F15                │ SDLK_F15                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F16"                  │ SDL_SCANCODE_F16                │ SDLK_F16                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F17"                  │ SDL_SCANCODE_F17                │ SDLK_F17                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F18"                  │ SDL_SCANCODE_F18                │ SDLK_F18                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F19"                  │ SDL_SCANCODE_F19                │ SDLK_F19                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F2"                   │ SDL_SCANCODE_F2                 │ SDLK_F2                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F20"                  │ SDL_SCANCODE_F20                │ SDLK_F20                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F21"                  │ SDL_SCANCODE_F21                │ SDLK_F21                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F22"                  │ SDL_SCANCODE_F22                │ SDLK_F22                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F23"                  │ SDL_SCANCODE_F23                │ SDLK_F23                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F24"                  │ SDL_SCANCODE_F24                │ SDLK_F24                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F3"                   │ SDL_SCANCODE_F3                 │ SDLK_F3                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F4"                   │ SDL_SCANCODE_F4                 │ SDLK_F4                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F5"                   │ SDL_SCANCODE_F5                 │ SDLK_F5                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F6"                   │ SDL_SCANCODE_F6                 │ SDLK_F6                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F7"                   │ SDL_SCANCODE_F7                 │ SDLK_F7                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F8"                   │ SDL_SCANCODE_F8                 │ SDLK_F8                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "F9"                   │ SDL_SCANCODE_F9                 │ SDLK_F9                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Find"                 │ SDL_SCANCODE_FIND               │ SDLK_FIND               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "G"                    │ SDL_SCANCODE_G                  │ SDLK_g                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "`" (Located  at  the  │ SDL_SCANCODE_GRAVE              │ SDLK_BACKQUOTE          │
       │ top  left  corner (on  │                                 │                         │
       │ both  ANSI  and   ISO  │                                 │                         │
       │ keyboards).  Produces  │                                 │                         │
       │ GRAVE   ACCENT    and  │                                 │                         │
       │ TILDE in a US Windows  │                                 │                         │
       │ layoutl and in US and  │                                 │                         │
       │ UK   Mac  layouts  on  │                                 │                         │
       │ ANSI keyboards, GRAVE  │                                 │                         │
       │ ACCENT  and  NOT SIGN  │                                 │                         │
       │ in a UK Windows  lay‐  │                                 │                         │
       │ out, SECTION SIGN and  │                                 │                         │
       │ PLUS-MINUS SIGN in US  │                                 │                         │
       │ and UK Mac layouts on  │                                 │                         │
       │ IOS  keyboards,  SEC‐  │                                 │                         │
       │ TION  SIGN and DEGREE  │                                 │                         │
       │ SIGNB in a Swiss Ger‐  │                                 │                         │
       │ man layout (Mac: only  │                                 │                         │
       │ on  ISO   keyboards),  │                                 │                         │
       │ CIRCUMFLEX ACCENT and  │                                 │                         │
       │ DEGREE SIGN in a Ger‐  │                                 │                         │
       │ man layout (Mac: only  │                                 │                         │
       │ on  ISO   keyboards),  │                                 │                         │
       │ SUPERSCRIPT  TWO  and  │                                 │                         │
       │ TILDE  in  a   French  │                                 │                         │
       │ Windows  layout, COM‐  │                                 │                         │
       │ MERCIAL AT and NUMBER  │                                 │                         │
       │ SIGN  in a French Mac  │                                 │                         │
       │ layout  on  ISO  key‐  │                                 │                         │
       │ boards, and LESS-THAN  │                                 │                         │
       │ SIGN and GREATER-THAN  │                                 │                         │
       │ SIGN  in a Swiss Ger‐  │                                 │                         │
       │ man,    German,    or  │                                 │                         │
       │ French  Mac layout on  │                                 │                         │
       │ ANSI keyboards)        │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "H"                    │ SDL_SCANCODE_H                  │ SDLK_h                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Help"                 │ SDL_SCANCODE_HELP               │ SDLK_HELP               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Home"                 │ SDL_SCANCODE_HOME               │ SDLK_HOME               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "I"                    │ SDL_SCANCODE_I                  │ SDLK_i                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Insert"  (insert  on  │ SDL_SCANCDOE_INSERT             │ SDLK_INSERT             │
       │ PC,  help on some Mac  │                                 │                         │
       │ keyboards  (but  does  │                                 │                         │
       │ send   code  73,  not  │                                 │                         │
       │ 117))                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "J"                    │ SDL_SCANCODE_J                  │ SDLK_j                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "K"                    │ SDL_SCANCODE_K                  │ SDLK_k                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "KBDIllumDown"   (the  │ SDL_SCANCODE_KBDILLUMDOWN       │ SDLK_KBDILLUMDOWN       │
       │ Keyboard Illumination  │                                 │                         │
       │ Down key)              │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "KBDIllumToggle" (the  │ SDL_SCANCODE_KBDILLUMTOGGLE     │ SDLK_KBDILLUMTOGGLE     │
       │ Keyboard Illumination  │                                 │                         │
       │ Toggle key)            │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "KBDIllumUp"     (the  │ SDL_SCANCODE_KBDILLUMUP         │ SDLK_KBDILLUMUP         │
       │ Keyboard   Illumnima‐  │                                 │                         │
       │ tion Up key)           │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 0" (the 0 key  │ SDL_SCANCODE_KP_0               │ SDLK_KP_0               │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  00"  (the 00  │ SDL_SCANCODE_KP_00              │ SDLK_KP_00              │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 000" (the 000  │ SDL_SCANCODE_KP_000             │ SDLK_KP_000             │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 1" (the 1 key  │ SDL_SCANCODE_KP_1               │ SDLK_KP_1               │
       │ (numeric keypad 1))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 2" (the 2 key  │ SDL_SCANCODE_KP_2               │ SDLK_KP_2               │
       │ (numeric keypad 2))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 3" (the 3 key  │ SDL_SCANCODE_KP_3               │ SDLK_KP_3               │
       │ (numeric keypad 3))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 4" (the 4 key  │ SDL_SCANCODE_KP_4               │ SDLK_KP_4               │
       │ (numeric keypad 4))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 5" (the 5 key  │ SDL_SCANCODE_KP_5               │ SDLK_KP_5               │
       │ (numeric keypad 5))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 6" (the 6 key  │ SDL_SCANCODE_KP_6               │ SDLK_KP_6               │
       │ (numeric keypad 6))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 7" (the 7 key  │ SDL_SCANCODE_KP_7               │ SDLK_KP_7               │
       │ (numeric keypad 7))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 8" (the 8 key  │ SDL_SCANCODE_KP_8               │ SDLK_KP_8               │
       │ (numeric keypad 8))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad 9" (the 9 key  │ SDL_SCANCODE_KP_9               │ SDLK_KP_9               │
       │ (numeric keypad 9))    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad A" (the A key  │ SDL_SCANCODE_KP_A               │ SDLK_KP_A               │
       │ (numric keypad))       │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad &" (the & key  │ SDL_SCANCODE_KP_AMPERSAND       │ SDLK_KP_AMPERSAND       │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad @" (the @ key  │ SDL_SCANCODE_KP_AT              │ SDLK_KP_AT              │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad B" (the B key  │ SDL_SCANCODE_KP_B               │ SDLK_KP_B               │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad    Backspace"  │ SDL_SCANCODE_KP_BACKSPACE       │ SDLK_KP_BACKSPACE       │
       │ (the   Backspace  key  │                                 │                         │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad Binary"  (the  │ SDL_SCANCODE_KP_BINARY          │ SDLK_KP_BINARY          │
       │ Binary  key  (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad C" (the C key  │ SDL_SCANCODE_KP_C               │ SDLK_KP_C               │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  Clear"  (the  │ SDL_SCANCODE_KP_CLEAR           │ SDLK_KP_CLEAR           │
       │ Clear  key  (numberic  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad   ClearEntry"  │ SDL_SCANCODE_KP_CLEARENTRY      │ SDLK_KP_CLEARENTRY      │
       │ (the Clear Entry  key  │                                 │                         │
       │ (numberic keypad))     │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad :" (the : key  │ SDL_SCANCODE_KP_COLON           │ SDLK_KP_COLON           │
       │ (numberic keypad))     │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad ," (the Comma  │ SDL_SCANCODE_KP_COMA            │ SDLK_KP_COMA            │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad D" (the D key  │ SDL_SCANCODE_KP_D               │ SDLK_KP_D               │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad &&"  (the  &&  │ SDL_SCANCODE_KP_DBLAMPERSAND    │ SDLK_KP_DBLAMPERSAND    │
       │ key   (numberic  key‐  │                                 │                         │
       │ pad))                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad ||"  (the  ||  │ SDL_SCANCODE_KP_DBLVERTICALBAR  │ SDLK_KP_DBLVERTICALBAR  │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad Decimal" (the  │ SDL_SCANCODE_KP_DECIMAL         │ SDLK_KP_DECIMAL         │
       │ Decimal key  (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad /" (the / key  │ SDL_SCANCODE_KP_DIVIDE          │ SDLK_KP_DIVIDE          │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad E" (the E key  │ SDL_SCANCODE_KP_E               │ SDLK_KP_E               │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  Enter"  (the  │ SDL_SCANCODE_KP_ENTER           │ SDLK_KP_ENTER           │
       │ Enter  key   (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad =" (the = key  │ SDL_SCANCODE_KP_EQUALS          │ SDLK_KP_EQUALS          │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  =   (AS400)"  │ SDL_SCANCODE_KP_EQUALSAS400     │ SDLK_KP_EQUALSAS400     │
       │ (the Equals AS400 key  │                                 │                         │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad !" (the ! key  │ SDL_SCANCODE_KP_EXCLAM          │ SDLK_KP_EXCLAM          │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad F" (the F key  │ SDL_SCANCODE_KP_F               │ SDLK_KP_F               │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad    >"    (the  │ SDL_SCANCODE_KP_GREATER         │ SDLK_KP_GREATER         │
       │ Greater  key (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad #" (the # key  │ SDL_SCANCODE_KP_HASH            │ SDLK_KP_HASH            │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  Hexadecimal"  │ SDL_SCANCODE_KP_HEXADECIMAL     │ SDLK_KP_HEXADECIMAL     │
       │ (the Hexadecimal  key  │                                 │                         │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  {" (the Left  │ SDL_SCANCODE_KP_LEFTBRACE       │ SDLK_KP_LEFTBRACE       │
       │ Brace  key   (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  (" (the Left  │ SDL_SCANCODE_KP_LEFTPAREN       │ SDLK_KP_LEFTPAREN       │
       │ Parenthesis key  (nu‐  │                                 │                         │
       │ meric keypad))         │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  <" (the Less  │ SDL_SCANCODE_KP_LESS            │ SDLK_KP_LESS            │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad MemAdd"  (the  │ SDL_SCANCODE_KP_MEMADD          │ SDLK_KP_MEMADD          │
       │ Mem  Add key (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad     MemClear"  │ SDL_SCANCODE_KP_MEMCLEAR        │ SDLK_KP_MEMCLEAR        │
       │ (the  Mem  Clear  key  │                                 │                         │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad    MemDivide"  │ SDL_SCANCODE_KP_MEMDIVIDE       │ SDLK_KP_MEMDIVIDE       │
       │ (the  Mem  Divide key  │                                 │                         │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  MemMultiply"  │ SDL_SCANCODE_KP_MEMMULTIPLY     │ SDLK_KP_MEMMULTIPLY     │
       │ (the Mem Multiply key  │                                 │                         │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad    MemRecall"  │ SDL_SCANCODE_KP_MEMRECALL       │ SDLK_KP_MEMRECALL       │
       │ (the  Mem  Recall key  │                                 │                         │
       │ (numberic keypad))     │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad     MemStore"  │ SDL_SCANCODE_KP_MEMSTORE        │ SDLK_KP_MEMSTORE        │
       │ (the  Mem  Store  key  │                                 │                         │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  MemSubtract"  │ SDL_SCANCODE_KP_MEMSUBTRACT     │ SDLK_KP_MEMSUBTRACT     │
       │ (the Mem Subtract key  │                                 │                         │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad -" (the - key  │ SDL_SCANCODE_KP_MINUS           │ SDLK_KP_MINUS           │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad *" (the * key  │ SDL_SCANCODE_KP_MULTIPLY        │ SDLK_KP_MULTIPLY        │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  Octal"  (the  │ SDL_SCANCODE_KP_OCTAL           │ SDLK_KP_OCTAL           │
       │ Octal   key  (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad %" (the  Per‐  │ SDL_SCANCODE_KP_PERCENT         │ SDLK_KP_PERCENT         │
       │ cent   key   (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad ." (the . key  │ SDL_SCANCODE_KP_PERIOD          │ SDLK_KP_PERIOD          │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad +" (the + key  │ SDL_SCANCODE_KP_PLUS            │ SDLK_KP_PLUS            │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad +-"  (the  +-  │ SDL_SCANCODE_KP_PLUSMINUS       │ SDLK_KP_PLUSMINUS       │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad ^" (the Power  │ SDL_SCANCODE_KP_POWER           │ SDLK_KP_POWER           │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad }" (the Right  │ SDL_SCANCODE_KP_RIGHTBRACE      │ SDLK_KP_RIGHTBRACE      │
       │ Brace   key  (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad )" (the Right  │ SDL_SCANCODE_KP_RIGHTPAREN      │ SDLK_KP_RIGHTPAREN      │
       │ Parenthesis  key (nu‐  │                                 │                         │
       │ meric keypad))         │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad  Space"  (the  │ SDL_SCANCODE_KP_SPACE           │ SDLK_KP_SPACE           │
       │ Space   key  (numeric  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad Tab" (the Tab  │ SDL_SCANCODE_KP_TAB             │ SDLK_KP_TAB             │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad |" (the | key  │ SDL_SCANCODE_KP_VERTICALBAR     │ SDLK_KP_VERTICALBAR     │
       │ (numeric keypad))      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Keypad XOR" (the XOR  │ SDL_SCANCODE_KP_XOR             │ SDLK_KP_XOR             │
       │ key (numeric keypad))  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "L"                    │ SDL_SCANCODE_L                  │ SDLK_l                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Left  Alt" (alt, op‐  │ SDL_SCANCODE_LALT               │ SDLK_LALT               │
       │ tion)                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Left Ctrl"            │ SDL_SCANCODE_LCTRL              │ SDLK_LCTRL              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Left" (the Left  ar‐  │ SDL_SCANCODE_LEFT               │ SDLK_LEFT               │
       │ row  key  (navigation  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "["                    │ SDL_SCANCODE_LEFTBRACKET        │ SDLK_LEFTBRACKET        │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Left GUI"  (windows,  │ SDL_SCANCODE_LGUI               │ SDLK_LGUI               │
       │ command      (apple),  │                                 │                         │
       │ meta)                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Left Shift"           │ SDL_SCANCODE_LSHIFT             │ SDLK_LSHIFT             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "M"                    │ SDL_SCANCODE_M                  │ SDLK_m                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Mail" (the MaileMail  │ SDL_SCANCODE_MAIL               │ SDLK_MAIL               │
       │ key)                   │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "MediaSelect"    (the  │ SDL_SCANCODE_MEDIASELECT        │ SDLK_MEDIASELECT        │
       │ Media Select key)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Menu"                 │ SDL_SCANCODE_MENU               │ SDLK_MENU               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "-"                    │ SDL_SCANCODE_MINUS              │ SDLK_MINUS              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "ModeSwitch" (I'm not  │ SDL_SCANCODE_MODE               │ SDLK_MODE               │
       │ sure  if  this is re‐  │                                 │                         │
       │ ally not  covered  by  │                                 │                         │
       │ any of the above, but  │                                 │                         │
       │ since there's a  spe‐  │                                 │                         │
       │ cial KMOD_MODE for it  │                                 │                         │
       │ I'm adding it here)    │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Mute"                 │ SDL_SCANCODE_MUTE               │ SDLK_MUTE               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "N"                    │ SDL_SCANCODE_N                  │ SDLK_n                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Numlock"  (the   Num  │ SDL_SCANCODE_NUMLOCKCLEAR       │ SDLK_NUMLOCKCLEAR       │
       │ Lock  key  (PC)   the  │                                 │                         │
       │ Clear key (Mac))       │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "O"                    │ SDL_SCANCODE_O                  │ SDLK_o                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Oper"                 │ SDL_SCANCODE_OPER               │ SDLK_OPER               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Out"SDL_SCANCODE_OUT  │ SDLK_OUT                        │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "P"                    │ SDL_SCANCODE_P                  │ SDLK_p                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "PageDown"             │ SDL_SCANCODE_PAGEDOWN           │ SDLK_PAGEDOWN           │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "PageUp"               │ SDL_SCANCODE_PAGEUP             │ SDLK_PAGEUP             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Paste"                │ SDL_SCANCODE_PASTE              │ SDLK_PASTE              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Pause"  (the   Pause  │ SDL_SCANCODE_PAUSE              │ SDLK_PAUSE              │
       │ Break key)             │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "."                    │ SDL_SCANCODE_PERIOD             │ SDLK_PERIOD             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Power" (the USB doc‐  │ SDL_SCANCODE_POWER              │ SDLK_POWER              │
       │ ument says this is  a  │                                 │                         │
       │ status  flag,  not  a  │                                 │                         │
       │ physical  key  -  but  │                                 │                         │
       │ some Mac keyboards do  │                                 │                         │
       │ have a power key)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "PrintScreen"          │ SDL_SCANCODE_PRINTSCREEN        │ SDLK_PRINTSCREEN        │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Prior"                │ SDL_SCANCODE_PRIOR              │ SDLK_PRIOR              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Q"                    │ SDL_SCANCODE_Q                  │ SDLK_q                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "R"                    │ SDL_SCANCODE_R                  │ SDLK_r                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Right Alt" (alt  gr,  │ SDL_SCANCODE_RALT               │ SDLK_RALT               │
       │ option)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Right Ctrl"           │ SDL_SCANCODE_RCTRL              │ SDLK_RCTRL              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Return"  (the  Enter  │ SDL_SCANCODE_RETURN             │ SDLK_RETURN             │
       │ key (main keyboard))   │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Return"               │ SDL_SCANCODE_RETURN2            │ SDLK_RETURN2            │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Right GUI" (windows,  │ SDL_SCANCODE_RGUI,SDLK_RGUI     │                         │
       │ command      (apple),  │                                 │                         │
       │ meta)                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Right"  (the   Right  │ SDL_SCANCODE_RIGHT              │ SDLK_RIGHT              │
       │ arrow key (navigation  │                                 │                         │
       │ keypad))               │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "]"                    │ SDL_SCANCODE_RIGHTBRACKET       │ SDLK_RIGHTBRACKET       │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Right Shift"          │ SDL_SCANCODE_RSHIFT             │ SDLK_RSHIFT             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "S"                    │ SDL_SCANCODE_S                  │ SDLK_s                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "ScrollLock"           │ SDL_SCANCODE_SCROLLLOCK"        │ SDLK_SCROLLLOCK         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Select"               │ SDL_SCANCODE_SELECT             │ SDLK_SELECT             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ";"                    │ SDL_SCANCODE_SEMICOLON          │ SDLK_SEMICOLON          │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Separator"            │ SDL_SCANCODE_SEPARATOR          │ SDLK_SEPARATOR          │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "/"                    │ SDL_SCANCODE_SLASH              │ SDLK_SLASH              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Sleep"  (the   Sleep  │ SDL_SCANCODE_SLEEP              │ SDLK_SLEEP              │
       │ key)                   │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Space"   (the  Space  │ SDL_SCANCODE_SPACE              │ SDLK_SPACE              │
       │ Bar key(s))            │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Stop"                 │ SDL_SCANCODE_STOP               │ SDLK_STOP               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "SysReq" (the  SysReq  │ SDL_SCANCODE_SYSREQ             │ SDLK_SYSREQ             │
       │ key)                   │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "T"                    │ SDL_SCANCODE_T                  │ SDLK_t                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Tab" (the Tab key)    │ SDL_SCANCODE_TAB                │ SDLK_TAB                │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "ThousandsSeparator"   │ SDL_SCANCODE_THOUSANDSSEPARATOR │ SDLK_THOUSANDSSEPARATOR │
       │ (the Thousands Seper‐  │                                 │                         │
       │ ator key)              │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "U"                    │ SDL_SCANCODE_U                  │ SDLK_u                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Undo"                 │ SDL_SCANCODE_UNDO               │ SDLK_UNDO               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_UNKNOWN            │ SDLK_UNKNOWN            │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Up"  (the  Up  arrow  │ SDL_SCANCODE_UP                 │ SDLK_UP                 │
       │ key  (navigation key‐  │                                 │                         │
       │ pad))                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "V"                    │ SDL_SCANCODE_V                  │ SDLK_v                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "VolumeDown"           │ SDL_SCANCODE_VOLUMEDOWN         │ SDLK_VOLUMEDOWN         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "VolumeUp"             │ SDL_SCANCODE_VOLLUMEUP          │ SDLK_VOLUMEUP           │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "W"                    │ SDL_SCANCODE_W                  │ SDLK_w                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "WWW"  (the  WWW/Word  │ SDL_SCANCODE_WWW                │ SDLK_WWW                │
       │ Wide Web key)          │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "X"                    │ SDL_SCANCODE_X                  │ SDLK_x                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Y"                    │ SDL_SCANCODE_Y                  │ SDLK_y                  │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "Z"                    │ SDL_SCANCODE_Z                  │ SDLK_z                  │
       ├────────────────────────┴─────────────────────────────────┴─────────────────────────┤
       │         These physical keys do not have corresponding virtual key values           │
       ├────────────────────────┬─────────────────────────────────┬─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL1     │ (none)                  │
       │ string; used on Asian  │                                 │                         │
       │ keyboards,  see foot‐  │                                 │                         │
       │ notes in USB doc)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL2     │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL3     │ (none)                  │
       │ string; Yen)           │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL4     │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL5     │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL6     │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL7     │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL8     │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_INTERNATIONAL9     │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG1              │ (none)                  │
       │ string; Hangu/English  │                                 │                         │
       │ toggle)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG2              │ (none)                  │
       │ string; Hanja conver‐  │                                 │                         │
       │ sion)                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG3              │ (none)                  │
       │ string; Katakana)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG4              │ (none)                  │
       │ string; Hiragana)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG5              │ (none)                  │
       │ string:  Zenkaku/Han‐  │                                 │                         │
       │ kaku)                  │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG6              │ (none)                  │
       │ string; reserved)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG7              │ (none)                  │
       │ string; reserved)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG8              │ (none)                  │
       │ string; reserved)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LANG9              │ (none)                  │
       │ string; reserved)      │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LOCKINGCAPSLOCK    │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LOCKINGNUMLOCK     │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_LOCKINGSCROLLLOCK  │ (none)                  │
       │ string)                │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ""  (no  name,  empty  │ SDL_SCANCODE_NONUSBACKSLASH     │ (none)                  │
       │ string; This  is  the  │                                 │                         │
       │ additional  key  that  │                                 │                         │
       │ ISO  keyboards   have  │                                 │                         │
       │ over  ANSI  ones, lo‐  │                                 │                         │
       │ cated  between   left  │                                 │                         │
       │ shift and Y. Produces  │                                 │                         │
       │ GRAVE   ACCENT   left  │                                 │                         │
       │ shift and Y. Produces  │                                 │                         │
       │ GRAVE   ACCENT    and  │                                 │                         │
       │ TILDE  in  a US or UK  │                                 │                         │
       │ Mac  layout,  REVERSE  │                                 │                         │
       │ SOLIDUS   (backslash)  │                                 │                         │
       │ and VERTICAL LINE  in  │                                 │                         │
       │ a  US  or  UK Windows  │                                 │                         │
       │ layout, and LESS-THAN  │                                 │                         │
       │ SIGN and GREATER-THAN  │                                 │                         │
       │ SIGN in a Swiss  Ger‐  │                                 │                         │
       │ man,    German,    or  │                                 │                         │
       │ French layout.)        │                                 │                         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "#"  (ISO  USB   key‐  │ SDL_SCANCODE_NONUSHASH          │ (none)                  │
       │ boards  actually  use  │                                 │                         │
       │ this code instead  of  │                                 │                         │
       │ 49  for the same key,  │                                 │                         │
       │ but  all  OSes   I've  │                                 │                         │
       │ seen  treat  the  two  │                                 │                         │
       │ codes    identically.  │                                 │                         │
       │ So, as an implementa‐  │                                 │                         │
       │ tor, unless your key‐  │                                 │                         │
       │ board  generates both  │                                 │                         │
       │ of  these  codes  and  │                                 │                         │
       │ your  OS  treats them  │                                 │                         │
       │ differently,      you  │                                 │                         │
       │ should       generate  │                                 │                         │
       │ SDL_SCANCODE_BACK‐     │                                 │                         │
       │ SLASH instead of this  │                                 │                         │
       │ code. As a user,  you  │                                 │                         │
       │ should  not  rely  on  │                                 │                         │
       │ this code because SDL  │                                 │                         │
       │ will  never  generate  │                                 │                         │
       │ it with  most  (all?)  │                                 │                         │
       │ keyboards.)            │                                 │                         │
       ├────────────────────────┴─────────────────────────────────┴─────────────────────────┤
       │         These virtual key values do not have corresponding physical keys           │
       ├────────────────────────┬─────────────────────────────────┬─────────────────────────┤
       │ "&"                    │ (none)                          │ SDLK_AMPERSAND          │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "*"                    │ (none)                          │ SDLK_ASTERISK           │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "@"                    │ (none)                          │ SDLK_AT                 │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "^"                    │ (none)                          │ SDLK_CARET              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ":"                    │ (none)                          │ SDLK_COLON              │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "$"                    │ (none)                          │ SDLK_DOLLAR             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "!"                    │ (none)                          │ SDLK_EXCLAM             │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ">"                    │ (none)                          │ SDLK_GREATER            │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "#"                    │ (none)                          │ SDLK_HASH               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "("                    │ (none)                          │ SDLK_LEFTPAREN          │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "<"                    │ (none)                          │ SDLK_LESS               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "%"                    │ (none)                          │ SDLK_PERCENT            │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "+"                    │ (none)                          │ SDLK_PLUS               │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "?"                    │ (none)                          │ SDLK_QUESTION           │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ """                    │ (none)                          │ SDLK_QUOTEDBL           │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ ")"                    │ (none)                          │ SDLK_RIGHTPAREN         │
       ├────────────────────────┼─────────────────────────────────┼─────────────────────────┤
       │ "_"                    │ (none)                          │ SDLK_UNDERSCORE         │
       └────────────────────────┴─────────────────────────────────┴─────────────────────────┘

CODE EXAMPLES
       // checks if a key is being remapped and prints what the remapping is
       if (event->key.keysysm.scancode != SDL_GetScancodeFromKey(event->key.keysym.sym))
       {
           printf("Physical %s key acting as %s key", SDL_GetScancodeName(event->key.keysym.scancode), SDL_GetKeyName(event->key.keysym.sym));
       }

REMARKS
       Values  of this type (also known as keycode or keysyms) are mapped to the cur‐
       rent layout of the keyboard and correlate to  an  SDL_Scancode.  The  scancode
       identifies the location of a key press and the corresponding SDL_Keycode gives
       that key press meaning in the context of the current keyboard layout.

       Values of this type are used to represent keyboard keys using the current lay‐
       out  of the keyboard. These values include Unicode values representing the un‐
       modified character that would be generated by pressing the key, or other  con‐
       stants for those keys that do not generate characters.

       To  look  up a scancode or keycode by decimal or hexadecimal value you can use
       the following tables:

       SDL Scancode Lookup Table
                           See https://wiki.libsdl.org/SDLScancodeLookup

       SDL Keycode Lookup Table
                           See https://wiki.libsdl.org/SDLKeycodeLookup

       Note: You can still use man SDLScancodeLookupTable or  man  SDLKeycodeLookupT‐
       able.

RELATED ENUMERATIONS
       SDL_Scancode

RELATED FUNCTIONS
       SDL_GetKeyFromScancode
       SDL_GetKeyName
       SDL_GetScancodeFromKey

===============================================================================
                                                                   *SDL_Keymod*


NAME
       SDL_Keymod -- Enumerations

SYNOPSIS
       An enumeration of key modifier masks.

DESCRIPTION
       Values

       ┌────────────────┬──────────────────────────────┐
       │ KMOD_NONE      │ 0  (no  modifier is applica‐ │
       │                │ ble)                         │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_LSHIFT    │ the left Shift key is down   │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_RSHIFT    │ the right Shift key is down  │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_LCTRL     │ the left Ctrl (Control)  key │
       │                │ is down                      │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_RCTRL     │ the right Ctrl (Control) key │
       │                │ is down                      │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_LALT      │ the left Alt key is down     │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_RALT      │ the right Alt key is down    │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_LGUI      │ the left GUI key (often  the │
       │                │ Windows key) is down         │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_RGUI      │ the right GUI key (often the │
       │                │ Windows key) is down         │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_NUM       │ the Num Lock key (may be lo‐ │
       │                │ cated on an extended keypad) │
       │                │ is down                      │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_CAPS      │ the Caps Lock key is down    │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_MODE      │ the AltGr key is down        │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_CTRL      │ (KMOD_LCTRL | KMOD_RCTRL)    │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_SHIFT     │ (KMOD_LSHIFT | KMOD_RSHIFT)  │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_ALT       │ (KMOD_LALT | KMOD_RALT)      │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_GUI       │ (KMOD_LGUI | KMOD_RGUI)      │
       ├────────────────┼──────────────────────────────┤
       │ KMOD_RESERVED  │ reserved for future use      │
       └────────────────┴──────────────────────────────┘

REMARKS
       These may be OR'd together.

RELATED FUNCTIONS
       SDL_GetModState
       SDL_SetModState

===============================================================================
                                                                   *SDL_Keysym*


NAME
       SDL_Keysym -- Structure

SYNOPSIS
       A structure that contains key information used in key events.

DATA FIELDS
       ┌───────────────┬──────────┬───────────────────────┐
       │ SDL_Scancode  │ scancode │ SDL    physical   key │
       │               │          │ code;  see  SDL_Scan‐ │
       │               │          │ code for details      │
       ├───────────────┼──────────┼───────────────────────┤
       │ SDL_Keycode   │ sym      │ SDL virtual key code; │
       │               │          │ see  SDL_Keycode  for │
       │               │          │ details               │
       ├───────────────┼──────────┼───────────────────────┤
       │ Uint16        │ mod      │ current   key   modi‐ │
       │               │          │ fiers; see SDL_Keymod │
       │               │          │ for details           │
       ├───────────────┼──────────┼───────────────────────┤
       │ Uint32        │ unused   │                       │
       └───────────────┴──────────┴───────────────────────┘

RELATED ENUMERATIONS
       SDL_Keycode
       SDL_Keymod
       SDL_Scancode

RELATED STRUCTURES
       SDL_KeyboardEvent
       SDL_TextInputEvent

===============================================================================
                                                               *SDL_KillThread*


NAME
       SDL_KillThread - Gracelessly terminates the thread.

SYNOPSIS
       #include "SDL.h" #include "SDL_thread.h"

       void SDL_KillThread(SDL_Thread *thread);

DESCRIPTION
       SDL_KillThread  gracelessly  terminates  the thread associated with thread. If
       possible, you should use some other form of IPC to signal the thread to quit.

SEE ALSO
       SDL_CreateThread, SDL_WaitThread

===============================================================================
                                                             *SDL_LOG_CATEGORY*


NAME
       SDL_LOG_CATEGORY -- Enumerations

SYNOPSIS
       An enumeration of the predefined log categories.

DESCRIPTION
       Values

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │ application log              │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │ error log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │ assert log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │ system log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │ audio log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │ video log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │ render log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │ input log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORYL_TEST        │ test log                     │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │ #  =  1-10; reserved for fu‐ │
       │                               │ ture SDL libray use          │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │ reserved   for   application │
       │                               │ use; see Remarks for details │
       └───────────────────────────────┴──────────────────────────────┘

REMARKS
       By  default  the  APPLICATION category is enabled at the SDL_LOG_PRIORITY_INFO
       level and all other categories are enabled  at  the  SDL_LOG_PRIORITY_CRITICAL
       level. See SDL_LogPriority for details.

       SDL_LOG_CATEGORY_CUSTOM is reserved for application use; for example:

       enum {
         MYAPP_CATEGORY_AWESOME1 = SDL_LOG_CATEGORY_CUSTOM,
         MYAPP_CATEGORY_AWESOME2,
         MYAPP_CATEGORY_AWESOME3,
         ...
       }

RELATED FUNCTIONS
       SDL_Log
       SDL_LogMessage
       SDL_LogMessageV

===============================================================================
                                                                *SDL_ListModes*


NAME
       SDL_ListModes  -  Returns a pointer to an array of available screen dimensions
       for the given format and video flags

SYNOPSIS
       #include "SDL.h"

       SDL_Rect **SDL_ListModes(SDL_PixelFormat *format, Uint32 flags);

DESCRIPTION
       Return a pointer to an array of available screen dimensions for the given for‐
       mat  and video flags, sorted largest to smallest. Returns NULL if there are no
       dimensions available for a particular format, or -1 if any dimension  is  okay
       for the given format.

       If  format  is  NULL,  the  mode  list  will  be  for  the  format returned by
       SDL_GetVideoInfo()->vfmt. The flag parameter is an OR'd combination of surface
       flags.  The  flags are the same as those used SDL_SetVideoMode and they play a
       strong role in deciding what modes  are  valid.  For  instance,  if  you  pass
       SDL_HWSURFACE  as  a flag only modes that support hardware video surfaces will
       be returned.

EXAMPLE
       SDL_Rect **modes;
       int i;
       .
       .
       .

       /* Get available fullscreen/hardware modes */
       modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_HWSURFACE);

       /* Check is there are any modes available */
       if(modes == (SDL_Rect **)0){
         printf("No modes available!
       ");
         exit(-1);
       }

       /* Check if or resolution is restricted */
       if(modes == (SDL_Rect **)-1){
         printf("All resolutions available.
       ");
       }
       else{
         /* Print valid modes */
         printf("Available Modes
       ");
         for(i=0;modes[i];++i)
           printf("  %d x %d
       ", modes[i]->w, modes[i]->h);
       }
       .
       .

SEE ALSO
       SDL_SetVideoMode, SDL_GetVideoInfo, SDL_Rect, SDL_PixelFormat

===============================================================================
                                                                  *SDL_LoadBMP*


NAME
       SDL_LoadBMP -- Function

SYNOPSIS
       Use this function to load a surface from a BMP file.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ SDL_Surface* SDL_LoadBMP(const char*    file)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ file  │ the  file  containing  a BMP │
       │       │ image                        │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to a new SDL_Surface structure or NULL if there was  an  er‐
       ror; call SDL_GetError for more information.

REMARKS
       The new surface should be freed with SDL_FreeSurface().

RELATED FUNCTIONS
       SDL_FreeSurface
       SDL_LoadBMP_RW
       SDL_SaveBMP

===============================================================================
                                                               *SDL_LoadBMP_RW*


NAME
       SDL_LoadBMP_RW -- Function

SYNOPSIS
       Use  this function to load a BMP image from a seekable SDL data stream (memory
       or file).

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ SDL_Surface SDL_LoadBMP_RW(SDL_RWops*   src,      │
       │                            int          freesrc)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ src      │ the data stream for the sur‐ │
       │          │ face                         │
       ├──────────┼──────────────────────────────┤
       │ freesrc  │ non-zero to close the stream │
       │          │ after being read             │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to a new SDL_Surface structure or NULL if there was  an  er‐
       ror; call SDL_GetError() for more information.

REMARKS
       The new surface should be freed with SDL_FreeSurface().

RELATED FUNCTIONS
       SDL_FreeSurface
       SDL_LoadBMP
       SDL_SaveBMP_RW

===============================================================================
                                                      *SDL_LoadDollarTemplates*


NAME
       SDL_LoadDollarTemplates -- Function

SYNOPSIS
       Use this function to load Dollar Gesture templates from a file.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_LoadDollarTemplate(SDL_TouchID    touchId,  │
       │                            SDL_RWops*     src)      │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────┐
       │ touchId  │ a touch id               │
       ├──────────┼──────────────────────────┤
       │ src      │ a SDL_RWops to load from │
       └──────────┴──────────────────────────┘

RETURN VALUE
       Returns the number of loaded templates on success or a negative error code (or
       0) on failure; call SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_SaveAllDollarTemplates
       SDL_SaveDollarTemplate

===============================================================================
                                                             *SDL_LoadFunction*


NAME
       SDL_LoadFunction -- Function

SYNOPSIS
       Use  this  function to look up the address of the named function in the shared
       object and return it.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void* SDL_LoadFunction(void*          handle,  │
       │                        const char*    name)    │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ handle  │ a valid shared object handle │
       │         │ returned by SDL_LoadObject() │
       ├─────────┼──────────────────────────────┤
       │ name    │ the  name of the function to │
       │         │ look up                      │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to the  function  or  NULL  if  there  was  an  error;  call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                             │
       │                                                                              │
       │ /* Variable declrations */                                                   │
       │ void* myHandle = NULL;                                                       │
       │ char* myFunctionName = "myFancyFunction";                                    │
       │ void (*myFancyFunction)(int anInt);                                          │
       │                                                                              │
       │ /* Dyanmically load mylib.so */                                              │
       │ myHandle = SDL_LoadObject("mylib.so");                                       │
       │                                                                              │
       │ /* Load the exported function from mylib.so                                  │
       │  * The expoerted function has following prorotype                            │
       │  * void myFancyFunction(int anInt);                                          │
       │  */                                                                          │
       │ myFancyFunction = (void(*)(int))SDL_LoadFunction(myHandle, myFunctionName);  │
       │                                                                              │
       │ /* Call myFancyFunction with a random integer. */                            │
       │ if (myFancyFunction != NULL)                                                 │
       │ {                                                                            │
       │   myFancyFunction(15);                                                       │
       │ }                                                                            │
       │ else                                                                         │
       │ {                                                                            │
       │   /* Error handling here */                                                  │
       │ }                                                                            │
       └──────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This function pointer is no longer valid after calling SDL_UnloadObject().

       This function can only look up C function names. Other languages may have name
       mangling and intrinsic language support that varies from compiler to compiler.

       Make sure you declare your function pointers with the same calling  convention
       as  the  actual  library function. Your code will crash mysteriously if you do
       not do this.

RELATED FUNCTIONS
       SDL_LoadObject
       SDL_UnloadObject

===============================================================================
                                                               *SDL_LoadObject*


NAME
       SDL_LoadObject -- Function

SYNOPSIS
       Use  this function to dynamically load a shared object and return a pointer to
       the object handle.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ void* SDL_LoadObject(const char*    sofile)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ sofil  │ a system dependent  name  of │
       │        │ the object file              │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns  a  pointer  to  the object handle or NULL if there was an error; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────┐
       │ #include "SDL.h"                 │
       │                                  │
       │ /* Dynamically load mylib.so */  │
       │ SDL_LoadObject("mylib.so");      │
       └──────────────────────────────────┘

RELATED FUNCTIONS
       SDL_LoadFunction
       SDL_UnloadObject

===============================================================================
                                                                  *SDL_LoadWAV*


NAME
       SDL_LoadWAV -- Function

SYNOPSIS
       Use this function to load a WAVE from a file.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ SDL_AudioSpec* SDL_LoadWAV(const char*      file,       │
       │                            SDL_AudioSpec*   spec,       │
       │                            Uint8**          audio_buf,  │
       │                            Uint32*          audio_len)  │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ file       │ the name of the file to load │
       ├────────────┼──────────────────────────────┤
       │ spec       │ an  SDL_AudioSpec  structure │
       │            │ that will be filled in  with │
       │            │ the  wave  file's format de‐ │
       │            │ tails                        │
       ├────────────┼──────────────────────────────┤
       │ audio_buf  │ the audio buffer             │
       ├────────────┼──────────────────────────────┤
       │ audio_len  │ the length of the audio buf‐ │
       │            │ fer in bytes                 │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       This  function, if successfully called, returned a pointer to an SDL_AudioSpec
       structure filled with the audio data format of the wave source data. audio_buf
       is filled with a pointer to an allocated buffer containing the audio data, and
       audio_len is filled with the length of that audio buffer in bytes.

       This function returns NULL if the wave  file cannot be opened, uses an unknown
       data format, or is corrupt; call SDL_GetError() for more information.

       When  the  application  is done with the data returned in audio_buf, it should
       call SDL_FreeWAV() to dispose of it.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────┐
       │ SDL_AudioSpec wav_spec;                                                    │
       │ Uint32 wav_length;                                                         │
       │ Uint8* wav_buffer;                                                         │
       │                                                                            │
       │ /* Load the WAV */                                                         │
       │ if (SDL_LoadWAV("test.wav", &wav_spec, &wav_buffer, &wav_length) == NULL)  │
       │ {                                                                          │
       │   fprintf(stderr, "Could not open test.wav: %s\n", SDL_GetError());        │
       │ }                                                                          │
       │ else                                                                       │
       │ {                                                                          │
       │   /* Do stuff with the WAV data, and then ... */                           │
       │   SDL_FreeWav(wav_buffer);                                                 │
       │ }                                                                          │
       └────────────────────────────────────────────────────────────────────────────┘

REMARKS
       SDL_LoadWAV is a convenient macro that calls SDL_LoadWAV_RW().

       This macro exists so you can pass a filename to SDL_LoadWAV_RW() without  hav‐
       ing to deal with the RWops API.

RELATED FUNCTIONS
       SDL_FreeWAV
       SDL_LoadWAV_RW

===============================================================================
                                                               *SDL_LoadWAV_RW*


NAME
       SDL_LoadWAV_RW -- Function

SYNOPSIS
       Use  this  function to load a WAVE from the data source, automatically freeing
       that source if freesrc is non-zero.

SYNTAX
       ┌─────────────────────────────────────────────────────────────┐
       │ SDL_AudioSpec* SDL_LoadWAV_RW(SDL_RWops*        src,        │
       │                               int               freesrc,    │
       │                               SDL_AudioSpec*    spec,       │
       │                               Uint8**           audio_buf,  │
       │                               Uint32*           audio_len)  │
       └─────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ src        │ the data source for the wave │
       │            │ file;  see  the RWOPS inter‐ │
       │            │ face()(https://wiki.lib‐     │
       │            │ sdl.org/CategoryIO) for more │
       │            │ info                         │
       ├────────────┼──────────────────────────────┤
       │ freesrc    │ non-zero  to   automatically │
       │            │ free the data source         │
       ├────────────┼──────────────────────────────┤
       │ spec       │ an  SDL_AudioSpec  structure │
       │            │ that will be filled in  with │
       │            │ the  wave  file's format de‐ │
       │            │ tails                        │
       ├────────────┼──────────────────────────────┤
       │ audio_buf  │ the audio buffer             │
       ├────────────┼──────────────────────────────┤
       │ audio_len  │ the length of the audio buf‐ │
       │            │ fer in bytes                 │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       This  function,  if successfully called, returns a pointer to an SDL_AudioSpec
       structure filled with the audio data format of the wave source data. audio_buf
       is filled with a pointer to an allocated buffer containing the audio data, and
       audio_len is filled with the length of that audio buffer in bytes.

       This function returns NULL if the wave file cannot be opened, uses an  unknown
       data format, or is corrupt; call SDL_GetError() for more information.

       When  the  application  is done with the data returned in audio_buf, it should
       call SDL_FreeWAV() to dispose it.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────┐
       │ extern SDL_RWops* myRWops;                                                    │
       │ SDL_AudioSpec wav_spec;                                                       │
       │ Uint32 wav_length;                                                            │
       │ Uint8* wav_buffer;                                                            │
       │                                                                               │
       │ /* Load the WAV */                                                            │
       │ if (SDL_LoadWAV_RW(myRWops, 1, &wav_spec, &wav_buffer, &wav_length) == NULL)  │
       │ {                                                                             │
       │   fprintf(stderr, "Could not open test.wav: %s\n", SDL_GetError());           │
       │ }                                                                             │
       │ else                                                                          │
       │ {                                                                             │
       │   /* Do stuff with the WAV data, and then... */                               │
       │   SDL_FreeWAV(wav_buffer);                                                    │
       │ }                                                                             │
       └───────────────────────────────────────────────────────────────────────────────┘

REMARKS
       Currently raw and MS-ADPCM WAVE file are supported.

       You need to free the audio buffer with SDL_FreeWAV() when you  are  done  with
       it.

RELATED FUNCTIONS
       SDL_FreeWAV
       SDL_LoadWAV

===============================================================================
                                                                *SDL_LockAudio*


NAME
       SDL_LockAudio -- Function

SYNOPSIS
       This  function  is  a  legacy  means of locking the audio device. New programs
       might want to use SDL_LockAudioDevice() instead.

SYNTAX
       ┌───────────────────────────┐
       │ void SDL_LockAudio(void)  │
       └───────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────┐
       │ void MyAudioCallback(void *userdata, Uint8* stream, int len)  │
       │ {                                                             │
       │     printf("The audio callback is running!\n");               │
       │     SDL_memset(stream, 0, len);  // just silence.             │
       │     printf("The audio callback is done!\n");                  │
       │ }                                                             │
       │                                                               │
       │ // don't lock for 2 seconds at a time in real life, please.   │
       │ SDL_Delay(2000);  // callback runs for 2 seconds.             │
       │ SDL_LockAudio();                                              │
       │ printf("The audio callback can't be running right now!\n");   │
       │ SDL_Delay(2000);  // callback doesn't run for 2 seconds.      │
       │ printf("Ok, unlocking!\n");                                   │
       │ SDL_UnlockAudio();                                            │
       │ SDL_Delay(2000);  // callback runs for 2 seconds.             │
       │                                                               │
       └───────────────────────────────────────────────────────────────┘

REMARKS
       This function is equivalent to calling

       ┌──────────────────────────┐
       │ SDL_LockAudioDevice(1);  │
       └──────────────────────────┘
       and is only useful if you used the legacy SDL_OpenAudio() function.

RELATED FUNCTIONS
       SDL_LockAudioDevice
       SDL_UnlockAudio
       SDL_UnlockAudioDevice

===============================================================================
                                                          *SDL_LockAudioDevice*


NAME
       SDL_LockAudioDevice -- Function

SYNOPSIS
       Use  this function to lock out the audio callback function for a specified de‐
       vice.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ void SDL_LockAudioDevice(SDL_AudioDeviceID    dev)  │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ dev  │ the ID of the device  to  be │
       │      │ locked                       │
       └──────┴──────────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────┐
       │ void MyAudioCallback(void*    userdata, Uint8* stream, int len)  │
       │ {                                                                │
       │   printf("The audio callback is running!\n");                    │
       │   SDL_memset(stream, 0, len);                                    │
       │   printf("The audio callback is done!\n");                       │
       │ }                                                                │
       │                                                                  │
       │ // don't lock for 2 seconds at a time in real life, please.      │
       │ extern SDL_AudioDeviceID devid;                                  │
       │ SDL_Delay(2000);  // callback runs for 2 seconds                 │
       │ SDL_LockAudioDevice(devid);                                      │
       │ printf("The audio callback can't be running right now!\n");      │
       │ SDL_Delay(2000);  // callback doesn't run for 2 seconds          │
       │ printf("Ok, unlocking!\n");                                      │
       │ SDL_UnlockAudioDevice(devid);                                    │
       │ SDL_Delay(2000);  // callback runs for 2 seconds                 │
       └──────────────────────────────────────────────────────────────────┘

REMARKS
       The  lock  manipulated by these functions protects the audio callback function
       specified in SDL_OpenAudioDevice(). During a SDL_LockAudioDeivce()/SDL_Unlock‐
       AudioDevice()  pair, you can be guaranteed that the callback function for that
       device is not running, even if the device is not paused.  While  a  device  is
       locked, any other unpaused, unlocked devices may still run their callbacks.

       Calling  this function from inside your audio callback is unnecessary. SDL ob‐
       tains this lock before calling your function, and releases it when  the  func‐
       tion returns.

       You  should not hold the lock longer than absolutely necessary. If you hold it
       too long, you'll experience dropouts in your audio playback. Ideally, your ap‐
       plication  locks the device, sets a few variables and unlocks again. Do not do
       heavy work while holding the lock for a device.

       It is safe to lock the audio device multiple times, as long as you  unlock  it
       an  equivalent number of times. The callback will not run until the device has
       been unlocked completely in this way. If your application fails to unlock  the
       device  appropriately,  your callback will never run, you might hear repeating
       bursts of audio, and SDL_CloseAudioDevice() will probably deadlock.

       Internally, the audio device lock is a mutex; if you lock from two threads  at
       once,  not  only  will  you  block  the audio callback, you'll block the other
       thread.

RELATED FUNCTIONS
       SDL_UnlockAudioDevice

===============================================================================
                                                                *SDL_LockMutex*


NAME
       SDL_LockMutex -- Function

SYNOPSIS
       Use this function to lock a mutex created with SDL_CreateMutex().

SYNTAX
       ┌─────────────────────────────────────────┐
       │ int SDL_LockMutex(SDL_Mutex*    mutex)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬───────────────────┐
       │ mutex  │ the mutex to lock │
       └────────┴───────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────┐
       │ SDL_mutex*    mutex;                           │
       │                                                │
       │ mutex = SDL_CreateMutex();                     │
       │ if (!mutex)                                    │
       │ {                                              │
       │   fprintf(stderr, "Couldn't create mutex\n");  │
       │   return;                                      │
       │ }                                              │
       │                                                │
       │ if (SDL_LockMutex(mutex) == 0)                 │
       │ {                                              │
       │   /* Do stuff while mutex is locked */         │
       │   SDL_UnlockMutex(mutex);                      │
       │ }                                              │
       │ else                                           │
       │ {                                              │
       │   fprintf(stderr, "Couldn't lock mutex\n");    │
       │ }                                              │
       │                                                │
       │ SDL_DestroyMutex(mutex);                       │
       └────────────────────────────────────────────────┘

REMARKS
       Calls to this function will not return while the mutex is  locked  by  another
       thread. See SDL_TryLockMutex() to attempt to lock the mutex without blocking.

       SDL mutexes are recursive.

RELATED FUNCTIONS
       SDL_CreateMutex
       SDL_DestroyMutex
       SDL_TryLockMutex
       SDL_UnlockMutex

===============================================================================
                                                              *SDL_LockSurface*


NAME
       SDL_LockSurface -- Function

SYNOPSIS
       Use this function to set up a surface for directly accessing the pixels.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_LockSurface(SDL_Surface*    surface)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ be locked                    │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────┐
       │ /* Make the pixels pointer valid in the surface */  │
       │ SDL_LockSurface(surface);                           │
       │                                                     │
       │ /* Surface is locked */                             │
       │ /* Direct pixel access on surface here */           │
       │ SDL_UnlockSurface(surface);                         │
       │                                                     │
       │ /* Surface is now unlocked */                       │
       └─────────────────────────────────────────────────────┘

REMARKS
       Between  calls  to SDL_LockSurface()/SDL_UnlockSurface(), you can write to and
       read from surface->pixels, using the pixel format stored  in  surface->format.
       Once you are done accessing the surface, you should use SDL_UnlockSurface() to
       release it.

       Not all surfaces require locking. If  SDL_MUSTLOCK(surface)  evaluates  to  0,
       then  you  can read and write to the surface at any time, and the pixel format
       of the surface will not change.

RELATED FUNCTIONS
       SDL_MUSTLOCK
       SDL_UnlockSurface

===============================================================================
                                                              *SDL_LockTexture*


NAME
       SDL_LockTexture -- Function

SYNOPSIS
       Use  this  function  to lock a portion of the texture for write-only pixel ac‐
       cess.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ int SDL_LockTexture(SDL_Texture*      texture,  │
       │                     const SDL_Rect*   rect,     │
       │                     void**            pixels,   │
       │                     int*              pitch)    │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to lock for  ac‐ │
       │          │ cess, which was created with │
       │          │ SDL_TEXTUREACCESS_STREAMING  │
       ├──────────┼──────────────────────────────┤
       │ rect     │ an SDL_Rect structure repre‐ │
       │          │ senting the area to lock for │
       │          │ access; NULL to lock the en‐ │
       │          │ tire texture                 │
       ├──────────┼──────────────────────────────┤
       │ pixels   │ this  is  filled  in  with a │
       │          │ pointer to the  locked  pix‐ │
       │          │ els, appropriately offset by │
       │          │ the locked area              │
       ├──────────┼──────────────────────────────┤
       │ pitch    │ this is filled in  with  the │
       │          │ pitch  of the locked pixels; │
       │          │ the pitch is the  length  of │
       │          │ one row in bytes             │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0  on success or a negative error code if the texture is not valid or
       was not created with SDL_TEXTUREACCESS_STREAMING; call SDL_GetError() for more
       information.

REMARKS
       As  an  optimization,  the pixels made available for editing don't necessarily
       contain the old texture data. This is a write-only operation, and if you  need
       to  keep  a  copy  of  the  texture data you should do that at the application
       level.

       You must use SDL_UnlockTexture() to unlock the pixels and apply any changes.

RELATED FUNCTIONS
       SDL_UnlockTexture

===============================================================================
                                                           *SDL_LockYUVOverlay*


NAME
       SDL_LockYUVOverlay - Lock an overlay

SYNOPSIS
       #include "SDL.h"

       int SDL_LockYUVOverlay(SDL_Overlay *overlay);

DESCRIPTION
       Much the same as SDL_LockSurface, SDL_LockYUVOverlay locks the overlay for di‐
       rect access to pixel data.

RETURN VALUE
       Returns 0 on success, or -1 on an error.

SEE ALSO
       SDL_UnlockYUVOverlay, SDL_CreateYUVOverlay, SDL_Overlay

===============================================================================
                                                                      *SDL_Log*


NAME
       SDL_Log -- Function

SYNOPSIS
       Use  this  function  to  log  a  message with SDL_LOG_CATEGORY_APPLICATION and
       SDL_LOG_PRIORITY_INFO.

SYNTAX
       ┌───────────────────────────────────┐
       │ void SDL_Log(const char*    fmt,  │
       │              ...)                 │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ fmt  │ a  printf()  style   message │
       │      │ format string                │
       ├──────┼──────────────────────────────┤
       │ ...  │ additional parameters match‐ │
       │      │ ing  %  tokens  in  the  fmt │
       │      │ string, if any               │
       └──────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_LogCritical
       SDL_LogDebug
       SDL_LogError
       SDL_LogInfo
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogVerbose
       SDL_LogWarn

===============================================================================
                                                              *SDL_LogCritical*


NAME
       SDL_LogCritical -- Function

SYNOPSIS
       Use this function to log a message with SDL_LOG_PRIORITY_CRITICAL.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_LogCritical(int            category,  │
       │                      const char*    fmt,       │
       │                      ...)                      │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the category of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ fmt       │ a  printf()  style   message │
       │           │ format string                │
       ├───────────┼──────────────────────────────┤
       │ ...       │ additional parameters match‐ │
       │           │ ing    tokens  in  the   fmt │
       │           │ string, if nay               │
       └───────────┴──────────────────────────────┘

REMARKS
       The category can be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_Log
       SDL_LogDebug
       SDL_LogError
       SDL_LogInfo
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogVerbose
       SDL_LogWarn

===============================================================================
                                                                 *SDL_LogDebug*


NAME
       SDL_LogDebug -- Function

SYNOPSIS
       Use this function to log a message with SDL_LOG_PRIORITY_DEBUG.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_LogDebug(int           category,  │
       │                   const char*   fmt,       │
       │                   ...)                     │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the category of the message; │
       │           │ see                      Re‐ │
       │           │ marks(https://wiki.lib‐      │
       │           │ sdl.org/SDL_LogDebug#cate‐   │
       │           │ gory) for details            │
       ├───────────┼──────────────────────────────┤
       │ fmt       │ a   printf()  style  message │
       │           │ format string                │
       ├───────────┼──────────────────────────────┤
       │ ...       │ additional parameters match‐ │
       │           │ ing  %  tokens  in  the  fmt │
       │           │ string, if any               │
       └───────────┴──────────────────────────────┘

REMARKS
       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_Log
       SDL_LogCritical
       SDL_LogError
       SDL_LogInfo
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogVerbose
       SDL_LogWarn

===============================================================================
                                                                 *SDL_LogError*


NAME
       SDL_LogError -- Function

SYNOPSIS
       Use this function to log a message with SDL_LOG_PRIORITY_ERROR.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_LogError(int           category,  │
       │                   const char*   fmt,       │
       │                   ...)                     │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the category of the message; │
       │           │ see                  Remarks │
       │           │ (https://wiki.lib‐           │
       │           │ sdl.org/SDL_LogError#cate‐   │
       │           │ gory) for details            │
       ├───────────┼──────────────────────────────┤
       │ fmt       │ a   printf()  style  message │
       │           │ format string                │
       ├───────────┼──────────────────────────────┤
       │ ...       │ additional parameters match‐ │
       │           │ ing  %  tokens  in  the  fmt │
       │           │ string, if any               │
       └───────────┴──────────────────────────────┘

REMARKS
       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_Log
       SDL_LogCritical
       SDL_LogDebug
       SDL_LogInfo
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogVerbose
       SDL_LogWarn

===============================================================================
                                                     *SDL_LogGetOutputFunction*


NAME
       SDL_LogGetOutputFunction -- Function

SYNOPSIS
       Use this function to get the current log output function.

SYNTAX
       ┌────────────────────────────────────────────────────────────────────┐
       │ void SDL_LogGetOutputFunction(SDL_LogOutputFunction*    callback,  │
       │                               void**                    userdata)  │
       └────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ callback  │ a pointer filled in with the │
       │           │ current  log  callback;  see │
       │           │ Remarks   (https://wiki.lib‐ │
       │           │ sdl.org/SDL_LogGetOutput‐    │
       │           │ Function#Remarks)   for  de‐ │
       │           │ tails                        │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ a pointer filled in with the │
       │           │ pointer  that  is  passed to │
       │           │ callback                     │
       └───────────┴──────────────────────────────┘

REMARKS
       The function prototype for callback is:

       ┌──────────────────────────────────────────────────────────┐
       │ void SDL_LogOutputFunction(void*              userdata,  │
       │                            int                category,  │
       │                            SDL_LogPriority    priority,  │
       │                            const char*        message)   │
       └──────────────────────────────────────────────────────────┘

       where its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ what was passed as  userdata │
       │           │ to     SDL_LogSetOutputFunc‐ │
       │           │ tion()                       │
       ├───────────┼──────────────────────────────┤
       │ category  │ the category of the message; │
       │           │ see                  Remarks │
       │           │ (https://wiki.lib‐           │
       │           │ sdl.org/SDL_LogGetOutput‐    │
       │           │ Function#category)           │
       ├───────────┼──────────────────────────────┤
       │ priority  │ the priority of the message; │
       │           │ see                  Remarks │
       │           │ (https://wiki.lib‐           │
       │           │ sdl.org/SDL_LogGetOutput‐    │
       │           │ Function#priority)           │
       ├───────────┼──────────────────────────────┤
       │ message   │ the message being output     │
       └───────────┴──────────────────────────────┘

       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘

       The priority will be one of:

       ┌────────────────────────────┬──────────────────┐
       │ SDL_LOG_PRIORITY_VERBOSE   │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_DEBUG     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_INFO      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_WARN      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_ERROR     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_CRITICAL  │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_NUM_LOG_PRIORITIES     │  (internal use)  │
       └────────────────────────────┴──────────────────┘

RELATED FUNCTIONS
       SDL_LogSetOutputFunction

===============================================================================
                                                           *SDL_LogGetPriority*


NAME
       SDL_LogGetPriority -- Function

SYNOPSIS
       Use this function to get the priority of a particular log category.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ SDL_LogPriority SDL_LogGetPriority(int    category)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the  category  to query; see │
       │           │ Remarks for details          │
       └───────────┴──────────────────────────────┘

RETURN VALUES
       Returns the SDL_LogPriority for the requested category; see  Remarks  for  de‐
       tails.

REMARKS
       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘
       The returned priority will be one of:

       ┌────────────────────────────┬──────────────────┐
       │ SDL_LOG_PRIORITY_VERBOSE   │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_DEBUG     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_INFO      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_WARN      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_ERROR     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_CRITICAL  │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_NUM_LOG_PRIORITIES     │  (internal use)  │
       └────────────────────────────┴──────────────────┘

RELATED FUNCTIONS
       SDL_LogSetPriority

===============================================================================
                                                                  *SDL_LogInfo*


NAME
       SDL_LogInfo -- Function

SYNOPSIS
       Use this function to log a message with SDL_LOG_PRIORITY_INFO.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_LogInfo(int            category,  │
       │                  const char*    fmt,       │
       │                  ...)                      │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the category of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ fmt       │ a  printf()  style  messsage │
       │           │ format string                │
       ├───────────┼──────────────────────────────┤
       │ ...       │ additional parameters match‐ │
       │           │ ing  %  tokens  in  the  fmt │
       │           │ string, if any               │
       └───────────┴──────────────────────────────┘

REMARKS
       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_Log
       SDL_LogCritical
       SDL_LogDebug
       SDL_LogError
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogVerbose
       SDL_LogWarn

===============================================================================
                                                               *SDL_LogMessage*


NAME
       SDL_LogMessage -- Function

SYNOPSIS
       Use this function to log a message with the specified category and priority.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ void SDL_LogMessage(int               category,  │
       │                     SDL_LogPriority   priority,  │
       │                     const char*       fmt,       │
       │                     ...)                         │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the category of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ priority  │ the priority of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ fmt       │ a   printf()  style  message │
       │           │ format string                │
       ├───────────┼──────────────────────────────┤
       │ ...       │ additional parameters match‐ │
       │           │ ing  %  tokens  in  the  fmt │
       │           │ string, if any               │
       └───────────┴──────────────────────────────┘

REMARKS
       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘
       The returned priority will be one of:

       ┌────────────────────────────┬──────────────────┐
       │ SDL_LOG_PRIORITY_VERBOSE   │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_DEBUG     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_INFO      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_WARN      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_ERROR     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_CRITICAL  │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_NUM_LOG_PRIORITIES     │  (internal use)  │
       └────────────────────────────┴──────────────────┘

RELATED FUNCTIONS
       SDL_Log
       SDL_LogCritical
       SDL_LogDebug
       SDL_LogError
       SDL_LogInfo
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogVerbose
       SDL_LogWarn

===============================================================================
                                                              *SDL_LogMessageV*


NAME
       SDL_LogMessageV -- Function

SYNOPSIS
       Use  this  function to log a message with the specified category and priority.
       This version of SDL_LogMessage() uses a stdarg variadic argument list.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_LogMessageV(int                category,  │
       │                      SDL_LogPriority    priority,  │
       │                      const char*        fmt,       │
       │                      va_list            ap)        │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the category of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ priority  │ the priority of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ fmt       │ a  printf()  style   message │
       │           │ format string                │
       ├───────────┼──────────────────────────────┤
       │ ap        │ a variable argument list     │
       └───────────┴──────────────────────────────┘

REMARKS
       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘
       The returned priority will be one of:

       ┌────────────────────────────┬──────────────────┐
       │ SDL_LOG_PRIORITY_VERBOSE   │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_DEBUG     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_INFO      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_WARN      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_ERROR     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_CRITICAL  │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_NUM_LOG_PRIORITIES     │  (internal use)  │
       └────────────────────────────┴──────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_Log
       SDL_LogCritical
       SDL_LogDebug
       SDL_LogError
       SDL_LogInfo
       SDL_LogMessage
       SDL_LogVerbose
       SDL_LogWarn

===============================================================================
                                                              *SDL_LogPriority*


NAME
       SDL_LogPriority -- Enumerations

SYNOPSIS
       An enumeration of the predefined log priorities.

DESCRIPTION
       Values

       ┌────────────────────────────┬────────────────┐
       │ SDL_LOG_PRIORITY_VERBOSE   │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_DEBUG     │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_INFO      │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_WARN      │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_ERROR     │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_CRITICAL  │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_NUM_LOG_PRIORITIES     │ (internal use) │
       └────────────────────────────┴────────────────┘

REMARKS
       The default log priorities are as follows:

       ┌───────────────────────────────┬───────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │ SDL_LOG_PRIORITY_INFO     │
       ├───────────────────────────────┼───────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │ SDL_LOG_PRIORITY_WARN     │
       ├───────────────────────────────┼───────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │ SDL_LOG_PRIORITY_VERBOSE  │
       ├───────────────────────────────┼───────────────────────────┤
       │ everything else               │ SDL_LOG_PRIORITY_CRITICAL │
       └───────────────────────────────┴───────────────────────────┘
       If you're debugging SDL you might want to call:

       SDL_LogSetAllPriority(SDL_LOG_PRIORITY_WARN);

RELATED FUNCTIONS
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogSetAllPriority
       SDL_LogSetPriority

===============================================================================
                                                       *SDL_LogResetPriorities*


NAME
       SDL_LogResetPriorities -- Function

SYNOPSIS
       Use this function to reset all priorities to default.

SYNTAX
       ┌────────────────────────────────────┐
       │ void SDL_LogResetPriorities(void)  │
       └────────────────────────────────────┘

REMARKS
       This is called in SDL_Quit().

RELATED FUNCTIONS
       SDL_LogSetAllPriority
       SDL_LogSetPriority

===============================================================================
                                                        *SDL_LogSetAllPriority*


NAME
       SDL_LogSetAllPriority -- Function

SYNOPSIS
       Use this function to set the priority of all log categories.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ void SDL_LogSetAllPriority(SDL_LogPriority    priority)  │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ priority  │ the  SDL_LogPriority  to as‐ │
       │           │ sign; see  Remarks  for  de‐ │
       │           │ tails                        │
       └───────────┴──────────────────────────────┘

REMARKS
       ┌────────────────────────────┬────────────────┐
       │ SDL_LOG_PRIORITY_VERBOSE   │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_DEBUG     │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_INFO      │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_WARN      │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_ERROR     │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_LOG_PRIORITY_CRITICAL  │                │
       ├────────────────────────────┼────────────────┤
       │ SDL_NUM_LOG_PRIORITIES     │ (internal use) │
       └────────────────────────────┴────────────────┘

RELATED FUNCTIONS
       SDL_LogSetPriority

===============================================================================
                                                     *SDL_LogSetOutputFunction*


NAME
       SDL_LogSetOutputFunction -- Function

SYNOPSIS
       Use  this function to replace the default log output function with one of your
       own.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────┐
       │ void SDL_LogSetOutputFunction(SDL_LogOutputFunction   callback,  │
       │                               void*                   userdata)  │
       └──────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ callback  │ the function to call instead │
       │           │ of  the default; see Remarks │
       │           │ for details                  │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ a pointer that is passed  to │
       │           │ callback                     │
       └───────────┴──────────────────────────────┘

REMARKS
       The function prototype for callback is:

       ┌──────────────────────────────────────────────────────────┐
       │ void SDL_LogOutputFunction(void*              userdata,  │
       │                            int                category,  │
       │                            SDL_LogPriority    priority,  │
       │                            const char*        message)   │
       └──────────────────────────────────────────────────────────┘
       where its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ what  was passed as userdata │
       │           │ to     SDL_LogSetOutputFunc‐ │
       │           │ tion()                       │
       ├───────────┼──────────────────────────────┤
       │ category  │ the category of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ priority  │ the priority of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ message   │ the message being output     │
       └───────────┴──────────────────────────────┘
       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘
       The returned priority will be one of:

       ┌────────────────────────────┬──────────────────┐
       │ SDL_LOG_PRIORITY_VERBOSE   │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_DEBUG     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_INFO      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_WARN      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_ERROR     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_CRITICAL  │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_NUM_LOG_PRIORITIES     │  (internal use)  │
       └────────────────────────────┴──────────────────┘

RELATED FUNCTIONS
       SDL_LogGetOutputFunction

===============================================================================
                                                           *SDL_LogSetPriority*


NAME
       SDL_LogSetPriority -- Function

SYNOPSIS
       Use this function to set the priority of a particular log category.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ void SDL_LogSetPriority(int               category,  │
       │                         SDL_LogPriority   priority)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the  category  to  assign  a │
       │           │ priority to; see Remarks for │
       │           │ details                      │
       ├───────────┼──────────────────────────────┤
       │ priority  │ the  SDL_LogPriority  to as‐ │
       │           │ sign; see  Remarks  for  de‐ │
       │           │ tails                        │
       └───────────┴──────────────────────────────┘

REMARKS
       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘
       The priority can be one of:

       ┌────────────────────────────┬──────────────────┐
       │ SDL_LOG_PRIORITY_VERBOSE   │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_DEBUG     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_INFO      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_WARN      │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_ERROR     │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_LOG_PRIORITY_CRITICAL  │                  │
       ├────────────────────────────┼──────────────────┤
       │ SDL_NUM_LOG_PRIORITIES     │  (internal use)  │
       └────────────────────────────┴──────────────────┘

RELATED FUNCTIONS
       SDL_LogGetPriority
       SDL_LogSetAllPriority

===============================================================================
                                                               *SDL_LogVerbose*


NAME
       SDL_LogVerbose -- Function

SYNOPSIS
       Use this function to log a message with SDL_LOG_PRIORITY_VERBOSE.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ void SDL_LogVerbose(int           category,  │
       │                     const char*   fmt,       │
       │                     ...)                     │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the category of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ fmt       │ a  printf()  style   message │
       │           │ format string                │
       ├───────────┼──────────────────────────────┤
       │ ...       │ additional parameters match‐ │
       │           │ ing  %  tokens  in  the  fmt │
       │           │ string, if any               │
       └───────────┴──────────────────────────────┘

REMARKS
       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_Log
       SDL_LogCritical
       SDL_LogDebug
       SDL_LogError
       SDL_LogInfo
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogWarn

===============================================================================
                                                                  *SDL_LogWarn*


NAME
       SDL_LogWarn -- Function

SYNOPSIS
       Use this function to log a message with SDL_LOG_PRIORITY_WARN.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_LogWarn(int            category,  │
       │                  const char*    fmt,       │
       │                  ...)                      │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ category  │ the category of the message; │
       │           │ see Remarks for details      │
       ├───────────┼──────────────────────────────┤
       │ fmt       │ a  printf()  style   message │
       │           │ format string                │
       ├───────────┼──────────────────────────────┤
       │ ...       │ additional parameters match‐ │
       │           │ ing  %  tokens  in  the  fmt │
       │           │ string, if any               │
       └───────────┴──────────────────────────────┘

REMARKS
       The category will be one of:

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_LOG_CATEGORY_APPLICATION  │  application log             │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ERROR        │  error log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_ASSERT       │  assert log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_SYSTEM       │  system log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_AUDIO        │  audio log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_VIDEO        │  video log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RENDER       │  render log                  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_INPUT        │  input log                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_TEST         │  test log                    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_RESERVED#    │  # = 1-10; reserved for fu‐  │
       │                               │  ture SDL library use        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_LOG_CATEGORY_CUSTOM       │  reserved  for  application  │
       │                               │  use;        see        Re‐  │
       │                               │  marks(https://wiki.lib‐     │
       │                               │  sdl.org/SDL_LOG_CATE‐       │
       │                               │  GORY#Remarks) for details   │
       └───────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_Log
       SDL_LogCritical
       SDL_LogDebug
       SDL_LogError
       SDL_LogInfo
       SDL_LogMessage
       SDL_LogMessageV
       SDL_LogVerbose

===============================================================================
                                                                *SDL_LowerBlit*


NAME
       SDL_LowerBlit -- Function

SYNOPSIS
       Use this function to perform low-level surface blitting only.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ int SDL_LowerBlit(SDL_Surface*    src,      │
       │                   SDL_Rect*       srcrect,  │
       │                   SDL_Surface*    dst,      │
       │                   SDL_Rect*       dstrect)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ src      │ the SDL_Surface structure to │
       │          │ be copied from               │
       ├──────────┼──────────────────────────────┤
       │ srcrect  │ the  SDL_Surface   structure │
       │          │ representing  the  rectangle │
       │          │ to be  copied,  or  NULL  to │
       │          │ copy the entire sturface     │
       ├──────────┼──────────────────────────────┤
       │ dst      │ the   SDL_Surface  structure │
       │          │ that is the blit target      │
       ├──────────┼──────────────────────────────┤
       │ dstrect  │ the SDL_Rect structure  rep‐ │
       │          │ resenting the rectangle that │
       │          │ is copied into               │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       This  is  a semi-private blit function and it performs low-level surface blit‐
       ting, assuming the input rectangles have already been clipped.

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_UpperBlit

===============================================================================
                                                          *SDL_LowerBlitScaled*


NAME
       SDL_LowerBlitScaled -- Function

SYNOPSIS
       Use this function to perform low-level surface scaled blitting only.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ int SDL_LowerBlitScaled(SDL_Surface*    src,      │
       │                         SDL_Rect*       srcrect,  │
       │                         SDL_Surface*    dst,      │
       │                         SDL_Rect*       dstrect)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ src      │ the SDL_Surface structure to │
       │          │ be copied from               │
       ├──────────┼──────────────────────────────┤
       │ srcrect  │ the SDL_Rect structure  rep‐ │
       │          │ resenting  the  rectangle to │
       │          │ be copied                    │
       ├──────────┼──────────────────────────────┤
       │ dst      │ the  SDL_Surface   structure │
       │          │ that is the blit target      │
       ├──────────┼──────────────────────────────┤
       │ dstrect  │ the  SDL_Rect structure rep‐ │
       │          │ resenting the rectangle that │
       │          │ is copied into               │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       This is a semi-private function and it performs  low-level  surface  blitting,
       assuming the input rectangle have already been clipped.

RELATED FUNCTIONS
       SDL_BlitScaled

===============================================================================
                                                                 *SDL_MUSTLOCK*


NAME
       SDL_MUSTLOCK -- Function

SYNOPSIS
       Use this function to determine whether a surface must be locked for access.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ SDL_bool SDL_MUSTLOCK(SDL_Surface*    surface)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ query                        │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the surface must be locked for access, SDL_FALSE if not.

RELATED FUNCTIONS
       SDL_LockSurface

===============================================================================
                                                                   *SDL_MapRGB*


NAME
       SDL_MapRGB -- Function

SYNOPSIS
       Use  this  function  to map an RGB triple to an opaque pixel value for a given
       pixel format.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ Uint32 SDL_MapRGB(const SDL_PixelFormat*    format,  │
       │                   Uint8                     r,       │
       │                   Uint8                     g,       │
       │                   Uint8                     b)       │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ format  │ an SDL_PixelFormat structure │
       │         │ describing the format of the │
       │         │ pixel                        │
       ├─────────┼──────────────────────────────┤
       │ r       │ the  red  component  of  the │
       │         │ pixel in the range 0-255     │
       ├─────────┼──────────────────────────────┤
       │ g       │ the  green  component of the │
       │         │ pixel in the range 0-255     │
       ├─────────┼──────────────────────────────┤
       │ b       │ the blue  component  of  the │
       │         │ pixel in the range 0-255     │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns a pixel value; see Remarks for details.

REMARKS
       This  function  maps the RGB color value to the specified pixel format and re‐
       turns the pixel value best approximating the given RGB  color  value  for  the
       given pixel format.

       If the format has a palette (8-bit) the index of the closest matching color in
       the palette will be returned.

       If the specified pixel format has an alpha component it will  be  returned  as
       all 1 bits (fully opaque).

       If  the pixel format bpp (color depth) is less than 32-bpp then the unused up‐
       per bits of the return value can safely be ignored (e.g., with a 16-bpp format
       the  return  value  can  be assigned to a Uint16, and similarly a Uint8 for an
       8-bpp format).

RELATED FUNCTIONS
       SDL_GetRGB
       SDL_GetRGBA
       SDL_MapRGBA

===============================================================================
                                                                  *SDL_MapRGBA*


NAME
       SDL_MapRGBA -- Function

SYNOPSIS
       Use  this function to map an RGBA quadruple to a pixel value for a given pixel
       format.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ Uint32 SDL_MapRGBA(const SDL_PixelFormat*   format,  │
       │                    Uint8                    r,       │
       │                    Uint8                    g,       │
       │                    Uint8                    b,       │
       │                    Uint8                    a)       │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ format  │ an SDL_PixelFormat structure │
       │         │ describing the format of the │
       │         │ pixel                        │
       ├─────────┼──────────────────────────────┤
       │ r       │ the  red  component  of  the │
       │         │ pixel in the range 0-255     │
       ├─────────┼──────────────────────────────┤
       │ g       │ the  green  component of the │
       │         │ pixel in the range 0-255     │
       ├─────────┼──────────────────────────────┤
       │ b       │ the blue  component  of  the │
       │         │ pixel in the range 0-255     │
       ├─────────┼──────────────────────────────┤
       │ a       │ the  alpha  component of the │
       │         │ pixel in the range 0-255     │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns a pixel value; see Remarks for details.

REMARKS
       This function maps the RGB color value to the specified pixel format  and  re‐
       turns  the  pixel  value  best approximating the given RGB color value for the
       given pixel format.

       If the format has a palette (8-bit) the index of the closest matching color in
       the palette will be returned.

       If  the  specified  pixel format has an alpha component it will be returned as
       all 1 bits (fully opaque).

       If the pixel format bpp (color depth) is less than 32-bpp then the unused  up‐
       per bits of the return value can safely be ignored (e.g., with a 16-bpp format
       the return value can be assigned to a Uint16, and similarly  a  Uint8  for  an
       8-bpp format).

RELATED FUNCTIONS
       SDL_GetRGB
       SDL_GetRGBA
       SDL_MapRGB

===============================================================================
                                                   *SDL_MasksToPixelFormatEnum*


NAME
       SDL_MasksToPixelFormatEnum -- Function

SYNOPSIS
       Use this function to convert a bpp value and RGBA masks to an enumerated pixel
       format.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ Uint32 SDL_MasksToPixelFormatEnum(int       bpp,    │
       │                                   Uint32    Rmask,  │
       │                                   Uint32    Gmask,  │
       │                                   Uint32    Bmask,  │
       │                                   Uint32    Amask)  │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ bpp    │ a bits per pixel value; usu‐ │
       │        │ ally 15, 16, or 32           │
       ├────────┼──────────────────────────────┤
       │ Rmask  │ the red mask for the format  │
       ├────────┼──────────────────────────────┤
       │ Gmask  │ the  green mask for the for‐ │
       │        │ mat                          │
       ├────────┼──────────────────────────────┤
       │ Bmask  │ the blue mask for the format │
       ├────────┼──────────────────────────────┤
       │ Amask  │ the alpha mask for the  for‐ │
       │        │ mat                          │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns one of the following SDL_PixelFormatEnum values:

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar  mode:  Y  + V + U (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar mode: Y + U  +  V  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packet  mode: Y0 + U0 + Y1 + │
       │                              │ V0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed mode: U0 + Y0 + V0  + │
       │                              │ Y1 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed  mode: Y0 + V0 + Y1 + │
       │                              │ U0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar mode: Y + U/V  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar mode: Y + V/U  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_PixelFormatEnumToMasks

===============================================================================
                                                           *SDL_MaximizeWindow*


NAME
       SDL_MaximizeWindow -- Function

SYNOPSIS
       Use this function to make a window as large as possible.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_MaximizeWindow(SDL_Window*   window)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬────────────────────────┐
       │ window  │ the window to maximize │
       └─────────┴────────────────────────┘

RELATED FUNCTIONS
       SDL_MinimizeWindow
       SDL_RestoreWindow

===============================================================================
                                                     *SDL_MessageBoxButtonData*


NAME
       SDL_MessageBoxButtonData -- Structure

SYNOPSIS
       A structure that contains individual button data for a message box.

DATA FIELDS
       ┌──────────────┬──────────┬───────────────────────┐
       │ Uint32       │ flags    │ one   of  the  values │
       │              │          │ from     SDL_Message‐ │
       │              │          │ BoxButtonFlags        │
       ├──────────────┼──────────┼───────────────────────┤
       │ int          │ buttonid │ user  defined  button │
       │              │          │ id  (value   returned │
       │              │          │ via  SDL_ShowMessage‐ │
       │              │          │ Box())                │
       ├──────────────┼──────────┼───────────────────────┤
       │ const char*  │ text     │ the UTF-8 button text │
       └──────────────┴──────────┴───────────────────────┘

RELATED ENUMERATIONS
       SDL_MessageBoxButtonFlags

RELATED STRUCTURES
       SDL_MessageBoxData

RELATED FUNCTIONS
       SDL_ShowMessageBox

===============================================================================
                                                    *SDL_MessageBoxButtonFlags*


NAME
       SDL_MessageBoxButtonFlags -- Enumerations

SYNOPSIS
       An enumeration of flags for SDL_MessageBoxButtonData.

DESCRIPTION
       Values

       ┌──────────────────────────────────────────┬──────────────────────────────┐
       │ SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT  │ marks   the  default  button │
       │                                          │ when return is hit           │
       ├──────────────────────────────────────────┼──────────────────────────────┤
       │ SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT  │ marks  the  default   button │
       │                                          │ when escape is hit           │
       └──────────────────────────────────────────┴──────────────────────────────┘

RELATED STRUCTURES
       SDL_MessageBoxButtonData

===============================================================================
                                                          *SDL_MessageBoxColor*


NAME
       SDL_MessageBoxColor -- Structure

SYNOPSIS
       A structure that contains RGB value used in an SDL_MessageBoxColorScheme.

DATA FIELDS
       ┌────────┬───┬───────────────────────┐
       │ Uint8  │ r │ the  red component in │
       │        │   │ the range 0-255       │
       ├────────┼───┼───────────────────────┤
       │ Uint8  │ g │ the  green  component │
       │        │   │ in the range 0-255    │
       ├────────┼───┼───────────────────────┤
       │ Uint8  │ b │ the blue component in │
       │        │   │ the range 0-255       │
       └────────┴───┴───────────────────────┘

RELATED STRUCTURES
       SDL_MessageBoxColorScheme

===============================================================================
                                                    *SDL_MessageBoxColorScheme*


NAME
       SDL_MessageBoxColorScheme -- Structure

SYNOPSIS
       A structure that contains a set of colors to use for message box dialogs.

DATA FIELDS
       ┌─────────────────────────┬────────┬───┐
       │ SDL_MessageBoxColor[5]  │ colors │   │
       └─────────────────────────┴────────┴───┘

RELATED ENUMERATIONS
       SDL_MessageBoxColorType

RELATED STRUCTURES
       SDL_MessageBoxColor
       SDL_MessageBoxData

===============================================================================
                                                      *SDL_MessageBoxColorType*


NAME
       SDL_MessageBoxColorType -- Enumerations

SYNOPSIS
       An  enumeration  of  position  inside  the  colors array of SDL_MessageBoxCol‐
       orScheme.

DESCRIPTION
       Values

       ┌─────────────────────────────────────────┬───┐
       │ SDL_MESSAGEBOX_COLOR_BACKGROUND         │   │
       ├─────────────────────────────────────────┼───┤
       │ SDL_MESSAGEBOX_COLOR_TEXT               │   │
       ├─────────────────────────────────────────┼───┤
       │ SDL_MESSAGEBOX_COLOR_BUTTON_BORDER      │   │
       ├─────────────────────────────────────────┼───┤
       │ SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND  │   │
       ├─────────────────────────────────────────┼───┤
       │ SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED    │   │
       ├─────────────────────────────────────────┼───┤
       │ SDL_MESSAGEBOX_COLOR_MAX                │   │
       └─────────────────────────────────────────┴───┘

RELATED STRUCTURES
       SDL_MessageBoxColorScheme

===============================================================================
                                                           *SDL_MessageBoxData*


NAME
       SDL_MessageBoxData -- Structure

SYNOPSIS
       A  structure  that  contains  title, text, window and other data for a message
       box.

DATA FIELDS
       ┌────────────────────────────────────┬─────────────┬───────────────────────┐
       │ Uint32                             │ flags       │ an       SDL_Message‐ │
       │                                    │             │ BoxFlags              │
       ├────────────────────────────────────┼─────────────┼───────────────────────┤
       │ SDL_Window*                        │ window      │ an   paraent  window, │
       │                                    │             │ can be NULL           │
       ├────────────────────────────────────┼─────────────┼───────────────────────┤
       │ const char*                        │ title       │ an UTF-8 title        │
       ├────────────────────────────────────┼─────────────┼───────────────────────┤
       │ const char*                        │ message     │ an UTF-8 message text │
       ├────────────────────────────────────┼─────────────┼───────────────────────┤
       │ int                                │ numbuttons  │ the number of buttons │
       ├────────────────────────────────────┼─────────────┼───────────────────────┤
       │ const SDL_MessageBoxButtonData*    │ buttons     │ an array of  SDL_Mes‐ │
       │                                    │             │ sageBoxButtonData     │
       │                                    │             │ with length  of  num‐ │
       │                                    │             │ buttons               │
       ├────────────────────────────────────┼─────────────┼───────────────────────┤
       │ const SDL_MessageBoxColorSchemes*  │ colorScheme │ an SDL_MessageBoxCol‐ │
       │                                    │             │ orScheme, can be NULL │
       │                                    │             │ to  use  system  set‐ │
       │                                    │             │ tings                 │
       └────────────────────────────────────┴─────────────┴───────────────────────┘

REMARKS
       See SDL_ShowMessageBox() for a complete code example.

RELATED ENUMERATIONS
       SDL_MessageBoxFlags

RELATED STRUCTURES
       SDL_MessageBoxButtonData
       SDL_MessageBoxColorScheme

RELATED FUNCTIONS
       SDL_ShowMessageBox

===============================================================================
                                                          *SDL_MessageBoxFlags*


NAME
       SDL_MessageBoxFlags -- Enumerations

SYNOPSIS
       An  enumeration  of message box flags (e.g. if supported message box will dis‐
       play warning icon).

DESCRIPTION
       Values

       ┌─────────────────────────────┬──────────────────────┐
       │ SDL_MESSAGEBOX_ERROR        │ error dialog         │
       ├─────────────────────────────┼──────────────────────┤
       │ SDL_MESSAGEBOX_WARNING      │ warning dialog       │
       ├─────────────────────────────┼──────────────────────┤
       │ SDL_MESSAGEBOX_INFORMATION  │ informational dialog │
       └─────────────────────────────┴──────────────────────┘

RELATED STRUCTURES
       SDL_MessageBoxData

RELATED FUNCTIONS
       SDL_ShowSimpleMessageBox

===============================================================================
                                                           *SDL_MinimizeWindow*


NAME
       SDL_MinimizeWindow -- Function

SYNOPSIS
       Use this function to minimize a window to an iconic representation.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_MinimizeWindow(SDL_Window*   window)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬────────────────────────┐
       │ window  │ the window to minimize │
       └─────────┴────────────────────────┘

RELATED FUNCTIONS
       SDL_MaximizeWindow
       SDL_RestoreWindow

===============================================================================
                                                                 *SDL_MixAudio*


NAME
       SDL_MixAudio -- Function

SYNOPSIS
       This  function  is  a legacy means of mixing audio. New programs might want to
       use SDL_MixAudioFormat() instead.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_MixAudio(Uint8*          dst,     │
       │                   const Uint8*    src,     │
       │                   Uint32          len,     │
       │                   int             volume)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ dst     │ the  destination   for   the │
       │         │ mixed audio                  │
       ├─────────┼──────────────────────────────┤
       │ src     │ the  source  audio buffer to │
       │         │ be mixed                     │
       ├─────────┼──────────────────────────────┤
       │ len     │ the length of the audio buf‐ │
       │         │ fer in bytes                 │
       ├─────────┼──────────────────────────────┤
       │ volume  │ ranges   from   0-128,   and │
       │         │ should     be     set     to │
       │         │ SDL_MIX_MAXVOLUME  for  full │
       │         │ audio volume                 │
       └─────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────┐
       │ void    MyAudioCallback(void*     udata,  │
       │ Uint8* stream, int len) {                 │
       │   extern const Uint8* mixdata;            │
       │   // make sure this is silence            │
       │   SDL_memset(stream, 0, len);             │
       │   //  mix our audio against the silence,  │
       │ at 50% volume.                            │
       │   SDL_MixAudio(stream,   mixData,   len,  │
       │ SDL_MIX_MAXVOLUME / 2);                   │
       │ }                                         │
       └───────────────────────────────────────────┘

REMARKS
       ┌─────────────────────────────────────────────────────┐
       │ SDL_MixAudioFormat(dst, src, format, len, volume);  │
       └─────────────────────────────────────────────────────┘
       where  format  is  the  obtained  format  of  the audio device from the legacy
       SDL_OpenAudio() function.

RELATED FUNCTIONS
       SDL_MixAudioFormat

===============================================================================
                                                           *SDL_MixAudioFormat*


NAME
       SDL_MixAudioFormat -- Function

SYNOPSIS
       Use this function to mix audio data in a specified format.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_MixAudioFormat(Uint8*            dst,     │
       │                         const Uint8*      src,     │
       │                         SDL_AudioFormat   format,  │
       │                         Uint32            len,     │
       │                         int               volume)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ dst     │ the   destination   for  the │
       │         │ mixed audio                  │
       ├─────────┼──────────────────────────────┤
       │ src     │ the source audio  buffer  to │
       │         │ be mixed                     │
       ├─────────┼──────────────────────────────┤
       │ format  │ the  SDL_AudioFormat  struc‐ │
       │         │ ture  representing  the  de‐ │
       │         │ sired audio format           │
       ├─────────┼──────────────────────────────┤
       │ len     │ the length of the audio buf‐ │
       │         │ fer in bytes                 │
       ├─────────┼──────────────────────────────┤
       │ volume  │ ranges   from   0-128,   and │
       │         │ should     be     set     to │
       │         │ SDL_MIX_MAXVOLUME  for  full │
       │         │ audio volume                 │
       └─────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────┐
       │ void    MyAudioCallback(void*     udata,  │
       │ Uint8* stream, int len) {                 │
       │   extern SDL_AudioFormat deviceFormat;    │
       │   extern const Uint8* mixdata;            │
       │   // make sure this is silence            │
       │   SDL_memset(stream, 0, len);             │
       │   // mix our audio against the  silence,  │
       │ at 50% volume.                            │
       │   SDL_MixAudioFormat(stream,    mixData,  │
       │ deviceFormat, len,  SDL_MIX_MAXVOLUME  /  │
       │ 2);                                       │
       │ }                                         │
       └───────────────────────────────────────────┘

REMARKS
       This  takes  an audio buffer src of len bytes of format data and mixes it into
       dst performing addition, volume adjustment, and overflow clipping. The  buffer
       pointed to by dst must also be len bytes of format data.

       This is provided for convenience -- you can mix your own audio data.

       Do  not  use this function for mixing together more than two streams of sample
       data. The output from repeated application of this function may  be  distorted
       by clipping, because there is no accumulator with greater range than the input
       (not to mention this being an inefficient way of doing it). Use  mixing  func‐
       tions from SDL_mixer, OpenAL (http://www.openal.org/), or write your own mixer
       instead.

       It is a common misconception that this function is  required  to  write  audio
       data to an output stream in an audio callback. While you can do that, SDL_Mix‐
       AudioFormat() is really only needed when you're mixing a single  audio  stream
       with a volume adjustment.

===============================================================================
                                                *SDL_MostSignificantBitIndex32*


NAME
       SDL_MostSignificantBitIndex32 -- Function

SYNOPSIS
       Use  this  function  to  get  the index of the most significant (set) bit in a
       32-bit number. This is also the same as the base 2 logarithm of the number.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ int SDL_MostSignificantBitIndex32(Uint32    x)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ x  │ the number to find  the  MSB │
       │    │ of                           │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns the index of the most significant bit of x, or -1 if x is 0.

CODE EXAMPLES
       ┌───────────────────────────────────────────┐
       │ #include "SDL_bits.h"                     │
       │                                           │
       │ if (bitmask) {                            │
       │   int  index = SDL_MostSignificantBitIn‐  │
       │ dex32(bitmask); }                         │
       └───────────────────────────────────────────┘

===============================================================================
                                                         *SDL_MouseButtonEvent*


NAME
       SDL_MouseButtonEvent -- Structure

SYNOPSIS
       A structure that contains mouse button event information.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ the    event    type; │
       │         │           │ SDL_MOUSEBUTTONDOWN   │
       │         │           │ or SDL_MOUSEBUTTONUP  │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ timestamp    of   the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ windowID  │ the window with mouse │
       │         │           │ focus, if any         │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ which     │ the   mouse  instance │
       │         │           │ id,                or │
       │         │           │ SDL_TOUCH_MOUSED; see │
       │         │           │ Remarks for details   │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint8   │ button    │ the    button    that │
       │         │           │ changed;  see Remarks │
       │         │           │ for details           │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint8   │ state     │ the state of the but‐ │
       │         │           │ ton;  SDL_PRESSED  or │
       │         │           │ DL_RELEASED           │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint8   │ clicks    │ 1 for single-click, 2 │
       │         │           │ for     double-click, │
       │         │           │ etc. (>= SDL 2.0.2)   │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ x         │ X  coordinate,  rela‐ │
       │         │           │ tive to window        │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ y         │ Y  coordinate,  rela‐ │
       │         │           │ tive to window        │
       └─────────┴───────────┴───────────────────────┘

REMARKS
       SDL_MouseButtonEvent is a member of the SDL_Event union and is  used  when  an
       event  of type SDL_MOUSEBUTTONDOWN or SDL_MOUSEBUTTONUP is reported. You would
       access it through the event's button field.

       An SDL_MOUSEBUTTONDOWN or  SDL_MOUSEBUTTONUP  event  occurs  whenever  a  user
       presses or releases a button on a mouse.

       button may be on of:

       ┌────────────────────┐
       │ SDL_BUTTON_LEFT    │
       ├────────────────────┤
       │ SDL_BUTTON_MIDDLE  │
       ├────────────────────┤
       │ SDL_BUTTON_RIGHT   │
       ├────────────────────┤
       │ SDL_BUTTON_X1      │
       ├────────────────────┤
       │ SDL_BUTTON_X2      │
       └────────────────────┘

       which  may be SDL_TOUCH_MOUSEID, for events that were generated by a touch in‐
       put device, and not a real mouse. You might want to  ignore  such  events,  if
       your application already handles SDL_TouchFingerEvent.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_MouseMotionEvent
       SDL_MouseWheelEvent

RELATED FUNCTIONS
       SDL_GetMouseState
       SDL_GetRelativeMouseState

===============================================================================
                                                            *SDL_MouseIsHaptic*


NAME
       SDL_MouseIsHaptic -- Function

SYNOPSIS
       Use this function to get whether or not the current mouse has haptic capabili‐
       ties.

SYNTAX
       ┌──────────────────────────────┐
       │ int SDL_MouseIsHaptic(void)  │
       └──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the mouse  is  haptic  or  SDL_FALSE  if  it  isn't;  call
       SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticOpenFromMouse

===============================================================================
                                                         *SDL_MouseMotionEvent*


NAME
       SDL_MouseMotionEvent -- Structure

SYNOPSIS
       A structure that contains mouse motion event information.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ the    event    type; │
       │         │           │ SDL_MOUSEMOTION       │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ timestamp   of    the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ windowID  │ the window with mouse │
       │         │           │ focus; if any         │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ which     │ the  mouse   instance │
       │         │           │ id, or SDL_TOUCH_MOU‐ │
       │         │           │ SEID; see Remarks for │
       │         │           │ details               │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ state     │ the state of the but‐ │
       │         │           │ ton; see Remarks  for │
       │         │           │ details               │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ x         │ X  coordinate,  rela‐ │
       │         │           │ tive to window        │
       ├─────────┼───────────┼───────────────────────┤
       │ Sin32   │ y         │ Y  coordinate,  rela‐ │
       │         │           │ tive to window        │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ xrel      │ relative   motion  in │
       │         │           │ the X direction       │
       ├─────────┼───────────┼───────────────────────┤
       │ Sin32   │ yrel      │ relative  motion   in │
       │         │           │ the Y direction       │
       └─────────┴───────────┴───────────────────────┘

REMARKS
       SDL_MouseMotionEvent  is  a  member of the SDL_Event union and is used when an
       event of type SDL_MOUSEMOTION is reported. You would  access  it  through  the
       event's motion field.

       An SDL_MOUSEMOTION event occurs whenever a user moves the mouse within the ap‐
       plication window or when SDL_WarpMouseInWindow() is called.

       state is a 32-bit button bitmask of the current button state and is  the  same
       as that returned by SDL_GetMouseState(). You can test different buttons by us‐
       ing the following masks:

       ┌────────────────────┐
       │ SDL_BUTTON_LMASK   │
       ├────────────────────┤
       │ SDL_BUTTON_MMASK   │
       ├────────────────────┤
       │ SDL_BUTTON_RMASK   │
       ├────────────────────┤
       │ SDL_BUTTON_X1MASK  │
       ├────────────────────┤
       │ SDL_BUTTON_X2MASK  │
       └────────────────────┘

       which may be SDL_TOUCH_MOUSEID, for events that were generated by a touch  in‐
       put  device,  and  not  a real mouse. You might want to ignore such events, if
       your application already handles SDL_TouchFingerEvent.

       Relative motion is stored in xrel and yrel and is relative to the last  motion
       event. If relative mouse mode is enabled with SDL_SetRelativeMouseMode(), then
       the mouse will give relative motion events even when the  cursor  reaches  the
       edge of the screen.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_MouseButtonEvent
       SDL_MouseWheelEvent

RELATED FUNCTIONS
       SDL_GetMouseState
       SDL_GetRelativeMouseState
       SDL_SetRelativeMouseMode

===============================================================================
                                                          *SDL_MouseWheelEvent*


NAME
       SDL_MouseWheelEvent -- Structure

SYNOPSIS
       A structure that contains mouse wheel event information.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ SDL_MOUSEWHEEL        │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ timestamp    of   the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ windowID  │ the window with mouse │
       │         │           │ focus, if any         │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ which     │ the   mouse  instance │
       │         │           │ id, or SDL_TOUCH_MOU‐ │
       │         │           │ SEID; see Remarks for │
       │         │           │ details               │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ x         │ the  amount  scrolled │
       │         │           │ horizontally,   posi‐ │
       │         │           │ tive to the right and │
       │         │           │ negative to the left  │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ y         │ the  amount  scrolled │
       │         │           │ vertically,  positive │
       │         │           │ away  from  the  user │
       │         │           │ and  negative  toward │
       │         │           │ the uer               │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ direction │ SDL_MOUSEWHEEL_NORMAL │
       │         │           │ or         SDL_MOUSE‐ │
       │         │           │ WHEEL_FLIPPED;    see │
       │         │           │ Remarks  for  details │
       │         │           │ (>= SDL 2.0.4)        │
       └─────────┴───────────┴───────────────────────┘

CODE EXAMPLES
       SDL_Event event;
       while (SDL_PollEvent(&event))
       {
         if (event.type == SDL_MOUSEWHEEL)
         {
           if (event.wheel.y > 0) // scroll up
           {
             // pull up code here!
           }
           else if (event.wheel.y < 0) // scroll down
           {
             // pull down code here!
           }
           else if (event.wheel.x > 0)  // scroll right
           {
             // ...
           }
           else if (event.wheel.x < 0)  // scroll left
           {
             // ...
           }
         }
         else if (event.type == SDL_MOUSEBUTTONDOWN)
         {
           // ... handle mouse clicks ...
         }
         // ... handle other kinds of events ...
       }

REMARKS
       SDL_MouseWheelEvent  is  a  member  of the SDL_Event union and is used when an
       event of type SDL_MOUSEWHEEL is reported. You  would  access  it  through  the
       event's wheel field.

       An SDL_MOUSEWHEEL event occurs whenever a user moves the mouse wheel.

       Movements  to  the  left  generate negative x values and to the right generate
       positive x values. Movements down (scroll backward) generate negative y values
       and up (scroll forward) generate positive y values.

       which  may be SDL_TOUCH_MOUSEID, for events that were generated by a touch in‐
       put device, and not a real mouse. You might want to  ignore  such  events,  if
       your application already handles SDL_TouchFingerEvent.

       SDL  does  not  abstract  the  mouse  wheel scroll directions to be consistent
       across all  platforms  (SDL_MOUSEWHEEL_NORMAL).  If  direction  is  SDL_MOUSE‐
       WHEEL_FLIPPED the values in x and y will be opposite. Multiply by -1 to change
       them back.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_MouseButtonEvent
       SDL_MouseMotionEvent

===============================================================================
                                                        *SDL_MultiGestureEvent*


NAME
       SDL_MultiGestureEvent -- Structure

SYNOPSIS
       A structure that contains multiple finger gesture event information.

DATA FIELDS
       ┌──────────────┬────────────┬───────────────────────┐
       │ Uint32       │ type       │ SDL_MULTIGESTURE      │
       ├──────────────┼────────────┼───────────────────────┤
       │ Uint32       │ timestamp  │ timestamp    of   the │
       │              │            │ event                 │
       ├──────────────┼────────────┼───────────────────────┤
       │ SDL_TouchID  │ touchId    │ the touch device id   │
       ├──────────────┼────────────┼───────────────────────┤
       │ float        │ dTheta     │ the amount  that  the │
       │              │            │ fingers  rotated dur‐ │
       │              │            │ ing this motion       │
       ├──────────────┼────────────┼───────────────────────┤
       │ float        │ dDist      │ the amount  that  the │
       │              │            │ fingers  pinched dur‐ │
       │              │            │ ing this motion       │
       ├──────────────┼────────────┼───────────────────────┤
       │ float        │ x          │ the normalized center │
       │              │            │ of gesture            │
       ├──────────────┼────────────┼───────────────────────┤
       │ float        │ y          │ the normalized center │
       │              │            │ of gesture            │
       ├──────────────┼────────────┼───────────────────────┤
       │ Uint16       │ numFingers │ the number of fingers │
       │              │            │ used in the gesture   │
       └──────────────┴────────────┴───────────────────────┘

REMARKS
       SDL_MultiGestureEvent  is  a member of the SDL_Event union and is used when an
       event of type SDL_MULTIGESTURE is reported. You would access  it  through  the
       event's mgesture field.

       For     more     information,    see:    README-gesture.md    (https://hg.lib‐
       sdl.org/SDL/file/default/docs/README-gesture.md)

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_DollarGestureEvent
       SDL_Event

===============================================================================
                                                               *SDL_NumHaptics*


NAME
       SDL_NumHaptics -- Function

SYNOPSIS
       Use  this  function to count the number of haptic devices attached to the sys‐
       tem.

SYNTAX
       ┌───────────────────────────┐
       │ int SDL_NumHaptics(void)  │
       └───────────────────────────┘

RETURN VALUE
       Returns the number of haptic devices detected on the system or a negative  er‐
       ror code on failure; call SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_HapticName

===============================================================================
                                                             *SDL_NumJoysticks*


NAME
       SDL_NumJoysticks -- Function

SYNOPSIS
       Use this function to count the number of joysticks attached to the system.

SYNTAX
       ┌─────────────────────────────┐
       │ int SDL_NumJoysticks(void)  │
       └─────────────────────────────┘

RETURN VALUE
       Returns  the  number of attached joysticks on success or a negative error code
       on failure; call SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_JoystickName
       SDL_JoystickOpen

===============================================================================
                                                                *SDL_OpenAudio*


NAME
       SDL_OpenAudio -- Function

SYNOPSIS
       This  function  is  a  legacy  means of opening the audio device. New programs
       might want to use SDL_OpenAudioDevice() instead.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ int SDL_OpenAudio(SDL_AudioSpec*    desired,   │
       │                   SDL_AudioSpec*    obtained)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ desired   │ an  SDL_AudioSpec  structure │
       │           │ representing   the   desired │
       │           │ output format                │
       ├───────────┼──────────────────────────────┤
       │ obtained  │ an  SDL_AudioSpec  structure │
       │           │ filled  in  with  the actual │
       │           │ parameters, or NULL          │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       This function opens the audio device with the desired parameters, and  returns
       0  if  successful,  placing  the  actual  hardware parameters in the structure
       pointed to by obtained.

       If obtained is NULL, the audio data passed to the callback  function  will  be
       guarunteed  to be in the requested format, and will be automatically converted
       to the actual hardware audio format if necessary. If obtainedis NULL,  desired
       will have fields modified.

       This  function  returns a negative error code on failure to open the audio de‐
       vice or failure to set up the audio thread; call SDL_GetError() for  more  in‐
       formation.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_AudioSpec want, have;                                                                                   │
       │                                                                                                             │
       │ SDL_memset(&want, 0, sizeof(want));   /* or SDL_zero(want) */                                               │
       │ want.freq = 48000;                                                                                          │
       │ want.format = AUDIO_F32;                                                                                    │
       │ want.channels = 2;                                                                                          │
       │ want.samples = 4096;                                                                                        │
       │ want.callback = MyAudioCallback;  /* you wrote this function elsewhere -- see SDL_AudioSpec for details */  │
       │                                                                                                             │
       │ if (SDL_OpenAudio(&want, &have) < 0)                                                                        │
       │ {                                                                                                           │
       │   SDL_Log("Failed to open audio: %s", SDL_GetError());                                                      │
       │ }                                                                                                           │
       │ else                                                                                                        │
       │ {                                                                                                           │
       │   if (have.format != want.format)                                                                           │
       │   {                                                                                                         │
       │     SDL_Log("We didn't get Float32 audio format.");                                                         │
       │   }                                                                                                         │
       │   SDL_PauseAudio(0);  /*  start audio playing. */                                                           │
       │   SDL_Delay(5000);    /*  let the audio callback play some sound for 5 seconds */                           │
       │   SDL_CloseAudio();                                                                                         │
       │ }                                                                                                           │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This  function  remains  for compatibility with SDL 1.2, but also because it's
       slightly easier to use than the new functions in SDL 2.0. The new, more power‐
       ful, and preferred way to do this is SDL_OpenAudioDevice().

       This function is roughly equivalent to:

       ┌───────────────────────────────────────────────────────────────────────────────┐
       │ SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);  │
       └───────────────────────────────────────────────────────────────────────────────┘
       with two notable exceptions:

       *  If obtained is NULL, we use desired (and allow no changes), which means de‐
       sired will be modified to have the correct values for silence,  etc,  and  SDL
       will convert any differences between your app's specific request and the hard‐
       ware behind the scenes.

       * The return value is always success or failure, and not a  device  ID,  which
       means you can only have one device open at a time with this function.

RELATED FUNCTIONS
       SDL_CloseAudio
       SDL_LockAudio
       SDL_PauseAudio
       SDL_UnlockAudio

RELATED STRUCTURES
       SDL_AudioSpec

===============================================================================
                                                          *SDL_OpenAudioDevice*


NAME
       SDL_OpenAudioDevice -- Function

SYNOPSIS
       Use this function to open a specific audio device.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_AudioDeviceID SDL_OpenAudioDevice(const char*             device,           │
       │                                       int                     iscapture,        │
       │                                       const SDL_AudioSpec*    desired,          │
       │                                       SDL_AudioSpec*          obtained,         │
       │                                       int                     allowed_changes)  │
       └─────────────────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────────────┬──────────────────────────────┐
       │ device           │ a  UTF-8  string reported by │
       │                  │ SDL_GetAudioDeviceName();    │
       │                  │ see Remarks                  │
       ├──────────────────┼──────────────────────────────┤
       │ iscapture        │ non-zero to sepcify a device │
       │                  │ should be opened for record‐ │
       │                  │ ing, not playback            │
       ├──────────────────┼──────────────────────────────┤
       │ desired          │ an  SDL_AudioSpec  structure │
       │                  │ representing   the   desired │
       │                  │ output  format; see SDL_Ope‐ │
       │                  │ nAudio() for  more  informa‐ │
       │                  │ tion                         │
       ├──────────────────┼──────────────────────────────┤
       │ obtained         │ an  SDL_AudioSpec  structure │
       │                  │ filled in  with  the  actual │
       │                  │ output  format; see SDL_Ope‐ │
       │                  │ nAudio() for  more  informa‐ │
       │                  │ tion                         │
       ├──────────────────┼──────────────────────────────┤
       │ allowed_changes  │ 0, or one or more flags OR'd │
       │                  │ together;  see  Remarks  for │
       │                  │ details                      │
       └──────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  a  valid  device  ID  that  is  >  0 on success or 0 on failure; call
       SDL_GetError() for more information.

       For compabitility with SDL 1.2, this will never return 1, since  SDL  reserves
       that ID for the legacy SDL_OpenAudio() function.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_AudioSpec want, have;                                                                                   │
       │ SDL_AudioDeviceID dev;                                                                                      │
       │                                                                                                             │
       │ SDL_memset(&want, 0, sizeof(want));   /* or SDL_zero(want) */                                               │
       │ want.freq = 48000;                                                                                          │
       │ want.format = AUDIO_F32;                                                                                    │
       │ want.channels = 2;                                                                                          │
       │ want.samples = 4096;                                                                                        │
       │ want.callback = MyAudioCallback;  /* you wrote this function elsewhere -- see SDL_AudioSpec for details */  │
       │                                                                                                             │
       │ dev = SDL_OpenAudioDevice(NULL, 0, &want, &have, SDL_AUDIO_ALLOW_FORMAT_CHANGES);                           │
       │ if (dev == 0)                                                                                               │
       │ {                                                                                                           │
       │   SDL_Log("Failed to open audio: %s", SDL_GetError());                                                      │
       │ }                                                                                                           │
       │ else                                                                                                        │
       │ {                                                                                                           │
       │   if (have.format != want.format) /* we let this one thing change */                                        │
       │   {                                                                                                         │
       │     SDL_Log("We didn't get Float32 audio format.");                                                         │
       │   }                                                                                                         │
       │   SDL_PauseAudio(0);  /*  start audio playing. */                                                           │
       │   SDL_Delay(5000);    /*  let the audio callback play some sound for 5 seconds */                           │
       │   SDL_CloseAudio();                                                                                         │
       │ }                                                                                                           │
       └─────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       SDL_OpenAudio(),  unlike  this  fuction,  always acts on device ID 1. As such,
       this function will never return a 1 so as not  to  conflict  with  the  legacy
       function.

       Please note that SDL 2.0 before 2.0.5 did not support recording; as such, this
       function was failing if iscapture  was  not  zero.  Starting  with  SDL  2.0.5
       recording is implemented and this value can be non-zero.

       Passing  in a device name of NULL requests the most reasonable default (and is
       equivalent to what SDL_OpenAudio() does to choose a device). The  device  name
       is a UTF-8 string reported by SDL_GetAudioDeviceName(), but some drivers allow
       arbitrary and driver-specific strings, such as a hostname/IP address for a re‐
       mote audio server, or a filename in the diskaudio driver.

       allowed_changes can have the following flags OR'd together:

       ┌───────────────────────────────────┐
       │ SDL_AUDIO_ALLOW_FREQUENCY_CHANGE  │
       ├───────────────────────────────────┤
       │ SDL_AUDIO_ALLOW_FORMAT_CHANGE     │
       ├───────────────────────────────────┤
       │ SDL_AUDIO_ALLOW_CHANNELS_CHANGE   │
       ├───────────────────────────────────┤
       │ SDL_AUDIO_ALLOW_ANY_CHANGE        │
       └───────────────────────────────────┘
       These  flags  specify  how SDL should behave when a device cannot offer a spe‐
       cific feature. If the application requests a feature that the hardware doesn't
       offer, SDL will always try to get the closest equivalent.

       For example, if you ask for float32 audio format, but the sound card only sup‐
       ports int16, SDL will set the hardware to int16. If you had set  SDL_AUDIO_AL‐
       LOW_FORMAT_CHANGE,  SDL  will  change the format in the obtained structure. If
       that flag was not set, SDL will prepare to convert your callback's float32 au‐
       dio  to  int16  before feeding it to the hardware and will keep the originally
       requested format in the obtained structure.

       If your application can only handle one specific data format, pass a zero  for
       allowed_changes and let SDL transparently handle any differences.

       An opened audio device starts out paused, and should be enabled for playing by
       calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio call‐
       back  function  to  be called. Since the audio driver may modify the requested
       size of the audio buffer, you should allocate any local mixing  buffers  after
       you open the audio device.

       The  audio  callback  runs in a separate thread in most cases; you can prevent
       race conditions between your callback and other threads without fully  pausing
       playback  with SDL_LockAudioDevice(). For more information about the callback,
       see SDL_AudioSpec.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_CloseAudioDevice
       SDL_GetAudioDeviceName
       SDL_LockAudioDevice
       SDL_OpenAudio
       SDL_PauseAudioDevice
       SDL_UnlockAudioDevice

===============================================================================
                                                                  *SDL_Overlay*


NAME
       SDL_Overlay - YUV video overlay

STRUCTURE DEFINITION
       typedef struct{
         Uint32 format;
         int w, h;
         int planes;
         Uint16 *pitches;
         Uint8 **pixels;
         Uint32 hw_overlay:1;
       } SDL_Overlay;

STRUCTURE DATA
       format              Overlay format (see below)

       w, h                Width and height of overlay

       planes              Number of planes in the overlay. Usually either 1 or 3

       pitches             An  array  of  pitches,  one  for each plane. Pitch is the
                           length of a row in bytes.

       pixels              An array of pointers to teh data of each plane. The  over‐
                           lay should be locked before these pointers are used.

       hw_overlay          This  will be set to 1 if the overlay is hardware acceler‐
                           ated.

DESCRIPTION
       A SDL_Overlay is similar to a SDL_Surface except it stores a YUV overlay.  All
       the fields are read only, except for pixels which should be locked before use.
       The format field stores the format of the overlay which is one of the  follow‐
       ing:

       #define SDL_YV12_OVERLAY  0x32315659  /* Planar mode: Y + V + U */
       #define SDL_IYUV_OVERLAY  0x56555949  /* Planar mode: Y + U + V */
       #define SDL_YUY2_OVERLAY  0x32595559  /* Packed mode: Y0+U0+Y1+V0 */
       #define SDL_UYVY_OVERLAY  0x59565955  /* Packed mode: U0+Y0+V0+Y1 */
       #define SDL_YVYU_OVERLAY  0x55595659  /* Packed mode: Y0+V0+Y1+U0 */

        More   information   on   YUV   formats   can   be  found  at  http://www.we‐
       bartz.com/fourcc/indexyuv.htm (link to  URL  http://www.webartz.com/fourcc/in‐
       dexyuv.htm) .

SEE ALSO
       SDL_CreateYUVOverlay,  SDL_LockYUVOverlay,  SDL_UnlockYUVOverlay,  SDL_FreeYU‐
       VOverlay

===============================================================================
                                                                  *SDL_Palette*


NAME
       SDL_Palette -- Structure

SYNOPSIS
       A structure that contains palette information.

DATA FIELDS
       ┌─────────────┬──────────┬───────────────────────┐
       │ int         │ ncolors  │ the  number of colors │
       │             │          │ in the palette        │
       ├─────────────┼──────────┼───────────────────────┤
       │ SDL_Color*  │ colors   │ an array of SDL_Color │
       │             │          │ structures represent‐ │
       │             │          │ ing the palette       │
       ├─────────────┼──────────┼───────────────────────┤
       │ Uint32      │ version  │ incrementally  tracks │
       │             │          │ changes  to  the pal‐ │
       │             │          │ ette (internal use)   │
       ├─────────────┼──────────┼───────────────────────┤
       │ int         │ refcount │ reference count  (in‐ │
       │             │          │ ternal use)           │
       └─────────────┴──────────┴───────────────────────┘

REMARKS
       Each  pixel  in  an  8-bit  surface  is  an index into the colors field of the
       SDL_Palette structure stored in SDL_PixelFormat. An SDL_Palette  should  never
       need to be created manually. It is automatically created when SDL allocates an
       SDL_PixelFormat for a surface. The colors values of an  SDL_Surface's  palette
       can be set with SDL_SetPaletteColors().

RELATED STRUCTURES
       SDL_PixelFormat

RELATED FUNCTIONS
       SDL_AllocPalette
       SDL_FreePalette
       SetPaletteColors

===============================================================================
                                                               *SDL_PauseAudio*


NAME
       SDL_PauseAudio -- Function

SYNOPSIS
       This  function is legacy means of pausing the audio device. New programs might
       want to use SDL_PauseAudioDevice() instead.

SYNTAX
       ┌──────────────────────────────────────┐
       │ void SDL_PauseAudio(int   pause_on)  │
       └──────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ pause_on  │ non-zero to pause, 0 to  un‐ │
       │           │ pause                        │
       └───────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────┐
       │ SDL_PauseAudio(1);  // audio callback is stopped when this return  │
       │ SDL_Delay(5000);    // audio device plays silence for 5 seconds    │
       │ SDL_PauseAudio(0);  // audio callback starts running again         │
       └────────────────────────────────────────────────────────────────────┘

REMARKS
       This function is equivalent to calling

       ┌─────────────────────────────────────┐
       │ SDL_PauseAudioDevice(1, pause_on);  │
       └─────────────────────────────────────┘
       and is only useful if you used the legacy SDL_OpenAudio() function.

RELATED FUNCTIONS
       SDL_GetAudioStatus
       SDL_PauseAudioDevice

===============================================================================
                                                         *SDL_PauseAudioDevice*


NAME
       SDL_PauseAudioDevice -- Function

SYNOPSIS
       Use this function to pause and unpause audio playback on a specified device.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ void SDL_PauseAudioDevice(SDL_AudioDeviceID   dev,       │
       │                           int                 pause_on)  │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ dev       │ a  device opened by SDL_Ope‐ │
       │           │ nAudioDevice()               │
       ├───────────┼──────────────────────────────┤
       │ pause_on  │ non-zero to pause, 0 to  un‐ │
       │           │ pause                        │
       └───────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────────┐
       │ extern SDL_AudioDeviceID  devid;                                                   │
       │ SDL_PauseAudioDevice(devid, 1);   // audio callback is stopped when this returns.  │
       │ SDL_Delay(5000);                  // audio device plays silence for 5 seconds      │
       │ SDL_PauseAudioDevice(devid, 0);   // audio callback starts running again.          │
       └────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This  function  pauses  and unpauses the audio callback processing for a given
       device. Newly-opened audio devices start in the paused state, so you must call
       this  function  with  pause_on=0  after  opening the specified audio device to
       start playing sound. This allows you to safely initialize data for your  call‐
       back  function  after opening the audio device. Silence will be written to the
       audio device while paused, and the audio callback  is  guaranteed  to  not  be
       called.  Pausing  one device does not prevent other unpaused devices from run‐
       ning their callbacks.

       Pausing state does not stack; even if you pause a device several times, a sin‐
       gle  unpause will start the device playing again, and vice versa. This is dif‐
       ferent from how SDL_LockAudioDevice() works.

       If you just need to protect a few variables from race conditions vs your call‐
       back, you shouldn't pause the audio device, as it will lead to dropouts in the
       audio playback. Instead, you should use SDL_LockAudioDevice().

RELATED FUNCTIONS
       SDL_LockAudioDevice

===============================================================================
                                                               *SDL_PeepEvents*


NAME
       SDL_PeepEvents -- Function

SYNOPSIS
       Use  this function to check the event queue for messages and optionally return
       them.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ int SDL_PeepEvents(SDL_Event*         events,     │
       │                    int                numevents,  │
       │                    SDL_eventaction    action,     │
       │                    Uint32             minType,    │
       │                    Uint32             maxType)    │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ events     │ destination buffer  for  the │
       │            │ retrieved events             │
       ├────────────┼──────────────────────────────┤
       │ numevents  │ if  action  is SDL_ADDEVENT, │
       │            │ the number of events to  add │
       │            │ back  to the event queue; if │
       │            │ action is  SDL_PEEKEVENT  or │
       │            │ SDL_GETEVENT,   the  maximum │
       │            │ number of events to retrieve │
       ├────────────┼──────────────────────────────┤
       │ action     │ action to take; see  Remarks │
       │            │ for details                  │
       ├────────────┼──────────────────────────────┤
       │ minType    │ minimum  value  of the event │
       │            │ type   to   be   considered; │
       │            │ SDL_FIRSTEVENT   is  a  safe │
       │            │ choice                       │
       ├────────────┼──────────────────────────────┤
       │ maxType    │ maximum value of  the  event │
       │            │ type   to   be   considered; │
       │            │ SDL_LASTEVENT  is   a   safe │
       │            │ choice                       │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns the number of events actually stored or a negative error code on fail‐
       ure; call SDL_GetError() for more information.

REMARKS
       action may be any of the following:

       ┌────────────────┬──────────────────────────────┐
       │ SDL_ADDEVENT   │ up to numevents events  will │
       │                │ be  added to the back of the │
       │                │ event queue                  │
       ├────────────────┼──────────────────────────────┤
       │ SDL_PEEKEVENT  │ up to  numevents  events  at │
       │                │ the   front   of  the  event │
       │                │ queue, within the  specified │
       │                │ minimum  and  maximum  type, │
       │                │ will be  returned  and  will │
       │                │ not   be  removed  from  the │
       │                │ queue                        │
       ├────────────────┼──────────────────────────────┤
       │ SDL_GETEVENT   │ up to  numevents  events  at │
       │                │ the   front   of  the  event │
       │                │ queue, within the  specified │
       │                │ minimum  and  maximum  type, │
       │                │ will be returned and will be │
       │                │ removed from the queue       │
       └────────────────┴──────────────────────────────┘
       This function is thread-safe.

       You may have to call SDL_PumpEvents() before calling this function. Otherwise,
       the events may not be ready to be filtered when you call SDL_PeepEvent().

RELATED FUNCTIONS
       SDL_PollEvent
       SDL_PumpEvents
       SDL_PushEvent

===============================================================================
                                                              *SDL_PixelFormat*


NAME
       SDL_PixelFormat -- Structure

SYNOPSIS
       A structure that contains pixel format information.

DATA FIELDS
       ┌───────────────────┬───────────────┬───────────────────────┐
       │ Uint32            │ format        │ one  of  the SDL_Pix‐ │
       │                   │               │ elFormatEnum values   │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ SDL_Palette*      │ palette       │ an SDL_Palette struc‐ │
       │                   │               │ ture  associated with │
       │                   │               │ this pixel format, or │
       │                   │               │ NULL  if  the  format │
       │                   │               │ doesn't have  a  pal‐ │
       │                   │               │ ette                  │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ BitsPerPixel  │ the number of signif‐ │
       │                   │               │ icant bits in a pixel │
       │                   │               │ value, eg: 8, 15, 16, │
       │                   │               │ 24, 32                │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ BytesPerPixel │ the number  of  bytes │
       │                   │               │ required  to  hold  a │
       │                   │               │ pixel value,  eg:  1, │
       │                   │               │ 2,  3, 4; see Remarks │
       │                   │               │ for related data type │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint32            │ Rmask         │ a  mask  representing │
       │                   │               │ the  location  of the │
       │                   │               │ red component of  the │
       │                   │               │ pixel                 │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint32            │ Gmask         │ a  mask  representing │
       │                   │               │ the location  of  the │
       │                   │               │ green   component  of │
       │                   │               │ the pixel             │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint32            │ Bmask         │ a  mask  representing │
       │                   │               │ the  location  of the │
       │                   │               │ blue component of the │
       │                   │               │ pixel                 │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint32            │ Amask         │ a  mask  representing │
       │                   │               │ the location  of  the │
       │                   │               │ alpha   component  of │
       │                   │               │ the pixel or 0 if the │
       │                   │               │ pixel  format doesn't │
       │                   │               │ have any alpha infor‐ │
       │                   │               │ mation                │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ Rloss         │ (internal use)        │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uin8              │ Gloss         │ (internal use)        │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ Bloss         │ (internval use)       │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ Aloss         │ (internval use)       │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ Rshift        │ (internal use)        │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ Gshift        │ (internal use)        │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ Bshift        │ (internal use)        │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ Uint8             │ Ashift        │ (internal use)        │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ int               │ refcount      │ (internal use)        │
       ├───────────────────┼───────────────┼───────────────────────┤
       │ SDL_PixelFormat*  │ next          │ (internal use)        │
       └───────────────────┴───────────────┴───────────────────────┘

CODE EXAMPLES
       8-bit  pixel  formats are the easiest to understand. Since it is an 8-bit for‐
       mat, we have 8 BitsPerPixel and 1 BytesPerPixel. Since BytesPerPixel is 1, all
       pixels are reprsented by a Uint8 which contains an index into palette->colors.
       So, to determine the color of a pixel in a 8-bit surface: we  read  the  color
       index  from  surface->pixels and we use that index to read SDL_Color structure
       from surface->format->palette->colors. Like so:

       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_Surface *surface;                                                                                    │
       │ SDL_PixelFormat *fmt;                                                                                    │
       │ SDL_Color *color;                                                                                        │
       │ Uint8 index;                                                                                             │
       │ /* Create surface */                                                                                     │
       │ fmt = surface->format;                                                                                   │
       │                                                                                                          │
       │ /* Check the bitdepth of the surface */                                                                  │
       │ if (fmt->BitsPerPixel != 8) {                                                                            │
       │   fprintf(stderr, "Not an 8-bit surface.\n");                                                            │
       │   return(-1);                                                                                            │
       │ }                                                                                                        │
       │                                                                                                          │
       │ /* Lock the surface */                                                                                   │
       │ SDL_LockSurface(surface);                                                                                │
       │                                                                                                          │
       │ /* Get the topleft pixel */                                                                              │
       │ index = *(Uint8*)surface->pixels;                                                                        │
       │ color = &fmt->palette->colors[index];                                                                    │
       │                                                                                                          │
       │ /* Unlock the surface */                                                                                 │
       │ SDL_UnlockSurface(surface);                                                                              │
       │ printf("Pixel color-> Red: %d, Green: %d, Blue: %d. Index: %d\n", color->r, color->g, color->b, index);  │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────┘

       Pixel formats above 8-bit are an entirely different experience. They are  con‐
       sidered  to  be "TrueColor" formats and the color information is stored in the
       pixels themselves, not in a palette. The mask, shift, and loss fields tell  us
       how the color information is encoded. The mask fields allow us to isolate each
       color component, the shift fields tell us the number of bits to the  right  of
       each  component  in  the pixel value and the loss fields tell us the number of
       bits lost from each component when packing 8-bit color component in a pixel.

       ┌──────────────────────────────────────────────────────────────────────────────────┐
       │ /* Extracting color components from a 32-bit color value */                      │
       │ SDL_PixelFormat *fmt;                                                            │
       │ SDL_Surface *surfaace;                                                           │
       │ Uint32 temp, pixel;                                                              │
       │ Uint8 red, green, blue, alpha;                                                   │
       │ fmt = surface->format;                                                           │
       │ SDL_LockSurface(surface);                                                        │
       │ pixel = *((Uint32*)surface->pixels);                                             │
       │ SDL_UnlockSurface(surface);                                                      │
       │                                                                                  │
       │ /* Get Red component */                                                          │
       │ temp = pixel & fmt->Rmask;  /* Isolate red component */                          │
       │ temp = temp >> fmt->Rshift;        /* Shift it down to 8-bit */                  │
       │ temp = temp << fmt->Rloss; /* Expand to a full 8-bit number */                   │
       │ red = (Uint8)temp;                                                               │
       │                                                                                  │
       │ /* Get Green component */                                                        │
       │ temp = pixel & fmt->Gmask;  /* Isolate green component */                        │
       │ temp = temp >> fmt->Gshift;  /* Shift it down to 8-bit */                        │
       │ temp = temp << fmt->Rloss;  /* Expand to a full 8-bit number */                  │
       │ green = (Uint8)temp;                                                             │
       │                                                                                  │
       │ /* Get Blue component */                                                         │
       │ temp = pixel & fmt->Bmask;  /* Isolate blue component */                         │
       │ temp = temp >> fmt->Bshift;  /* Shift it down to 8-bit */                        │
       │ temp = temp << fmt->Bloss;  /* Expand to a full 8-bit number */                  │
       │ blue = (Uint8)temp;                                                              │
       │                                                                                  │
       │ /* Get Alpha component */                                                        │
       │ temp = pixel & fmt->Amask;  /* Isolate alpha component */                        │
       │ temp = temp >> fmt->Ashift;  /* Shift it down to 8-bit */                        │
       │ temp = temp << fmt->Aloss;  /* Expand to a full 8-bit number */                  │
       │ alpha = (Uint8)temp;                                                             │
       │                                                                                  │
       │ printf("Pixel Color -> R: %d, G: %d, B: %d, A: %d\n", red, green, blue, alpha);  │
       └──────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       Everything in the pixel format structure is read-only.

       A pixel format has either a palette or masks. If  a  palette  is  used  Rmask,
       Gmask, Bmask and Amask will be 0.

       The data types used to represent pixels are as follows:

       ┌──────────────────┬───────────────────────────┐
       │ Bytes Per Pixel  │ Related Data Types        │
       ├──────────────────┼───────────────────────────┤
       │ 1                │ Uint8                     │
       ├──────────────────┼───────────────────────────┤
       │ 2                │ Uint16                    │
       ├──────────────────┼───────────────────────────┤
       │ 3                │ tuple of Uint8 RGB values │
       ├──────────────────┼───────────────────────────┤
       │ 4                │ Uint32                    │
       └──────────────────┴───────────────────────────┘

       An SDL_PixelFormat describes the format of the pixel data stored at the pixels
       field of an SDL_Surface. Every surface stores an SDL_PixelFormat in the format
       field.

       If  you  wish to do pixel level modifications on a surface, then understanding
       how SDL stores its color information is essential. See Code Examples above for
       more information.

       For  information on modern pixel color spaces, see the following Wikipedia ar‐
       ticle: http://en.wikipedia.org/wiki/RGBA_color_space.

RELATED STRUCTURES
       SDL_Surface

RELATED FUNCTIONS
       SDL_ConvertSurface
       SDL_GetRGB
       SDL_GetRGBA
       SDL_MapRGB
       SDL_MapRGBA

===============================================================================
                                                          *SDL_PixelFormatEnum*


NAME
       SDL_PixelFormatEnum -- Enumerations

SYNOPSIS
       An enumeration of of pixel formats.

DESCRIPTION
       Pixel Format Macros

       ┌────────────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELTYPE(format)              │ the  type  of the pixel for‐ │
       │                                    │ mat; see Remarks for details │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELORDER(format)             │ the ordering of channels  or │
       │                                    │ bits  in  the  pixel format; │
       │                                    │ see Remarks for details      │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELLAYOUT(format)            │ the channel bit  pattern  of │
       │                                    │ the  pixel  format;  See Re‐ │
       │                                    │ marks for details            │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_BITSPERPIXEL(format)           │ the number of bits of  color │
       │                                    │ information   in  the  pixel │
       │                                    │ format                       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_BYTESPERPIXEL(format)          │ the number of bytes used  to │
       │                                    │ represent a pixel            │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_ISPIXELFORMAT_INDEXED(format)  │ true  for pixel formats that │
       │                                    │ have a palette               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_ISPIXELFORMAT_ALPHA(format)    │ true for pixel formats  that │
       │                                    │ have an alpha channel        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_ISPIXELFORMAT_FOURCC(format)   │ true  for pixel formats rep‐ │
       │                                    │ resenting  unique   formats, │
       │                                    │ for example YUV formats      │
       └────────────────────────────────────┴──────────────────────────────┘

       Pixel Format Values

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar  mode:  Y  + V + U (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar mode: Y + U  +  V  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packet  mode: Y0 + U0 + Y1 + │
       │                              │ V0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed mode: U0 + Y0 + V0  + │
       │                              │ Y1 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed  mode: Y0 + V0 + Y1 + │
       │                              │ U0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar mode: Y + U/V  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar mode: Y + V/U  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

REMARKS
       The pixel type is one of the following values:

       ┌─────────────────────────┐
       │ SDL_PIXELTYPE_UNKNOWN   │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_INDEX1    │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_INDEX4    │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_INDEX8    │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_PACKED8   │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_PACKED16  │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_PACKED32  │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_ARRAYU8   │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_ARRAYU16  │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_ARRAYU32  │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_ARRAYF16  │
       ├─────────────────────────┤
       │ SDL_PIXELTYPE_ARRAYF32  │
       └─────────────────────────┘

       Depending on the pixel type there are three  different  types  of  ordering  -
       bitmapped, packed, or array.

       ┌─────────────────────────────────────────────────┐
       │ Bitmap pixel order (high bit -> low bit)        │
       ├─────────────────────────────────────────────────┤
       │ SDL_BITMAPORDER_NONE                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_BITMAPORDER_4321                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_BITMAPORDER_1234                            │
       ├─────────────────────────────────────────────────┤
       │ Packed component order (high bit -> low bit)    │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_NONE                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_XRGB                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_RGBX                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_ARGB                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_RGBA                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_XBGR                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_BGRX                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_ABGR                            │
       ├─────────────────────────────────────────────────┤
       │ SDL_PACKEDORDER_BGRA                            │
       ├─────────────────────────────────────────────────┤
       │ Array component order (high byte -> high byte)  │
       ├─────────────────────────────────────────────────┤
       │ SDL_ARRAYORDER_NONE                             │
       ├─────────────────────────────────────────────────┤
       │ SDL_ARRAYORDER_RGB                              │
       ├─────────────────────────────────────────────────┤
       │ SDL_ARRAYORDER_RGBA                             │
       ├─────────────────────────────────────────────────┤
       │ SDL_ARRAYORDER_ARGB                             │
       ├─────────────────────────────────────────────────┤
       │ SDL_ARRAYORDER_BGR                              │
       ├─────────────────────────────────────────────────┤
       │ SDL_ARRAYORDER_BGRA                             │
       ├─────────────────────────────────────────────────┤
       │ SDL_ARRAYORDER_ABGR                             │
       └─────────────────────────────────────────────────┘

       Packed pixel formats have one of the following channel layouts:

       ┌───────────────────────────┐
       │ SDL_PACKEDLAYOUT_NONE     │
       ├───────────────────────────┤
       │ SDL_PACKEDLAYOUT_332      │
       ├───────────────────────────┤
       │ SDL_PACKEDLAYOUT_4444     │
       ├───────────────────────────┤
       │ SDL_PACKEDLAYOUT_1555     │
       ├───────────────────────────┤
       │ SDL_PACKEDLAYOUT_5551     │
       ├───────────────────────────┤
       │ SDL_PACKEDLAYOUT_565      │
       ├───────────────────────────┤
       │ SDL_PACKEDLAYOUT_8888     │
       ├───────────────────────────┤
       │ SDL_PACKEDLAYOUT_2101010  │
       ├───────────────────────────┤
       │ SDL_PACKEDLAYOUT_1010102  │
       └───────────────────────────┘

SDL_PIXELFORMAT_*32 aliases
       SDL_PIXELFORMAT_RGBA32  is an alias for SDL_PIXELFORMAT_RGBA8888 on big endian
       machines and for SDL_PIXELFORMAT_ABGR8888 on little endian  machines,  so  you
       can  use  it  to specify that your pixels are represented as RGBA byte arrays,
       like SDL_PIXELFORMAT_RGB24 is for RGB byte arrays.

       However, being just an alias, it has the exact same value of the aliased  type
       so  SDL_GetPixelFormatName(SDL_PIXELFORMT_RGBA32)  will return the name of the
       aliased type (e.g. "SDL_PIXELFORMAT_ABGR8888"), depending on your platform.

       The  same  applies  to  SDL_PIXELFORMAT_ARGB32,   SDL_PIXELFORMAT_BGRA32   and
       SDL_PIXELFORMAT_ABGR32  (with  the only difference that they alias other pixel
       formats, of course). The SDL_PIXELFORMAT_*32 aliases are available  since  SDL
       2.0.5.

RELATED STRUCTURES
       SDL_DisplayMode
       SDL_RenderInfo

RELATED FUNCTIONS
       SDL_CreateTexture
       SDL_CreateTextureFromSurface
       SDL_GetPixelFormatName
       SDL_MasksToPixelFormatEnum
       SDL_PixelFormatEnumToMasks
       SDL_QueryTexture
       SDL_RenderReadPixels

===============================================================================
                                                   *SDL_PixelFormatEnumToMasks*


NAME
       SDL_PixelFormatEnumToMasks -- Function

SYNOPSIS
       Use  this  function  to  convert  one of the enumerated pixel formats to a bpp
       value and RGBA masks.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_PixelFormatEnumToMasks(Uint32    format,  │
       │                                     int*      bpp,     │
       │                                     Uint32*   Rmask,   │
       │                                     Uint32*   Gmask,   │
       │                                     Uint32*   Bmask,   │
       │                                     Uint32*   Amask)   │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ format  │ one  of  the   SDL_PixelFor‐ │
       │         │ matEnum  values; see Remarks │
       │         │ for details                  │
       ├─────────┼──────────────────────────────┤
       │ bpp     │ a filled in bits  per  pixel │
       │         │ value; usually 15, 16, or 32 │
       ├─────────┼──────────────────────────────┤
       │ Rmask   │ a pointer filled in with the │
       │         │ red mask for the format      │
       ├─────────┼──────────────────────────────┤
       │ Gmask   │ a pointer filled in with the │
       │         │ green mask for the format    │
       ├─────────┼──────────────────────────────┤
       │ Bmask   │ a pointer filled in with the │
       │         │ blue mask for the format     │
       ├─────────┼──────────────────────────────┤
       │ Amask   │ a pointer filled in with the │
       │         │ alpha mask for the format    │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  SDL_TRUE  on  success or SDL_FALSE if the conversion wasn't possible;
       call SDL_GetError() for more information.

REMARKS
       format may be one of the following:

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar mode: Y + V  +  U  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar  mode:  Y  + U + V (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packed mode: Y0+U0+Y1+V0  (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed  mode: U0+Y0+V0+Y1 (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed mode: Y0+V0+Y1+U0  (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar  mode: Y + U/V inter‐ │
       │                              │ leaved (2  planes)  (>=  SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar  mode: Y + V/U inter‐ │
       │                              │ leaved (2  planes)  (>=  SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_MasksToPixelFormatEnum

===============================================================================
                                                                    *SDL_Point*


NAME
       SDL_Point -- Structure

SYNOPSIS
       A structure that defines a two dimensional point.

DATA FIELDS
       ┌──────┬───┬───────────────────────┐
       │ int  │ x │ the  x  coordinate of │
       │      │   │ the point             │
       ├──────┼───┼───────────────────────┤
       │ int  │ y │ the y  coordinate  of │
       │      │   │ the point             │
       └──────┴───┴───────────────────────┘

CODE EXAMPLES
       // Example program:
       // Using SDL_Point in some places of your code

       #include "SDL.h"
       #include <stdio.h>

       int main(int argc, char *argv[]) {
         SDL_Window *window;

         SDL_Point window_position = {      // Position of window
           SDL_WINDOWPOS_CENTERED,
           SDL_WINDOWPOS_CENTERED
         };
         SDL_Point window_size = { 640, 480 };    // Ssize of window

         SDL_Point mouse_position;                // Mouse position coords

         SDL_Init(SDL_INIT_VIDEO);                // Initialize SDL2

         // Create an application window with the following settings:
         window = SDL_CreateWindow(
           "SDL_Point usage",    // window title
           window_position.x,    // initial x position
           window_position.y,    // initial y position
           window_size.x,        // width, in pixels
           window_size.y,        // height, in pixels
           SDL_WINDOW_OPENGL     // flags - see below
         );

         // Check that the window was successfully made
         if (window == NULL) {
           SDL_Log("Could not create window: %s", SDL_GetError());
           return 1;
         }

         SDL_GetMouseState(
           &mouse_position.x,      // Sets mouse_position to...
           &mouse_position.y       // ... mouse arrow coords on window
         );

         SDL_Log("Mouse position: x=%i y=%i",    // Print mouse position
           mouse_position.x, mouse_position.y
         );

         // Close and destroy the window
         SDL_DestroyWindow(window);

         // Clean up
         SDL_Quit();
         return 0;
       }

REMARKS
       An SDL_Point defines single two dimensional point. It can be used not only for
       points, but also for size. SDL_Point is used by SDL_EnclosePoints()  to  check
       if  array of points is inside rectangle (SDL_Rect). You can also make your own
       functions using SDL_Point to simplify your code. It's very helful.

RELATED STRUCTURES
       SDL_Rect

RELATED FUNCTIONS
       SDL_EnclosePoints

===============================================================================
                                                              *SDL_PointInRect*


NAME
       SDL_PointInRect -- Function

SYNOPSIS
       Use this function to check if a point resides inside a rectangle.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ SDL_bool SDL_PointInRect(const SDL_Point*   p,  │
       │                          const SDL_Point*   r)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ p  │ an  SDL_Point  which  is the │
       │    │ point                        │
       ├────┼──────────────────────────────┤
       │ r  │ an  SDL_Rect  which  is  the │
       │    │ rectangle                    │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if point resides inside rectangle or SDL_FALSE if not.

REMARKS
       Both p and r must not be NULL.

VERSION
       This function is available since SDL 2.0.4.

===============================================================================
                                                                *SDL_PollEvent*


NAME
       SDL_PollEvent -- Function

SYNOPSIS
       Use this function to poll for currently pending events.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ int SDL_PollEvent(SDL_Event*    event)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ event  │ the  SDL_Event  structure to │
       │        │ be  filled  with  the   next │
       │        │ event  from  the  queue,  or │
       │        │ NULL                         │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 if there is a pending event or 0 if there are none available.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────┐
       │ while (1)                                                │
       │ {                                                        │
       │   SDL_Event event;                                       │
       │   while (SDL_PollEvent(&event))                          │
       │   {                                                      │
       │     /* handle your event here */                         │
       │   }                                                      │
       │   /* do some other stuff here -- draw your app, etc. */  │
       │ }                                                        │
       └──────────────────────────────────────────────────────────┘

REMARKS
       If event is not NULL, the next event is removed from the queue and  stored  in
       the  SDL_Event  structure  pointed  to by event. The 1 returned refers to this
       event, immediately stored in the SDL Event structure -- not an event  to  fol‐
       low.

       If  event  is NULL, it simply returns 1 if there is an event in the queue, but
       will not remove it.

       As this function implicitly calls SDL_PumpEvents(), you  can  only  call  this
       function in the thread that set the video mode.

       SDL_PollEvent()  is the favored way of receiving system events since it can be
       done from the main loop and does not suspend the main loop while waiting on an
       event to be posted.

RELATED FUNCTIONS
       SDL_GetEventFilter
       SDL_PeepEvents
       SDL_PushEvent
       SDL_SetEventFilter
       SDL_WaitEvent
       SDL_WaitEventTimeout

===============================================================================
                                                               *SDL_PowerState*


NAME
       SDL_PowerState -- Enumerations

SYNOPSIS
       An enumeration of the basic state of the system's power supply.

DESCRIPTION
       Values

       ┌────────────────────────────┬──────────────────────────────┐
       │ SDL_POWERSTATE_UNKNOWN     │ cannot  determine power sta‐ │
       │                            │ tus                          │
       ├────────────────────────────┼──────────────────────────────┤
       │ SDL_POWERSTATE_ON_BATTERY  │ not plugged in,  running  on │
       │                            │ the battery                  │
       ├────────────────────────────┼──────────────────────────────┤
       │ SDL_POWERSTATE_NO_BATTERY  │ plugged   in,   no   battery │
       │                            │ available                    │
       ├────────────────────────────┼──────────────────────────────┤
       │ SDL_POWERSTATE_CHARGING    │ plugged in, charging battery │
       ├────────────────────────────┼──────────────────────────────┤
       │ SDL_POWERSTATE_CHARGED     │ plugged in, battery charged  │
       └────────────────────────────┴──────────────────────────────┘

CODE EXAMPLES
       if (SDL_GetPowerInfo(NULL, NULL) == SDL_POWERSTATE_ON_BATTERY) {
         printf("You should plug in your laptop before running this update.\n");
       }

REMARKS
       Not all machines can have batteries at all, and not all platforms  can  report
       battery  status.  Those  that  do  can still having minor moments of confusion
       about the state of the battery. As such, you should always be prepared to  get
       an  otherwise-unexpected SDL_POWERSTATE_UNKNOWN from SDL_GetPowerInfo(). Also,
       batteries are fickle hardware: reported status can flicker between two  states
       for no obvious reason on occasion.

RELATED FUNCTIONS
       SDL_GetPowerInfo

===============================================================================
                                                               *SDL_PumpEvents*


NAME
       SDL_PumpEvents -- Function

SYNOPSIS
       Use  this function to pump the event loop, gathering events from the input de‐
       vices.

SYNTAX
       ┌────────────────────────────┐
       │ void SDL_PumpEvents(void)  │
       └────────────────────────────┘

REMARKS
       This function updates the event queue and internal input device state.

       Warning: This should only be run in the thread that initialized the video sub‐
       system,  and  for extra safety, you should consider only doing those things on
       the main thread in any case.

       SDL_PumpEvents() gathers all the pending input information  from  devices  and
       places  it  in  the  event  queue. Without calls to SDL_PumpEvents() no events
       would  ever  be  placed  on  the  queue.  Often  the   need   for   calls   to
       SDL_PumpEvents()  is  hidden from the user since SDL_PollEvent() and SDL_Wait‐
       Event() implicitly call SDL_PumpEvents(). However, if you are not  polling  or
       waiting  for  events  (e.g.  you  are  filtering  them),  then  you  must call
       SDL_PumpEvents() to force an event queue update.

RELATED FUNCTIONS
       SDL_PollEvent
       SDL_WaitEvent

===============================================================================
                                                                *SDL_PushEvent*


NAME
       SDL_PushEvent -- Function

SYNOPSIS
       Use this function to add an event to the event queue.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ int SDL_PushEvent(SDL_Event*    event)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ event  │ the SDL_Event to be added to │
       │        │ the queue                    │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on success, 0 if the event was filtered, or a negative error code on
       failure;  call  SDL_GetError() for more information. A common reason for error
       is the event queue being full.

CODE EXAMPLES
       ┌────────────────────────────────────┐
       │ // Default Usage:                  │
       │ SDL_Event sdlevent;                │
       │ sdlevent.type = SDL_KEYDOWN;       │
       │ sdlevent.key.keysym.sym = SDLK_1;  │
       │                                    │
       │ SDL_PushEvent(&sdlevent);          │
       └────────────────────────────────────┘

REMARKS
       The event queue can actually be used as a two way communication  channel.  Not
       only  can  events be read from the queue, but the user can also push their own
       events onto it. event is a pointer to the event structure  you  wish  to  push
       onto the queue. The event is copied into the queue, and the caller may dispose
       of the memory pointed to after SDL_PushEvent() returns.

       Note: Pushing device input events onto the queue doesn't modify the  state  of
       the device within SDL.

       This function is thread-safe, and can be called from other threads safely.

       Note: Events pushed onto the queue with SDL_PushEvent() get passed through the
       event filter but events added with SDL_PeepEvents() do not.

       For pushing application-specific events, please  use  SDL_RegisterEvents()  to
       get  an  event type that does not conflict with other code that also wants its
       own custom event types.

RELATED FUNCTIONS
       SDL_PeepEvents
       SDL_PollEvent
       SDL_RegisterEvents

===============================================================================
                                                             *SDL_QueryTexture*


NAME
       SDL_QueryTexture -- Function

SYNOPSIS
       Use this function to query the attributes of a texture.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_QueryTexture(SDL_Texture*   texture,  │
       │                      Uint32*        format,   │
       │                      int*           access,   │
       │                      int*           w,        │
       │                      int*           h)        │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to query         │
       ├──────────┼──────────────────────────────┤
       │ format   │ a pointer filled in with the │
       │          │ raw format of  the  texture; │
       │          │ the  actual  format may dif‐ │
       │          │ fer,  but  pixel   transfers │
       │          │ will  use  this  format; see │
       │          │ Remarks for details          │
       ├──────────┼──────────────────────────────┤
       │ access   │ a pionter filled in with the │
       │          │ actual access to the texture │
       │          │ (one of  the  SDL_TextureAc‐ │
       │          │ cess values)                 │
       ├──────────┼──────────────────────────────┤
       │ w        │ a pointer filled in with the │
       │          │ width of the texture in pix‐ │
       │          │ els                          │
       ├──────────┼──────────────────────────────┤
       │ h        │ a pointer filled in with the │
       │          │ height  of  the  texture  in │
       │          │ pixels                       │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────┐
       │ SDL_Texture*  source;                          │
       │                                                │
       │ // loading etc ...                             │
       │                                                │
       │ int w, h;                                      │
       │ SDL_QueryTexture(source, NULL, NULL, &w, &h);  │
       └────────────────────────────────────────────────┘

REMARKS
       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color  data, for the current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar mode: Y + V  +  U  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar  mode:  Y  + U + V (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packet mode: Y0 + U0 + Y1  + │
       │                              │ V0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed  mode: U0 + Y0 + V0 + │
       │                              │ Y1 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed mode: Y0 + V0 + Y1  + │
       │                              │ U0 (1 plane)                 │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar  mode: Y + U/V inter‐ │
       │                              │ leaved (2  planes)  (>=  SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar  mode: Y + V/U inter‐ │
       │                              │ leaved (2  planes)  (>=  SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_CreateTexture

===============================================================================
                                                               *SDL_QueueAudio*


NAME
       SDL_QueueAudio -- Function

SYNOPSIS
       Use this function to queue more audio on non-callback devices.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ int SDL_QueueAudio(SDL_AudioDeviceID    dev,   │
       │                    const void*          data,  │
       │                    Uint32               len)   │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ dev   │ the  device  ID  to which we │
       │       │ will queue audio             │
       ├───────┼──────────────────────────────┤
       │ data  │ the data to queue to the de‐ │
       │       │ vice for later playback      │
       ├───────┼──────────────────────────────┤
       │ len   │ the  number  of  bytes  (not │
       │       │ samples!)  to  which  (data) │
       │       │ points to                    │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       If you are looking to retrieve queued audio from a  non-callback  capture  de‐
       vice,  you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return -1 to
       signify an error if you use it with capture devices.

       SDL offers two ways to feed audio to the device: you can either supply a call‐
       back that SDL triggers with some frequency to obtain more audio (pull method),
       or you can supply no callback, and then SDL will expect you to supply data  at
       regular intervals (push method) with this function.

       There  are  no limits on the amount of data you can queue, short of exhaustion
       of address space. Queued data will drain to the device  as  necessary  without
       further  intervention  from  you.  If  the device needs audio but there is not
       enough queued, it will play silence to make up the difference. This means  you
       will have skips in your audio playback if you aren't routinely queueing suffi‐
       cient data.

       This function copies the supplied data, so you are safe to free  it  when  the
       function  returns.  This function is thread-safe, but queueing to the same de‐
       vice from two threads at once does not promise which  buffer  will  be  queued
       first.

       You  may  not  queue  audio  on a device that is using an application-supplied
       callback; doing so returns an error. You have to use  the  audio  callback  or
       queue audio with this function, but not both.

       You should not call SDL_LockAudio() on the device before queueing; SDL handles
       locking internally for this function.

VERSION
       This function is available since SDL 2.0.4.

RELATED FUNCTIONS
       SDL_ClearQueuedAudio
       SDL_GetQueuedAudioSize

===============================================================================
                                                                     *SDL_Quit*


NAME
       SDL_Quit -- Function

SYNOPSIS
       Use  this  function to clean up all initialized subsystems. You should call it
       upon all exit conditions.

SYNTAX
       ┌──────────────────────┐
       │ void SDL_Quit(void)  │
       └──────────────────────┘

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                        │
       │ #include <stdio.h>                                                      │
       │ #include <stdilib.h>                                                    │
       │                                                                         │
       │ int main(int argc, char** argv)                                         │
       │ {                                                                       │
       │   if (SDL_Init(SDL_INIT_EVERYTHING) != 0)                               │
       │   {                                                                     │
       │     fprintf(stderr, "Unable to initialize SDL: %s\n", SDL_GetError());  │
       │     return 1;                                                           │
       │   }                                                                     │
       │   ateixt(SDL_Quit);                                                     │
       │                                                                         │
       │   /* ... */                                                             │
       │   return 0;                                                             │
       │ }                                                                       │
       └─────────────────────────────────────────────────────────────────────────┘

REMARKS
       You should call this function even if you have shutdown each initialized  sub‐
       system  with SDL_QuitSubSystem(). It is safe to call this function even in the
       case of errors in initialization.

       If you start a subsystem using a call to that subsystem's init  function  (for
       example  SDL_VideoInit())  instead  of SDL_Init() or SDL_InitSubSystem(), then
       you must use that subsystem's quit function (SDL_VideoQuit()) to shut it  down
       before calling SDL_Quit().

       You can use this function with atexit() to ensure that it is run when your ap‐
       plication is shutdown, but it is not wise to do this from a library  or  other
       dynamically loaded code.

RELATED FUNCTIONS
       SDL_Init
       SDL_QuitSubSystem

===============================================================================
                                                                *SDL_QuitEvent*


NAME
       SDL_QuitEvent -- Structure

SYNOPSIS
       A structure that contains the "quit requested" event.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ SDL_QUIT              │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ timestamp    of   the │
       │         │           │ event                 │
       └─────────┴───────────┴───────────────────────┘

CODE EXAMPLES
       SDL_Event e;
       for (;;) {
         SDL_PollEvent(&e);
         if (e.type == SDL_QUIT) {
           SDL_Log("Program quit after %i ticks", e.quit.timestamp);
           break;
         }
       }

REMARKS
       SDL_QuitEvent is s member of the SDL_Event union and is used when an event  of
       type SDL_QUIT is reported. You would access it through the event's quit field.

       Please refer to the discussion of SDL_QUIT (see SDL_QUIT section in Remarks by
       executing man SDL_QUIT) for more details.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

===============================================================================
                                                            *SDL_QuitRequested*


NAME
       SDL_QuitRequested -- Function

SYNOPSIS
       Use this function to see whether an SDL_QUIT event is queued.

SYNTAX
       ┌───────────────────────────────────┐
       │ SDL_bool SDL_QuitRequested(void)  │
       └───────────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if SDL_QUIT is queued or SDL_FALSE otherwise.

REMARKS
       This  is  actually  a  macro that calls SDL_PumpEvents() followed by SDL_Peep‐
       Events(). Since it pumps the event queue, it can only  be  used  in  the  main
       thread.

       It's  perfectly  normal  for  applications  to just look for SDL_QUIT in their
       event loop, too, without using this macro.

RELATED FUNCTIONS
       SDL_PollEvent
       SDL_PumpEvents
       SDL_WaitEvent

===============================================================================
                                                            *SDL_QuitSubSystem*


NAME
       SDL_QuitSubSystem -- Function

SYNOPSIS
       Use this function to shut down specific SDL subsystems.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ void SDL_QuitSubSystem(Uint32   flags)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ flags  │ any  of  the  flags  used by │
       │        │ SDL_Init() see  Remarks  for │
       │        │ details                      │
       └────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                             │
       │                                                              │
       │ /* ... */                                                    │
       │                                                              │
       │ int main(int argc, char** argv)                              │
       │ {                                                            │
       │   int sdl_initialized = 0;                                   │
       │   sdl_initialized = !SDL_Init(0);                            │
       │                                                              │
       │   /* ... console stuff */                                    │
       │                                                              │
       │   if (sdl_initialized && SDL_InitSubSystem(SDL_INIT_VIDEO))  │
       │   {                                                          │
       │     display_graph();                                         │
       │     SDL_QuitSubSystem(SDL_INIT_VIDEO);                       │
       │   }                                                          │
       │                                                              │
       │   /* ... more console sutff ... */                           │
       │                                                              │
       │   if (sdl_initialized)  SDL_Quit();                          │
       │   return 0;                                                  │
       │ }                                                            │
       └──────────────────────────────────────────────────────────────┘

REMARKS
       These are the flags which may be passed to SDL_QuitSubSystem() and may be OR'd
       together to quit multiple subsystems simultaneously.

       ┌──────────────────────────┬──────────────────────────────┐
       │ SDL_INIT_TIMER           │  timer subsystem             │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_AUDIO           │  audio subsystem             │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_VIDEO           │  video subsystem; automati‐  │
       │                          │  cally    initializes   the  │
       │                          │  events subsystem            │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_JOYSTICK        │  joystick subsystem;  auto‐  │
       │                          │  matically  initializes the  │
       │                          │  events subsystem            │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_HAPTIC          │  haptic  (force   feedback)  │
       │                          │  subsystem                   │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_GAMECONTROLLER  │  controller  subsystem; au‐  │
       │                          │  tomatically    initializes  │
       │                          │  the joystick subsystem      │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_EVENTS          │  events subsystem            │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_EVERYTHING      │  all  of  the above subsys‐  │
       │                          │  tems                        │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_NOPARACHUTE     │  compatibility;  this  flag  │
       │                          │  is ignored                  │
       └──────────────────────────┴──────────────────────────────┘
       If  you  start a subsystem using a call to that subsystem's init function (for
       example  SDL_VideoInit())  instead  of  SDL_Init()   or   SDL_InitSubSystem(),
       SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use that
       subsystem's quit function (SDL_VideoQuit()) directly instead.

       You still need to call SDL_Quit() even if you close all open  subsystems  with
       SDL_QuitSubSystem().

RELATED FUNCTIONS
       SDL_InitSubSystem
       SDL_Quit

===============================================================================
                                                                 *SDL_REVISION*


NAME
       SDL_REVISION -- Function

SYNOPSIS
       This macro is a string describing the source at a particular point in develop‐
       ment.

REMARKS
       The revision is a string including sequential revision number that  is  incre‐
       mented with each commit, and a hash of the last code change.

       Example: hg-5344:94189aa89b54

       SDL_revision.h  must be included in your program explicitly if you want to use
       the SDL_REVISION constant.

RELATED FUNCTIONS
       SDL_GetRevision

===============================================================================
                                                           *SDL_RWFromConstMem*


NAME
       SDL_RWFromConstMem -- Function

SYNOPSIS
       Use this function to prepare a read-only memory buffer for use with RWops.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ SDL_RWops* SDL_RWFromConstMem(const void*   mem,   │
       │                               int           size)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ mem   │ a  pointer  to  a  read-only │
       │       │ buffer to feed an  SDL_RWops │
       │       │ stream                       │
       ├───────┼──────────────────────────────┤
       │ size  │ the buffer size, in bytes    │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns  a  pointer  to  a  new SDL_RWops structure, or NULL if it fails; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────┐
       │ char bitmap[] = {                                                                            │
       │   66, 77, 86, 2, 0, 0, 0, 0 ...                                                              │
       │ };                                                                                           │
       │ SDL_RWops *rw = SDL_RWFromConstantMem(bitmap, sizeof(bitmap));                               │
       │ SDL_Surface *img = SDL_LoadBMP_RW(rw, 1); /* Automatically frees the RWops struct for us */  │
       │ /* Do something with img ... */                                                              │
       └──────────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This function sets up an SDL_RWops struct based on a memory area of a  certain
       size. It assumes the memory area is not writable.

       Attempting  to write to this RWops stream will report an error without writing
       to the memory buffer.

       This memory buffer is not copied by the RWops; the pointer  you  provide  must
       remain  valid until you close the stream. Closing the stream will not free the
       original buffer.

       If you need to write to a memory buffer, you should use SDL_RWFromMem() with a
       writable buffer of memory instead.

RELATED FUNCTIONS
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromFP
       SDL_RWFromMem
       SDL_RWread
       SDL_RWseek
       SDL_RWtell

===============================================================================
                                                                 *SDL_RWFromFP*


NAME
       SDL_RWFromFP -- Function

SYNOPSIS
       Use  this  function  to create an SDL_RWops structure from a standard I/O file
       pointer (stdio.h's FILE*).

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ SDL_RWops* SDL_RWFromFP(void*       fp,         │
       │                         SDL_bool    autoclose)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ fp         │ the  FILE*  that  feeds  the │
       │            │ SDL_RWops stream             │
       ├────────────┼──────────────────────────────┤
       │ autoclose  │ SDL_TRUE  to close the FILE* │
       │            │ when closing the  SDL_RWops, │
       │            │ SDL_FALSE to leave the FILE* │
       │            │ open  when  the   RWops   is │
       │            │ closed                       │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to the SDL_RWops structure that is created, or NULL on fail‐
       ure; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────┐
       │ FILE *fp = fopen("myfile.dat", "rb");                                 │
       │ SDL_RWops *rw = SDL_RWFromFP(fp, SDL_TRUE);                           │
       │ /* Do things with rw... */                                            │
       │ SDL_RWclose(rw);  /* Automatically does an fclose(fp) in this case*/  │
       └───────────────────────────────────────────────────────────────────────┘

REMARKS
       This function is not available on Windows, since files opened in  an  applica‐
       tion on that platform cannot be used by a dynamically linked library.

       On  some platforms, the first parameter is a void*, on others, it's FILE*, de‐
       pending on what system headers are available to SDL. It is always intended  to
       be the FILE* type from the C runtime's stdio.h.

RELATED FUNCTIONS
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromMem
       SDL_RWread
       SDL_RWseek
       SDL_RWtell
       SDL_RWwrite

===============================================================================
                                                               *SDL_RWFromFile*


NAME
       SDL_RWFromFile -- Function

SYNOPSIS
       Use  this function to create a new SDL_RWops structure for reading from and/or
       writing to a named file.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ SDL_RWops* SDL_RWFromFile(const char*   file,  │
       │                           const char*   mode)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ file  │ a UTF-8 string  representing │
       │       │ the filename to open         │
       ├───────┼──────────────────────────────┤
       │ mode  │ an ASCII string representing │
       │       │ the  mode  to  be  used  for │
       │       │ opening  the  file;  see Re‐ │
       │       │ marks for details            │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns a pointer to the SDL_RWops structure that is created, or NULL on fail‐
       ure; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_RWops *file = SDL_RWFromFile("myimage.bmp", "rb");                                   │
       │ SDL_Surface *image = SDL_LoadBMP_RW(file, 1); /* 1 to automatically close the RWops. */  │
       │ /* Do something with image here */                                                       │
       └──────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The  mode  string  is treated roughly the same as in a call to the C library's
       fopen(), even if SDL doesn't happen to use fopen() behind the scenes.

       Available mode strings:

       ┌─────┬──────────────────────────────┐
       │ r   │ Open a file for reading. The │
       │     │ file must exist.             │
       ├─────┼──────────────────────────────┤
       │ w   │ Create  an  empty  file  for │
       │     │ writing. If a file with  the │
       │     │ same  name  already  exists, │
       │     │ its content  is  erased  and │
       │     │ the file is treated as a new │
       │     │ empty file.                  │
       ├─────┼──────────────────────────────┤
       │ a   │ Append to  a  file.  Writing │
       │     │ operations  append  data  at │
       │     │ the end  of  the  file.  The │
       │     │ file  is  created if it does │
       │     │ not exist.                   │
       ├─────┼──────────────────────────────┤
       │ r+  │ Open a file for update  both │
       │     │ reading   and  writing.  The │
       │     │ file must exist.             │
       ├─────┼──────────────────────────────┤
       │ w+  │ Create  an  empty  file  for │
       │     │ both reading and writing. If │
       │     │ a file with  the  same  name │
       │     │ already  exists, its content │
       │     │ is erased and  the  file  is │
       │     │ treated as a new empty file. │
       ├─────┼──────────────────────────────┤
       │ a+  │ Open  a file for reading and │
       │     │ appending. All writing oper‐ │
       │     │ ations  are performed at the │
       │     │ end of the file,  protecting │
       │     │ the  previous  content to be │
       │     │ overwritten. You can reposi‐ │
       │     │ tion  (fseek, fwind) the in‐ │
       │     │ ternal pointer  to  anywhere │
       │     │ in the file for reading, but │
       │     │ writing operations will move │
       │     │ it  back to the end of file. │
       │     │ The file is  created  if  it │
       │     │ does not exist.              │
       └─────┴──────────────────────────────┘
       Note:  In order to open a file as a binary file, a "b" character has to be in‐
       cluded in the mode string. This additional "b" character  can  either  be  ap‐
       pended  at  the  end  of the string (thus making the following compound modes:
       "rb", "wb", "ab", "r+b", "w+b", "a+b"). Additional characters may  follow  the
       sequence,  although  they should have no effect. For example, "t" is sometimes
       appended to make explicit the file is a text file.

       This function supports Unicode filenames, but they must be  encoded  in  UTF-8
       format, regardless of the underlying operating system.

       As a fallback, SDL_RWFromFile() will transparently open a matching filename in
       Android assets.

       Closing the SDL_RWops will close the file handle SDL is holding internally.

RELATED FUNCTIONS
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFP
       SDL_RWFromMem
       SDL_RWread
       SDL_RWseek
       SDL_RWtell
       SDL_RWwrite

===============================================================================
                                                                *SDL_RWFromMem*


NAME
       SDL_RWFromMem -- Function

SYNOPSIS
       Use  this  function  to  prepare  a  read-write  memory  buffer  for  use with
       SDL_RWops.

SYNTAX
       ┌──────────────────────────────────────────┐
       │ SDL_RWops* SDL_RWFromMem(void*    mem,   │
       │                          int      size)  │
       └──────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ mem   │ a pointer  to  a  buffer  to │
       │       │ feed an SDL_RWops stream     │
       ├───────┼──────────────────────────────┤
       │ size  │ the buffer size, in bytes    │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns  a  pointer  to  a  new SDL_RWops structure, or NULL if it fails; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────┐
       │ char bitmap[310000];                                                                    │
       │ SDL_RWops *rw = SDL_RWFromMem(bitmap, sizeof(bitmap));                                  │
       │ SDL_SaveBMP_RW(screen, rw, 1);  /* close SDL_RWops, leaves us memory buffer of data */  │
       └─────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This function sets up an SDL_RWops struct based on a memory area of a  certain
       size, for both read and write access.

       This  memory  buffer  is not copied by the RWops; the pointer you provide must
       remain valid until you close the stream. Closing the stream will not free  the
       original buffer.

       If  you  need  to  make  sure the RWops never writes to the memory buffer, you
       should use SDL_RWFromConstMem() with a read-only buffer of memory instead.

RELATED FUNCTIONS
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromFP
       SDL_FromMem
       SDL_RWread
       SDL_RWseek
       SDL_RWtell
       SDL_RWwrite

===============================================================================
                                                                  *SDL_RWclose*


NAME
       SDL_RWclose -- Function

SYNOPSIS
       Use this function to close and free an allocated SDL_RWops structure.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_RWclose(struct SDL_RWops*   context)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ context  │ SDL_RWops structure to close │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────┐
       │ Uint8 buf[256];                                   │
       │ SDL_RWops *rw = SDL_RWFromFile("test.bin", "r");  │
       │ if (rw != NULL)                                   │
       │ {                                                 │
       │   SDL_RWread(rw, buf, sizeof(buf), 1);            │
       │   SDL_RWclose(rw);                                │
       │ }                                                 │
       │ // Go on and use the data in buf...               │
       └───────────────────────────────────────────────────┘

REMARKS
       SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases  any  re‐
       sources  used  by the stream and frees the SDL_RWops itself with SDL_FreeRW().
       This returns 0 on success, or -1 if the stream failed to flush to  its  output
       (e.g. to disk).

       Note  that if this fails to flush the stream to disk, this function reports an
       error, but the SDL_RWops is still invalid once this function returns.

       SDL_RWclose() is actually a macro that calls the SDL_RWops's close method  ap‐
       propriately, to simplify application development.

RELATED FUNCTIONS
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromFP
       SDL_RWFromMem
       SDL_RWread
       SDL_RWseek
       SDL_RWwrite

===============================================================================
                                                                    *SDL_RWops*


NAME
       SDL_RWops -- Structure

SYNOPSIS
       A  structure  that  provides an abstract interface to stream I/O. Applications
       can generally ignore the specifics of this  structure's  internals  and  treat
       them  as  opaque  pointers. The details are important to lower-level code that
       might need to implement one of these, however.

DATA FIELDS
       ┌────────────────────────────────────────────────────────┬────────┬───────────────────────┐
       │ Sint64 (*)(SDL_RWops *)                                │ size   │ callback that reports │
       │                                                        │        │ stream  size; see Re‐ │
       │                                                        │        │ marks                 │
       ├────────────────────────────────────────────────────────┼────────┼───────────────────────┤
       │ Sint64 (*)(SDL_RWops *, Sint64, int)                   │ seek   │ callback  that  seeks │
       │                                                        │        │ in  stream;  see  Re‐ │
       │                                                        │        │ marks                 │
       ├────────────────────────────────────────────────────────┼────────┼───────────────────────┤
       │ size_t (*)(SDL_RWops *, void *, size_t, size_t)        │ read   │ callback  that  reads │
       │                                                        │        │ from  the stream; see │
       │                                                        │        │ Remarks               │
       ├────────────────────────────────────────────────────────┼────────┼───────────────────────┤
       │ size_t (*)(SDL_RWops *, const void *, size_t, size_t)  │ write  │ callback that  writes │
       │                                                        │        │ to  the  stream;  see │
       │                                                        │        │ Remarks               │
       ├────────────────────────────────────────────────────────┼────────┼───────────────────────┤
       │ int (*)(SDL_RWops *)                                   │ close  │ callback that  closes │
       │                                                        │        │ the  stream;  see Re‐ │
       │                                                        │        │ marks                 │
       ├────────────────────────────────────────────────────────┼────────┼───────────────────────┤
       │ Uint32                                                 │ type   │ type of  stream;  see │
       │                                                        │        │ Remarks               │
       ├────────────────────────────────────────────────────────┼────────┼───────────────────────┤
       │ union                                                  │ hidden │ type-specific   data; │
       │                                                        │        │ see Remarks           │
       └────────────────────────────────────────────────────────┴────────┴───────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────┐
       │ SDL_RWops *io = SDL_RWFromFile("username.txt", "rb");  │
       │ if (io != NULL) {                                      │
       │   char name[256];                                      │
       │   if (io->read(io, name, sizeof(name), 1) > 0) {       │
       │     printf("Hello, $s!0, name);                        │
       │   }                                                    │
       │   io->close(io);                                       │
       │ }                                                      │
       └────────────────────────────────────────────────────────┘

       The following is functionally identical to the above  example,  but  uses  the
       recommended macro interface.

       ┌────────────────────────────────────────────────────────┐
       │ SDL_RWops *io = SDL_RWFromFile("username.txt", "rb");  │
       │ if (io != NULL) {                                      │
       │   char name[256];                                      │
       │   if (SDL_RWread(io, name, sizeof(name), 1) > 0) {     │
       │     printf("Hello, %s!0, name);                        │
       │   }                                                    │
       │   SDL_RWclose(io);                                     │
       │ }                                                      │
       └────────────────────────────────────────────────────────┘

REMARKS
       SDL_RWops  is  an  abstraction over I/O. It provides interfaces to read, write
       and seek data in a stream, without the caller needing to know where  the  data
       is coming from.

       For  example, a RWops might be fed by a memory buffer, or a file on disk, or a
       connection to a web server, without any changes to how the caller consumes the
       data.

       SDL  provides some internal methods for reading from common stream types, like
       files and memory buffers, but this structure can be used by the application or
       third party libraries to implement whatever type of stream it pleases.

       Mose  of  the  fields of this structure are function pointers that are used as
       callbacks to implement the stream interface. All of them use  SDLCALL  calling
       convention.

       Please note that many of these function pointers used ints in SDL 1.2; to give
       them a better range, they have become Sint64 in SDL 2.0.

       Application shouldn't have to care about the internals of this structure. They
       can  treat  it  as  an  opaque  data pointer and use the SDL_RWread(), SDL_WR‐
       write(), SDL_RWseek(), SDL_RWtell(), and SDL_RWclose() functions on them.  Ap‐
       plications  almost never create or modify these structures either, instead fa‐
       voring creation functions like SDL_RWFromFile(), SDL_RWFromMem(), etc.

       Third-party libraries and special low-level code may need to know how to prop‐
       erly implement this struct, however.

   Size Function
       size  is  a function pointer that reports the stream's total size in bytes. If
       the stream size can't be determined (either because it doesn't make sense  for
       the stream type, or there was an err), this function returns -1.

   Seek Function
       seek is a function pointer that positions the next read/write operation in the
       stream. This seeks in byte offsets. If the stream cannot seek (either  because
       it  doesn't make sense for the stream type, or there was an error), this func‐
       tion returns -1, otherwise it returns the new  position.  Seeking  zero  bytes
       from RW_SEEK_CUR is a common way to determine the current stream position.

       The final argument works like the standard fseek() "whence":

       ┌──────────────┬───────┬───────────────────────┐
       │ Identifier   │ Value │ Explanation           │
       ├──────────────┼───────┼───────────────────────┤
       │ RW_SEEK_SET  │ 0     │ Seek  from the begin‐ │
       │              │       │ ning of data          │
       ├──────────────┼───────┼───────────────────────┤
       │ RW_SEEK_CUR  │ 1     │ Seek relative to cur‐ │
       │              │       │ rent read point       │
       ├──────────────┼───────┼───────────────────────┤
       │ RW_SEEK_END  │ 2     │ Seek  relative to the │
       │              │       │ end of data           │
       └──────────────┴───────┴───────────────────────┘

   Read Function
       read is a function pointer that reads from the stream. It reads up to num  ob‐
       jects each of size bytes into the buffer pointer to by ptr. Returns the number
       of objects read, which may be less than requested. Returns 0 on error or EOF.

   Write Function
       write is a function pointer that writes to the stream. It writes  exactly  num
       objects each of size bytes from the buffer pointer to by ptr. Returns the num‐
       ber of objects written, which will be less than requested on error.

   Close Function
       close is a function pointer that cleans up the stream. It should  release  any
       resources  used by the stream and free the SDL_RWops itself with SDL_FreeRW().
       This returns 0 on success, or -1 if the stream failed to  flush  to  disk  (or
       whereever). The SDL_RWops is no longer valid after this call, even if flushing
       the stream failed.

   Stream Type
       The type field is currently one of these values. An  application  can  usually
       ignore this information.

       ┌──────────────────────┬───────┬───────────────────────┐
       │ Identifier           │ Value │ Description           │
       ├──────────────────────┼───────┼───────────────────────┤
       │ SDL_RWOPS_UNKNOWN    │ 0     │ Unknown  stream  type │
       │                      │       │ or    application-de‐ │
       │                      │       │ fined                 │
       ├──────────────────────┼───────┼───────────────────────┤
       │ SDL_RWOPS_WINFILE    │ 1     │ Win32 file handle     │
       ├──────────────────────┼───────┼───────────────────────┤
       │ SDL_RWOPS_STDFILE    │ 2     │ stdio.h FILE*         │
       ├──────────────────────┼───────┼───────────────────────┤
       │ SDL_RWOPS_JNIFILE    │ 3     │ Android asset         │
       ├──────────────────────┼───────┼───────────────────────┤
       │ SDL_RWOPS_MEMORY     │ 4     │ Memory         stream │
       │                      │       │ (read/write)          │
       ├──────────────────────┼───────┼───────────────────────┤
       │ SDL_RWOPS_MEMORY_RO  │ 5     │ Memory stream  (read- │
       │                      │       │ only)                 │
       └──────────────────────┴───────┴───────────────────────┘

       Applications  and libraries rolling their own RWops implementations should use
       SDL_RWOPS_UNKNOWN. All other values are currently reserved for SDL's  internal
       use.

   Hidden Union
       Applications can ignore this union completely. All of the fields in this union
       are platform-specific and off-limits, used internally by SDL, with one  excep‐
       tion.  You may use the unknown struct to store your own RWops implementation's
       data, possibly cleaning it up during the close method. If  your  data  doesn't
       fit  in  two pointers, use these pointers, to hold an allocated structure that
       contains the real data.

RELATED FUNCTIONS
       SDL_AllocRW
       SDL_FreeRW
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromFP
       SDL_RWFromMem
       SDL_RWread
       SDL_RWseek
       SDL_RWtell
       SDL_RWwrite

===============================================================================
                                                                   *SDL_RWread*


NAME
       SDL_RWread -- Function

SYNOPSIS
       Use this function to read from a data source.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ size_t SDL_RWread(struct SDL_RWops*   context,  │
       │                   void*               ptr,      │
       │                   size_t              size,     │
       │                   size_t              maxnum)   │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ context  │ a  pointer  to  an SDL_RWops │
       │          │ structure                    │
       ├──────────┼──────────────────────────────┤
       │ ptr      │ a pointer  to  a  buffer  to │
       │          │ read data into               │
       ├──────────┼──────────────────────────────┤
       │ size     │ the  size  of each object to │
       │          │ read, in bytes               │
       ├──────────┼──────────────────────────────┤
       │ maxnum   │ the maximum  number  of  ob‐ │
       │          │ jects to be read             │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the  number  of  objects  read,  or  0  at error or end of file; call
       SDL_GetError() for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────┐
       │ SDL_RWops* rw = SDL_RWFromFile("test.bin", "r");  │
       │ if (rw != NULL)                                   │
       │ {                                                 │
       │   extern Uint8 buf[256];                          │
       │   SDL_RWread(rw, buf, sizeof(buf), 1);            │
       │   SDL_RWclose(rw);                                │
       │ }                                                 │
       └───────────────────────────────────────────────────┘
       Read a complete file in memory (assuming size can be  detected)  (from  OpenGL
       WikiBook       (https://gitlab.com/wikibooks-opengl/modern-tutorials/blob/mas‐
       ter/common-sdl2/shader_utils.cpp)):

       ┌────────────────────────────────────────────────────────────────────┐
       │ char* file_read(const char* filename) {                            │
       │   SDL_RWops* rw = SDL_RWFromFile(filename, "rb");                  │
       │   if (rw == NULL) return NULL;                                     │
       │                                                                    │
       │   Sint64 res_size = SDL_RWsize(rw);                                │
       │   char* res = (char*)malloc(res_size + 1);                         │
       │                                                                    │
       │   Sint64 nb_read_total = 0, nb_read = 1;                           │
       │   char* buf = res;                                                 │
       │   while (nb_read_total < res_size && nb_read != 0)                 │
       │   {                                                                │
       │     nb_read = SDL_RWread(rw, buf, 1, (res_size - nb_read_total));  │
       │     nb_read_total += nb_read;                                      │
       │     buf += nb_read;                                                │
       │   }                                                                │
       │   SDL_RWclose(rw);                                                 │
       │   if (nb_read_total != res_size)                                   │
       │   {                                                                │
       │     free(res);                                                     │
       │     return NULL;                                                   │
       │   }                                                                │
       │                                                                    │
       │   res[nb_read_total] = '\0';                                       │
       │   return res;                                                      │
       │ }                                                                  │
       └────────────────────────────────────────────────────────────────────┘

REMARKS
       This function reads up to maximum objects each of  size  size  from  the  data
       source to the area pointed at by ptr. This function may read less objects than
       requested. It will return zero when there has been an error or the data stream
       is completely read.

       SDL_RWread() is actually a macro that calls the SDL_RWops's read method appro‐
       priately, to simplify application development.

       More Examples

       ┌────────────────────────────────────────────────┐
       │ Uint32 buffer[10];                             │
       │ SDL_RWread(rwop, buffer, sizeof(Uint32), 10);  │
       └────────────────────────────────────────────────┘
       This will read 40 bytes of data, and put it into 'buffer', which  is  intended
       to hold 32-bit integers. Each Uint32 is 4 bytes, or 32-bits.

       ┌────────────────────────────────────────────────┐
       │ Uint64 buffer[10];                             │
       │ SDL_RWread(rwop, buffer, sizeof(Uint64), 10);  │
       └────────────────────────────────────────────────┘
       This  will  read  80 bytes of data, and place them into 'buffer', which is now
       designed for 64-bit integers (Uint64 values). Each Uint64 (long) is  8  bytes,
       and we are reading 10 of them (as shown by buffer[10] when we make it).

RELATED FUNCTIONS
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromFP
       SDL_RWFromMem
       SDL_RWseek
       SDL_RWwrite

===============================================================================
                                                                   *SDL_RWseek*


NAME
       SDL_RWseek -- Function

SYNOPSIS
       Use this function to seek within an SDL_RWops data stream.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ Sint64 SDL_RWseek(SDL_RWops*    context,  │
       │                   Sint64        offset,   │
       │                   int           whence    │
       │ )                                         │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ context  │ a  pointer  to  an SDL_RWops │
       │          │ structure                    │
       ├──────────┼──────────────────────────────┤
       │ offset   │ an offset in bytes, relative │
       │          │ to  whence  location; can be │
       │          │ negative                     │
       ├──────────┼──────────────────────────────┤
       │ whence   │ any of RW_SEEK, RW_SEEK_CUR, │
       │          │ RW_SEEK_END; see Remarks for │
       │          │ details                      │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns the final offset in the data stream after the seek or -1 oon error.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────┐
       │ SDL_RWops *rw = SDL_RWFromFile("myfile.bin", "rb");   │
       │ if (rw != NULL)                                       │
       │ {                                                     │
       │   /* Seek to 0 bytes from the end of the file */      │
       │   Sint64 length = SDL_RWseek(rw, 0, RW_SEEK_END);     │
       │   SDL_RWclose(rw);                                    │
       │                                                       │
       │   if (length < 0)                                     │
       │   {                                                   │
       │     printf("Could not seek inside myfile.bin\n");     │
       │   }                                                   │
       │   else                                                │
       │   {                                                   │
       │     printf("myfile.bin is %d bytes long\n", length);  │
       │   }                                                   │
       │ }                                                     │
       └───────────────────────────────────────────────────────┘

REMARKS
       This function seeks to offset relative to whence.

       whence may be any of the following values:

       ┌──────────────┬──────────────────────────────┐
       │ RW_SEEK_SET  │  seek from the beginning of  │
       │              │  data                        │
       ├──────────────┼──────────────────────────────┤
       │ RW_SEEK_CUR  │  seek  relative  to current  │
       │              │  read point                  │
       ├──────────────┼──────────────────────────────┤
       │ RW_SEEK_END  │  seek relative to  the  end  │
       │              │  of data                     │
       └──────────────┴──────────────────────────────┘
       If this stream cannot seek, it will return -1.

       SDL_RWseek() is actually a macro that calls the SDL_RWops's seek method appro‐
       priately, to simplify application development.

RELATED FUNCTIONS
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromFP
       SDL_RWFromMem
       SDL_RWread
       SDL_RWtell
       SDL_RWwrite

===============================================================================
                                                                   *SDL_RWsize*


NAME
       SDL_RWsize -- Function

SYNOPSIS
       Use this macro to get the size of the data stream in an SDL_RWops.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ Sint64 SDL_RWsize(SDL_RWops*    context)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ context  │ the  SDL_RWops  to  get  the │
       │          │ size of the data stream from │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns the size of the data stream in the SDL_RWops on success, -1 if unknown
       or a negative error code on failure; call SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

===============================================================================
                                                                   *SDL_RWtell*


NAME
       SDL_RWtell -- Function

SYNOPSIS
       Use  this function to determine the current read/write offset in and SDL_RWops
       data stream.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ Sint64 SDL_RWtell(struct SDL_RWops*   context)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ context  │ a SDL_RWops data stream  ob‐ │
       │          │ ject  from  which to get the │
       │          │ current offset               │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns the current offset in the stream, or -1 if the information  cannot  be
       determined.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────┐
       │ extern SDL_RWops *rw;                                                     │
       │ printf("Current position in stream: %lld\n", (long long)SDL_RWtell(rw));  │
       │ if (SDL_RWseek(rw, 0, RW_SEEK_END) != -1)                                 │
       │ {                                                                         │
       │   printf("Final position in stream: %lld\n", (long long)SDL_RWtell(rw));  │
       │ }                                                                         │
       └───────────────────────────────────────────────────────────────────────────┘

REMARKS
       SDL_RWtell is actually a macro that calls the SDL_RWops's seek method, with an
       offset of 0 bytes from RW_SEEK_CUR, to simplify application development.

RELATED FUNCTIONS
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromFP
       SDL_RWFromMem
       SDL_RWread
       SDL_RWseek
       SDL_RWwrite

===============================================================================
                                                                  *SDL_RWwrite*


NAME
       SDL_RWwrite -- Function

SYNOPSIS
       Use this function to write to an SDL_RWops data stream.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ size_t SDL_RWwrite(strut SDL_RWops*   context,  │
       │                    const void*        ptr,      │
       │                    size_t             size,     │
       │                    size_t             num)      │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ context  │ a  pointer  to  an SDL_RWops │
       │          │ structure                    │
       ├──────────┼──────────────────────────────┤
       │ ptr      │ a pointer to a  buffer  con‐ │
       │          │ taining data to write        │
       ├──────────┼──────────────────────────────┤
       │ size     │ the  size  of  an  object to │
       │          │ write, in bytes              │
       ├──────────┼──────────────────────────────┤
       │ num      │ the  number  of  objects  to │
       │          │ write                        │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the  number of objects written, which will be less than num on error;
       call SDL_GetError() for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────┐
       │ SDL_RWops *rw = SDL_RWFromFile("hello.txt", "w");  │
       │ if (rw != NULL)                                    │
       │ {                                                  │
       │   const char *str = "Hello World";                 │
       │   size_t len = SDL_strlen(str);                    │
       │                                                    │
       │   if (SDL_RWwrite(rw, str, 1, len) != len)         │
       │   {                                                │
       │     printf("Couldn't fully write string\n");       │
       │   }                                                │
       │   else                                             │
       │   {                                                │
       │     printf("Wrote %d 1-byte blocks\n", len);       │
       │   }                                                │
       │   SDL_RWclose(rw);                                 │
       │ }                                                  │
       └────────────────────────────────────────────────────┘

REMARKS
       This function writes exactly num objects each  of  size  size  from  the  area
       pointed  at  by  ptr to the stream. If this fails for any reason, it'll return
       less than num to demonstrate how far the write progressed. On success, it  re‐
       turns num.

       SDL_RWwrite is actually a macro that calls the SDL_RWops's write method appro‐
       priately, to simplify application development.

RELATED FUNCTIONS
       SDL_RWclose
       SDL_RWFromConstMem
       SDL_RWFromFile
       SDL_RWFromFP
       SDL_RWFromMem
       SDL_RWread
       SDL_RWseek

===============================================================================
                                                              *SDL_RaiseWindow*


NAME
       SDL_RaiseWindow -- Function

SYNOPSIS
       Use  this function to raise a window above other windows and set the input fo‐
       cus.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ void SDL_RaiseWindow(SDL_Window*    window)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬─────────────────────┐
       │ window  │ the window to raise │
       └─────────┴─────────────────────┘

===============================================================================
                                                                 *SDL_ReadBE16*


NAME
       SDL_ReadBE16 -- Function

SYNOPSIS
       Use this function to read 16 bits of big-endian data from an SDL_RWops and re‐
       turn in native format.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ Uint16 SDL_ReadBE16(SDL_RWops*    src)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ src  │ the  stream  from  which  to │
       │      │ read data                    │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns 16 bits of data in the native byte order of the platform.

REMARKS
       SDL  byteswaps the data only if necessary, so the data returned will be in the
       native byte order.

RELATED FUNCTIONS
       SDL_ReadLE16

===============================================================================
                                                                 *SDL_ReadBE32*


NAME
       SDL_ReadBE32 -- Function

SYNOPSIS
       Use this function to read 32 bits of big-endian data from an SDL_RWops and re‐
       turn in native format.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ Uint32 SDL_ReadBE32(SDL_RWops*    src)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ src  │ the  stream  from  which  to │
       │      │ read data                    │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns 32 bits of data in the native byte order of the platform.

REMARKS
       SDL  byteswaps the data only if necessary, so the data returned will be in the
       native byte order.

RELATED FUNCTIONS
       SDL_ReadLE32

===============================================================================
                                                                 *SDL_ReadBE64*


NAME
       SDL_ReadBE64 -- Function

SYNOPSIS
       Use this function to read 64 bits of big-endian data from SDL_RWops and return
       in native format.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ Uint64 SDL_ReadBE64(SDL_RWops*    src)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ src  │ the  stream  from  which  to │
       │      │ read data                    │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns 64 bits of data in the native byte order of the platform.

REMARKS
       SDL  byteswaps the data only if necessary, so the data returned will be in the
       native byte order.

RELATED FUNCTIONS
       SDL_ReadLE64

===============================================================================
                                                                 *SDL_ReadLE16*


NAME
       SDL_ReadLE16 -- Function

SYNOPSIS
       Use  this function to read 16 bits of little-endian data from an SDL_RWops and
       return in native format.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ Uint16 SDL_ReadLE16(SDL_RWops*    src)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ src  │ the  stream  from  which  to │
       │      │ read data                    │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns 16 bits of data in the native byte order of the platform.

REMARKS
       SDL  byteswaps the data only if necessary, so the data returned will be in the
       native byte order.

RELATED FUNCTIONS
       SDL_ReadBE16

===============================================================================
                                                                 *SDL_ReadLE32*


NAME
       SDL_ReadLE32 -- Function

SYNOPSIS
       Use this function to read 32 bits of little-endian data from SDL_RWops and re‐
       turn in native format.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ Uint32 SDL_ReadLE32(SDL_RWops*    src)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ src  │ the  stream  from  which  to │
       │      │ read data                    │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns 32 bits of data in the native byte order of the platform.

REMARKS
       SDL  byteswaps the data only if necessary, so the data returned will be in the
       native byte order.

RELATED FUNCTIONS
       SDL_ReadBE32

===============================================================================
                                                                 *SDL_ReadLE64*


NAME
       SDL_ReadLE64 -- Function

SYNOPSIS
       Use  this function to read 64 bits of little-endian data from an SDL_RWops and
       return in native format.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ Uint64 SDL_ReadLE64(SDL_RWops*    src)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ src  │ the  stream  from  which  to │
       │      │ read data                    │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns 64 bits of data in the native byte order of the platform.

REMARKS
       SDL  byteswaps the data only if necessary, so the data returned will be in the
       native byte order.

RELATED FUNCTIONS
       SDL_ReadBE64

===============================================================================
                                                                   *SDL_ReadU8*


NAME
       SDL_ReadU8 -- Function

SYNOPSIS
       Use this function to read a byte from an SDL_RWops

SYNTAX
       ┌─────────────────────────────────────┐
       │ Uint8 SDL_ReadU8(SDL_RWops*   src)  │
       └─────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬────────────────────────────┐
       │ src  │ the SDL_RWops to read from │
       └──────┴────────────────────────────┘

RETURN VALUE
       Returns the read byte on success or 0 on failure; call SDL_GetError() for more
       information.

RELATED FUNCTIONS
       SDL_WriteU8

===============================================================================
                                                            *SDL_RecordGesture*


NAME
       SDL_RecordGesture -- Function

SYNOPSIS
       Use  this function to begin recording a gesture on a specified touch device or
       all touch devices.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_RecordGesture(SDL_TouchID   touchId)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ touchId  │ the touch device id,  or  -1 │
       │          │ for all touch devices        │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on success or 0 if the specified device could not be found.

REMARKS
       If  the parameter touchId is -1 (i.e., all devices), this function will always
       return 1, regardless of whether there actually are any devices.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetTouchDevice

===============================================================================
                                                                     *SDL_Rect*


NAME
       SDL_Rect -- Structure

SYNOPSIS
       A  structure  that  contains the definition of a rectangle, with the origin at
       the upper left.

DATA FIELDS
       ┌──────┬───┬───────────────────────┐
       │ int  │ x │ the x location of the │
       │      │   │ rectangle's     upper │
       │      │   │ left corner           │
       ├──────┼───┼───────────────────────┤
       │ int  │ y │ the y location of the │
       │      │   │ rectangle's     upper │
       │      │   │ left corner           │
       ├──────┼───┼───────────────────────┤
       │ int  │ w │ the width of the rec‐ │
       │      │   │ tangle                │
       ├──────┼───┼───────────────────────┤
       │ int  │ h │ the   height  of  the │
       │      │   │ rectangle             │
       └──────┴───┴───────────────────────┘

CODE EXAMPLES
       ┌─────────────────────────────────────────────────┐
       │ SDL_Rect srcrect;                               │
       │ SDL_Rect dstrect;                               │
       │                                                 │
       │ srcrect.x = 0;                                  │
       │ srcrect.y = 0;                                  │
       │ srcrect.w = 32;                                 │
       │ srcrect.h = 32;                                 │
       │ dstrect.x = 640/2;                              │
       │ dstrect.y = 480/2;                              │
       │ dstrect.w = 32;                                 │
       │ dstrect.h = 32;                                 │
       │                                                 │
       │ SDL_BlitSurface(src, &srcrect, dst, &dstrect);  │
       └─────────────────────────────────────────────────┘

REMARKS
       An SDL_Rect defines a rectangular area of the screen. It is used by  SDL_Blit‐
       Surface() to define blitting regions and by several other video functions.

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_EnclosePoints
       SDL_GetDisplayBounds
       SDL_HashIntersection
       SDL_IntersectRect
       SDL_LockTexture
       SDL_RenderCopy
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderReadPixels
       SDL_UnionRect
       SDL_UpdateTexture

===============================================================================
                                                                *SDL_RectEmpty*


NAME
       SDL_RectEmpty -- Function

SYNOPSIS
       Use this function to check whether a rectangle has no area.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ SDL_bool SDL_RectEmpty(const SDL_Rect*    r)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ r  │ the  SDL_Rect structure rep‐ │
       │    │ resenting the  rectangle  to │
       │    │ check                        │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the rectangle has no area or SDL_FALSE if it does, see Re‐
       marks for details.

REMARKS
       If the rectangle defined by r is NULL or has a width or height <= 0, it has no
       area  and this function returns SDL_TRUE. If both width and height are > 0 the
       rectangle has area and this function returns SDL_FALSE.

===============================================================================
                                                               *SDL_RectEquals*


NAME
       SDL_RectEquals -- Function

SYNOPSIS
       Use this function to check whether two rectangles are equal.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ SDL_bool SDL_RectEquals(const SDL_Rect*   a,  │
       │                         const SDL_Rect*   b)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ a  │ an SDL_Rect structure repre‐ │
       │    │ senting the first rectangle  │
       ├────┼──────────────────────────────┤
       │ b  │ an SDL_Rect structure repre‐ │
       │    │ senting the second rectangle │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns  SDL_TRUE if the two rectangles are exactly the same, SDL_FALSE other‐
       wise; see Remarks for details.

REMARKS
       This function compares the width, height, and location (X and  Y)  values  for
       each  of  the  two rectangles and returns SDL_TRUE if all corresponding values
       are equal. If any value does not match or either rectangle is NULL, it returns
       SDL_FALSE.

===============================================================================
                                                           *SDL_RegisterEvents*


NAME
       SDL_RegisterEvents -- Function

SYNOPSIS
       Use this function to allocate a set of user-defined events, and return the be‐
       ginning event number for that set of events.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ Uint32 SDL_RegisterEvents(int   numevents)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ numevents  │ the number of events  to  be │
       │            │ allocated                    │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       The beginning event number, or (Uint32)-1 if there are not enough user-defined
       events left.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────┐
       │ Uint32 myEventType = SDL_RegisterEvents(1);                       │
       │ if (myEventType != ((Uint32)-1))                                  │
       │ {                                                                 │
       │   SDL_Event event;                                                │
       │   SDL_memset(&event, 0, sizeof(event)); /* or SDL_zero(event) */  │
       │   event.type = myEventType;                                       │
       │   event.user.code = my_event_code;                                │
       │   event.user.data1 = significant_data;                            │
       │   event.user.data2 = 0;                                           │
       │   SDL_PushEvent(&event);                                          │
       │ }                                                                 │
       └───────────────────────────────────────────────────────────────────┘

REMARKS
       Calling this function with  numevents  <=  0  is  an  error  and  will  return
       (Uint32)-1.

       Note,   (Uint32)-1  means  the  maximum  unsigned  32-bit  integer  value  (or
       0xFFFFFFFF), but is clearer to write.

RELATED FUNCTIONS
       SDL_PushEvent

===============================================================================
                                                              *SDL_RemoveTimer*


NAME
       SDL_RemoveTimer -- Function

SYNOPSIS
       Use this function to remove a timer created with SDL_AddTimer().

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ SDL_bool SDL_RemoveTimer(SDL_TimerID    id)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────┬──────────────────────────────┐
       │ id  │ the  ID  of the timer to re‐ │
       │     │ move                         │
       └─────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the timer is removed or  SDL_FALSE  if  the  timer  wasn't
       found.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────┐
       │ Uint32 delay = (33 / 10) * 10;  /* To round it down to the nearest 10 ms */         │
       │                                                                                     │
       │ /* ... */                                                                           │
       │                                                                                     │
       │ SDL_TimerID my_timer_id = SDL_AddTimer(delay, my_callbackfunc, my_callback_param);  │
       │                                                                                     │
       │ /* ... */                                                                           │
       │                                                                                     │
       │ SDL_RemoveTimer(my_timer_id);                                                       │
       └─────────────────────────────────────────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_AddTimer

===============================================================================
                                                              *SDL_RenderClear*


NAME
       SDL_RenderClear -- Function

SYNOPSIS
       Use  this  function  to  clear  the  current rendering target with the drawing
       color.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ int SDL_RenderClear(SDL_Renderer*   renderer)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬───────────────────────┐
       │ renderer  │ the rendering context │
       └───────────┴───────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                        │
       │                                                                                         │
       │ int main(int argc, char* argv[])                                                        │
       │ {                                                                                       │
       │   SDL_Window* window;                                                                   │
       │   SDL_Renderer* renderer;                                                               │
       │                                                                                         │
       │   /* Initialize SDL. */                                                                 │
       │   if (SDL_Init(SDL_INIT_VIDEO) < 0)                                                     │
       │     return 1;                                                                           │
       │                                                                                         │
       │   /* Create the window where we will drwa. */                                           │
       │   window = SDL_CreateWindow("SDL_RenderClear",                                          │
       │                             SDL_WINDOWPOS_CENTERED,                                     │
       │                             SDL_WINDOWPOS_CENTERED,                                     │
       │                             512,                                                        │
       │                             512,                                                        │
       │                             0);                                                         │
       │                                                                                         │
       │   /* We must call SDL_CreateRenderer in order for draw calls to affect this window. */  │
       │   renderer = SDL_CreateRenderer(window, -1, 0);                                         │
       │                                                                                         │
       │   /* Select the color for drawing. It is set to red here. */                            │
       │   SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);                                     │
       │                                                                                         │
       │   /* Clear the entire screen to our selected color. */                                  │
       │   SDL_RenderClear(renderer);                                                            │
       │                                                                                         │
       │   /* Up until now everything was drawn behind the scenes.                               │
       │      This will show the new, red contents of the window. */                             │
       │   SDL_RenderPresent(renderer);                                                          │
       │                                                                                         │
       │   /* Give us time to see the window */                                                  │
       │   SDL_Delay(5000);                                                                      │
       │                                                                                         │
       │   /* Always be sure to clean up */                                                      │
       │   SDL_Quit();                                                                           │
       │   return 0;                                                                             │
       │ }                                                                                       │
       └─────────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       This  function  clears  the entire rendering target, ignoring the viewport and
       the clip rectangle.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_SetRenderDrawColor

===============================================================================
                                                               *SDL_RenderCopy*


NAME
       SDL_RenderCopy -- Function

SYNOPSIS
       Use  this  function  to copy a portion of the texture to the current rendering
       target.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ int SDL_RenderCopy(SDL_Renderer*      renderer,  │
       │                    SDL_Texture*       texture,   │
       │                    const SDL_Rect*    srcrect,   │
       │                    const SDL_Rect*    dstrect)   │
       └──────────────────────────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ texture   │ the  source texture; see Re‐ │
       │           │ marks for details            │
       ├───────────┼──────────────────────────────┤
       │ srcrect   │ the source  SDL_Rect  struc‐ │
       │           │ ture  or NULL for the entire │
       │           │ texture                      │
       ├───────────┼──────────────────────────────┤
       │ dstrect   │ the   destination   SDL_Rect │
       │           │ structure  or  NULL  for the │
       │           │ entire rendering target; the │
       │           │ texture will be stretched to │
       │           │ fill the given rectangle     │
       └───────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                  │
       │ #define SHAPE_SIZE 16                                                             │
       │                                                                                   │
       │ int main(int argc, char *argv[])                                                  │
       │ {                                                                                 │
       │   SDL_Window* Main_Window;                                                        │
       │   SDL_Renderer* Main_Renderer;                                                    │
       │   SDL_Surface* Loading_Surf;                                                      │
       │   SDL_Texture* Background_Tx;                                                     │
       │   SDL_Texture* BlueShapes;                                                        │
       │                                                                                   │
       │   /* Rectangles for drawing which will specify source (inside the texture)        │
       │   and target (on the screen) for rendering our textures. */                       │
       │   SDL_Rect SrcR;                                                                  │
       │   SDL_Rect DestR;                                                                 │
       │                                                                                   │
       │   SrcR.x = 0;                                                                     │
       │   SrcR.y = 0;                                                                     │
       │   SrcR.w = SHAPE_SIZE;                                                            │
       │   SrcR.h = SHAPE_SIZE;                                                            │
       │                                                                                   │
       │   DestR.x = 640 / 2 - SHAPE_SIZE / 2;                                             │
       │   DestR.y = 580 / 2 - SHAPE_SIZE / 2;                                             │
       │   DestR.w = SHAPE_SIZE;                                                           │
       │   DestR.h = SHAPE_SIZE;                                                           │
       │                                                                                   │
       │                                                                                   │
       │   /* Before we can render anything, we need a window and a renderer */            │
       │   Main_Window = SDL_CreateWindow("SDL_RenderCopy Example",                        │
       │   SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 580, 0);                 │
       │   Main_Renderer = SDL_CreateRenderer(Main_Window, -1, SDL_RENDERER_ACCELERATED);  │
       │                                                                                   │
       │   /* The loading of the background texture. Since SDL_LoadBMP() returns           │
       │   a surface, we convert it to a texture afterwards for fast accelerated           │
       │   blitting. */                                                                    │
       │   Loading_Surf = SDL_LoadBMP("Background.bmp");                                   │
       │   Background_Tx = SDL_CreateTextureFromSurface(Main_Renderer, Loading_Surf);      │
       │   SDL_FreeSurface(Loading_Surf); /* we got the texture now -> free surface */     │
       │                                                                                   │
       │   /* Load an additional texture */                                                │
       │   Loading_Surf = SDL_LoadBMP("Blueshapes.bmp");                                   │
       │   BlueShapes = SDL_CreateTextureFromSurface(Main_Renderer, Loading_Surf);         │
       │   SDL_FreeSurface(Loading_Surf);                                                  │
       │                                                                                   │
       │   /* now onto the fun part.                                                       │
       │   This will render a rotating selection of the blue shapes                        │
       │   in the middle of the screen */                                                  │
       │   int i;                                                                          │
       │   int n;                                                                          │
       │   for (i = 0; i < 2; ++i) {                                                       │
       │     for(n = 0; n < 4; ++n) {                                                      │
       │       SrcR.x = SHAPE_SIZE * (n % 2);                                              │
       │       if (n > 1) {                                                                │
       │         SrcR.y = SHAPE_SIZE;                                                      │
       │       } else {                                                                    │
       │         SrcR.y = 0;                                                               │
       │       }                                                                           │
       │                                                                                   │
       │       /* render background, whereas NULL for source and destination               │
       │       rectangles just means "use the default" */                                  │
       │       SDL_RenderCopy(Main_Renderer, Background_Tx, NULL, NULL);                   │
       │                                                                                   │
       │       /* render the current animation step of our shape */                        │
       │       SDL_RenderCopy(Main_Renderer, BlueShapes, &SrcR, &DestR);                   │
       │       SDL_RenderPresent(Main_Renderer);                                           │
       │       SDL_Delay(500);                                                             │
       │     }                                                                             │
       │   }                                                                               │
       │                                                                                   │
       │                                                                                   │
       │   /* The renderer works pretty much like a big canvas:                            │
       │   when you RenderCopy() you are adding paint, each time adding it                 │
       │   on top.                                                                         │
       │   You can change how it blends with the stuff that                                │
       │   the new data goes over.                                                         │
       │   When your 'picture' is complete, you show it                                    │
       │   by using SDL_RenderPresent(). */                                                │
       │                                                                                   │
       │   /* SDL 1.2 hint: If you're stuck on the whole renderer idea coming              │
       │   from 1.2 surfaces and blitting, think of the renderer as your                   │
       │   main surface, and SDL_RenderCopy() as the blit function to that main            │
       │   surface, with SDL_RenderPresent() as the old SDL_Flip() function.*/             │
       │                                                                                   │
       │   SDL_DestroyTexture(BlueShapes);                                                 │
       │   SDL_DestroyTexture(Background_Tx);                                              │
       │   SDL_DestroyRenderer(Main_Renderer);                                             │
       │   SDL_DestroyWindow(Main_Window);                                                 │
       │   SDL_Quit();                                                                     │
       │                                                                                   │
       │                                                                                   │
       │   return 0;                                                                       │
       │ }                                                                                 │
       └───────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       The texture is blended with the destination based on its blend mode  set  with
       SDL_SetTextureBlendMode().

       The texture color is affected based on its color modulation set by SDL_SetTex‐
       tureColorMod().

       The texture alpha is affected based on its alpha modulation set by SDL_SetTex‐
       tureAlphaMod().

RELATED FUNCTIONS
       SDL_RenderCopyEx
       SDL_SetTextureAlphaMod
       SDL_SetTextureBlendMode
       SDL_SetTextureColorMod

===============================================================================
                                                             *SDL_RenderCopyEx*


NAME
       SDL_RenderCopyEx -- Function

SYNOPSIS
       Use  this  function  to copy a portion of the texture to the current rendering
       target, optionally rotating it by angle around the given center and also flip‐
       ping it top-down and/or left-right.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ int SDL_RenderCopyEx(SDL_Renderer*            renderer,  │
       │                      SDL_Texture*             texture,   │
       │                      const SDL_Rect*          srcrect,   │
       │                      const SDL_Rect*          dstrect,   │
       │                      const double             angle,     │
       │                      const SDL_Point*         center,    │
       │                      const SDL_RendererFlip   flip)      │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ texture   │ the  source texture; see Re‐ │
       │           │ marks for details            │
       ├───────────┼──────────────────────────────┤
       │ srcrect   │ the source  SDL_Rect  struc‐ │
       │           │ ture  or NULL for the entire │
       │           │ texture                      │
       ├───────────┼──────────────────────────────┤
       │ dstrect   │ the   destination   SDL_Rect │
       │           │ structure  or  NULL  for the │
       │           │ entire rendering target      │
       ├───────────┼──────────────────────────────┤
       │ angle     │ an angle in degrees that in‐ │
       │           │ dicates  the  rotation  that │
       │           │ will be applied  to  dstrect │
       │           │ rotating  it  in a clockwise │
       │           │ direction                    │
       ├───────────┼──────────────────────────────┤
       │ center    │ a pointer to a  point  indi‐ │
       │           │ cating  around which dstrect │
       │           │ will be  rotated  (if  NULL, │
       │           │ rotation will be done around │
       │           │ dstrect.w/2, dstrect.h/2)    │
       ├───────────┼──────────────────────────────┤
       │ flip      │ a   SDL_RendererFlip   value │
       │           │ stating  which  flipping ac‐ │
       │           │ tions should be performed on │
       │           │ the texture                  │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       The texture is blended with the destination based on its blend mode  set  with
       SDL_SetTextureBlendMode().

       The texture color is affected based on its color modulation set by SDL_SetTex‐
       tureColorMod().

       The texture alpha is affected based on its alpha modulation set by SDL_SetTex‐
       tureAlphaMod().

RELATED FUNCTIONS
       SDL_RenderCopy
       SDL_SetTextureAlphaMod
       SDL_SetTextureBlendMode
       SDL_SetTextureColorMod

===============================================================================
                                                           *SDL_RenderDrawLine*


NAME
       SDL_RenderDrawLine -- Function

SYNOPSIS
       Use this function to draw a line on the current rendering target.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_RenderDrawLine(SDL_Renderer*    renderer,  │
       │                        int              x1,        │
       │                        int              y1,        │
       │                        int              x2,        │
       │                        int              y2)        │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ x1        │ the   x  coordinate  of  the │
       │           │ start point                  │
       ├───────────┼──────────────────────────────┤
       │ y1        │ the  y  coordinate  of   the │
       │           │ start point                  │
       ├───────────┼──────────────────────────────┤
       │ x2        │ the  x coordinate of the end │
       │           │ point                        │
       ├───────────┼──────────────────────────────┤
       │ y2        │ the y coordinate of the  end │
       │           │ point                        │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
REMARKS
       SDL_RenderDrawLine() draws the line to include both end points. If you want to
       draw multiple, connecting lines use SDL_RenderDrawLines() instead.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderPresent
       SDL_SetRenderDrawBlendMode
       SDL_SetRenderDrawColor

===============================================================================
                                                          *SDL_RenderDrawLines*


NAME
       SDL_RenderDrawLines -- Function

SYNOPSIS
       Use this function to draw a series of connected lines on the current rendering
       target.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_RenderDrawLines(SDL_Renderer*       renderer,  │
       │                         const SDL_Point*    points,    │
       │                         int                 count)     │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ points    │ an array of SDL_Point struc‐ │
       │           │ tures   representing  points │
       │           │ along the lines              │
       ├───────────┼──────────────────────────────┤
       │ count     │ the number of points,  draw‐ │
       │           │ ing count-1 lines            │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                                    │
       │                                                                                     │
       │ #define POINTS_COUNT 4                                                              │
       │                                                                                     │
       │ static SDL_Point points[POINTS_COUNT] = {                                           │
       │     {320, 200},                                                                     │
       │     {300, 240},                                                                     │
       │     {340, 240},                                                                     │
       │     {320, 200}                                                                      │
       │ };                                                                                  │
       │                                                                                     │
       │ int main(int argc, char* argv[])                                                    │
       │ {                                                                                   │
       │     if (SDL_Init(SDL_INIT_VIDEO) == 0) {                                            │
       │         SDL_Window* window = NULL;                                                  │
       │         SDL_Renderer* renderer = NULL;                                              │
       │                                                                                     │
       │         if (SDL_CreateWindowAndRenderer(640, 480, 0, &window, &renderer) == 0) {    │
       │             SDL_bool done = SDL_FALSE;                                              │
       │                                                                                     │
       │             while (!done) {                                                         │
       │                 SDL_Event event;                                                    │
       │                                                                                     │
       │                 SDL_SetRenderDrawColor(renderer, 0, 0, 0, SDL_ALPHA_OPAQUE);        │
       │                 SDL_RenderClear(renderer);                                          │
       │                                                                                     │
       │                 SDL_SetRenderDrawColor(renderer, 255, 255, 255, SDL_ALPHA_OPAQUE);  │
       │                 SDL_RenderDrawLines(renderer, points, POINTS_COUNT);                │
       │                 SDL_RenderPresent(renderer);                                        │
       │                                                                                     │
       │                 while (SDL_PollEvent(&event)) {                                     │
       │                     if (event.type == SDL_QUIT) {                                   │
       │                         done = SDL_TRUE;                                            │
       │                     }                                                               │
       │                 }                                                                   │
       │             }                                                                       │
       │         }                                                                           │
       │                                                                                     │
       │         if (renderer) {                                                             │
       │             SDL_DestroyRenderer(renderer);                                          │
       │         }                                                                           │
       │         if (window) {                                                               │
       │             SDL_DestroyWindow(window);                                              │
       │         }                                                                           │
       │     }                                                                               │
       │     SDL_Quit();                                                                     │
       │     return 0;                                                                       │
       │ }                                                                                   │
       │                                                                                     │
       └─────────────────────────────────────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_RenderDrawLine
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderFillRect
       SDL_RenderFillRects
       SDL_RenderPresent
       SDL_SetRenderDrawBlendMode
       SDL_SetRenderDrawColor

===============================================================================
                                                          *SDL_RenderDrawPoint*


NAME
       SDL_RenderDrawPoint -- Function

SYNOPSIS
       Use this function to draw a point on the current rendering target.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_RenderDrawPoint(SDL_Renderer*     renderer,  │
       │                         int               x,         │
       │                         int               y)         │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ x         │ the   x  coordinate  of  the │
       │           │ point                        │
       ├───────────┼──────────────────────────────┤
       │ y         │ the  y  coordinate  of   the │
       │           │ point                        │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,  use
       SDL_RenderDrawPoints() instead.

RELATED FUNCTIONS
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderFillRect
       SDL_RenderFillRects
       SDL_RenderPresent
       SDL_SetRenderDrawBlendMode
       SDL_SetRenderDrawColor

===============================================================================
                                                         *SDL_RenderDrawPoints*


NAME
       SDL_RenderDrawPoints -- Function

SYNOPSIS
       Use this function to draw multiple points on the current rendering target.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_RenderDrawPoints(SDL_Renderer*      renderer,  │
       │                          const SDL_Point*   points,    │
       │                          int                count)     │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ points    │ an array of SDL_Point struc‐ │
       │           │ tures  that  represent   the │
       │           │ points to draw               │
       ├───────────┼──────────────────────────────┤
       │ count     │ the number of points to draw │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderFillRect
       SDL_RenderFillRects
       SDL_RenderPresent
       SDL_SetRenderDrawBlendMode
       SDL_SetRenderDrawColor

===============================================================================
                                                           *SDL_RenderDrawRect*


NAME
       SDL_RenderDrawRect -- Function

SYNOPSIS
       Use this function to draw a rectangle on the current rendering target.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_RenderDrawRect(SDL_Renderer*      renderer,  │
       │                        const SDL_Rect*    rect)      │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ rect      │ an SDL_Rect structure repre‐ │
       │           │ senting  the  rectangle   to │
       │           │ draw, or NULL to outline the │
       │           │ entire rendering target      │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRects
       SDL_RenderFillRect
       SDL_RenderFillRects
       SDL_RenderPresent
       SDL_SetRenderDrawBlendMode
       SDL_SetRenderDrawColor

===============================================================================
                                                          *SDL_RenderDrawRects*


NAME
       SDL_RenderDrawRects -- Function

SYNOPSIS
       Use  this  function to draw some number of rectangles on the current rendering
       target.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_RenderDrawRects(SDL_Renderer*     renderer,  │
       │                         const SDL_Rect*   rects,     │
       │                         int               count)     │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ rects     │ an array of SDL_Rect  struc‐ │
       │           │ tures  representing the rec‐ │
       │           │ tangles to be drawn          │
       ├───────────┼──────────────────────────────┤
       │ count     │ the number of rectangles     │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderFillRect
       SDL_RenderFillRects
       SDL_RenderPresent
       SDL_SetRenderDrawBlendMode
       SDL_SetRenderDrawColor

===============================================================================
                                                           *SDL_RenderFillRect*


NAME
       SDL_RenderFillRect -- Function

SYNOPSIS
       Use this function to fill a rectangle on the current rendering target with the
       drawing color.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_RenderFillRect(SDL_Renderer*      renderer,  │
       │                        const SDL_Rect*    rect)      │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ rect      │ the SDL_Rect structure  rep‐ │
       │           │ resenting  the  rectangle to │
       │           │ fill, or NULL for the entire │
       │           │ rendering target             │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       The current drawing color is set by SDL_SetRenderDrawColor(), and the  color's
       alpha  value  is  ignored  unless blending is enabled with appropriate call to
       SDL_SetRenderDrawBlendMode().

RELATED FUNCTIONS
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderFillRects
       SDL_RenderPresent
       SDL_SetRenderDrawBlendMode
       SDL_SetRenderDrawColor

===============================================================================
                                                          *SDL_RenderFillRects*


NAME
       SDL_RenderFillRects -- Function

SYNOPSIS
       Use  this  function to fill some number of rectangles on the current rendering
       target with the drawing color.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_RenderFillRects(SDL_Renderer*     renderer,  │
       │                         const SDL_Rect*   rects,     │
       │                         int               count)     │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ rects     │ an array of SDL_Rect  struc‐ │
       │           │ tures  representing the rec‐ │
       │           │ tangles to be filled         │
       ├───────────┼──────────────────────────────┤
       │ count     │ the number of rectangles     │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderFillRect
       SDL_RenderPresent

===============================================================================
                                                        *SDL_RenderGetClipRect*


NAME
       SDL_RenderGetClipRect -- Function

SYNOPSIS
       Use this function to get the clip rectangle for the current target.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ void SDL_RenderGetClipRect(SDL_Renderer*    renderer,  │
       │                            SDL_Rect*        rect)      │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the  rendering  context from │
       │           │ which clip rectangle  should │
       │           │ be queried                   │
       ├───────────┼──────────────────────────────┤
       │ rect      │ an SDL_Rect structure filled │
       │           │ in with the current clipping │
       │           │ area  or  an empty rectangle │
       │           │ if clipping is disabled      │
       └───────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_RenderIsClipEnabled
       SDL_RenderSetClipRect

===============================================================================
                                                      *SDL_RenderGetD3D9Device*


NAME
       SDL_RenderGetD3D9Device -- Function

SYNOPSIS
       Use this function to get the D3D device associated with a renderer.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────┐
       │ IDirect3DDevice9* SDL_RenderGetD3D9Device(SDL_Renderer*   renderer)  │
       └──────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the  renderer  from which to │
       │           │ get the associated  D3D  de‐ │
       │           │ vice                         │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  the  D3D device associated with given renderer or NULL if it is not a
       D3D renderer; call SDL_GetError() for more information.

REMARKS
       Once you are done using the device, you should release it to avoid a  resource
       leak.

VERSION
       This function is available since SDL 2.0.1.

===============================================================================
                                                    *SDL_RenderGetIntegerScale*


NAME
       SDL_RenderGetIntegerScale -- Function

SYNOPSIS
       Use  this function to set whether to force integer scales for resolution-inde‐
       pendent rendering.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ int SDL_RenderGetIntegerScale(SDL_Renderer*   renderer,  │
       │                               SDL_bool        enable)    │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the renderer for which inte‐ │
       │           │ ger scaling should be set    │
       ├───────────┼──────────────────────────────┤
       │ enable    │ enable  or disable the inte‐ │
       │           │ ger scaling for rendering    │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       This function restricts the logical viewport to integer values - that is, when
       a resolution is between two multiples of a logical size, the viewport size  is
       rounded down to the lower multiple.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_RenderGetIntegerScale
       SDL_RenderSetLogicalSize

===============================================================================
                                                     *SDL_RenderGetLogicalSize*


NAME
       SDL_RenderGetLogicalSize -- Function

SYNOPSIS
       Use this function to get device independent resolution for rendering.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ void SDL_RenderGetLogicalSize(SDL_Renderer*   renderer,  │
       │                               int*            w,         │
       │                               int*            h)         │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ a rendering context          │
       ├───────────┼──────────────────────────────┤
       │ w         │ an int to be filled with the │
       │           │ width                        │
       ├───────────┼──────────────────────────────┤
       │ h         │ an int to be filled with the │
       │           │ height                       │
       └───────────┴──────────────────────────────┘

REMARKS
       If  this  function is called on an SDL_Renderer who never had its logical size
       set by SDL_RenderSetLogicalSize(), this function sets both w and h to 0.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_RenderSetLogicalSize

===============================================================================
                                                           *SDL_RenderSetScale*


NAME
       SDL_RenderSetScale -- Function

SYNOPSIS
       Use  this  function to set the drawing scale for rendering on the current tar‐
       get.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_RenderSetScale(SDL_Renderer*    renderer,  │
       │                        float            scaleX,    │
       │                        float            scaleY)    │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ a rendering context          │
       ├───────────┼──────────────────────────────┤
       │ scaleX    │ the horizontal scaling  fac‐ │
       │           │ tor                          │
       ├───────────┼──────────────────────────────┤
       │ scaleY    │ the vertical scaling factor  │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       The drawing coordinates are scaled by the x/y scaling factors before they  are
       used by the renderer. This allows resolution independent drawing with a single
       coordinate system.

       If this results in scaling or subpixel drawing by the  rendering  backend,  it
       will  be handled using the appropriate quality hints. For best results use in‐
       teger scaling factors.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_RenderGetScale
       SDL_RenderSetLogicalSize

===============================================================================
                                                        *SDL_RenderSetViewport*


NAME
       SDL_RenderSetViewport -- Function

SYNOPSIS
       Use this function to set the drawing area for rendering on the current target.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_RenderSetViewport(SDL_Renderer*     renderer,  │
       │                           const SDL_Rect*   rect)      │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ rect      │ the  SDL_Rect structure rep‐ │
       │           │ resenting the drawing  area, │
       │           │ or  NULL to set the viewport │
       │           │ to the entire target         │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       When  the  window  is  resized, the current viewport is automatically centered
       within the new window size.

RELATED FUNCTIONS
       SDL_RenderGetViewport

===============================================================================
                                                    *SDL_RenderTargetSupported*


NAME
       SDL_RenderTargetSupported -- Function

SYNOPSIS
       Use  this  function  to  determine whether a window supports the use of render
       targets.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_RenderTargetSupported(SDL_Renderer*    renderer)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the renderer  that  will  be │
       │           │ checked                      │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if supported or SDL_FALSE if not.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_SetRenderTarget

===============================================================================
                                                                 *SDL_Renderer*


NAME
       SDL_Renderer -- Structure

SYNOPSIS
       A structure that contains a rendering state.

RELATED FUNCTIONS
       SDL_CreateRenderer
       SDL_CreateSoftwareRenderer
       SDL_CreateTexture
       SDL_CreateTextureFromSurface
       SDL_CreateWindowAndRenderer
       SDL_DestroyRenderer
       SDL_GetRenderDrawBlendMode
       SDL_GetRenderDrawColor
       SDL_GetRendererInfo
       SDL_GetRendererOutputSize
       SDL_GetRenderTarget
       SDL_RenderClear
       SDL_RenderCopy
       SDL_RenderCopyEx
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderFillRect
       SDL_RenderFillRects
       SDL_RenderGetClipRect
       SDL_RenderGetIntegerScale
       SDL_RenderGetLogicalSize
       SDL_RenderGetScale
       SDL_RenderGetViewport
       SDL_RenderIsClipEnabled
       SDL_RenderPresent
       SDL_RenderReadPixels
       SDL_RenderSetClipRect
       SDL_RenderSetIntegerScale
       SDL_RenderSetLogicalSize
       SDL_RenderSetScale
       SDL_RenderSetViewport
       SDL_RenderTargetSupported
       SDL_SetRenderDrawBlendMode
       SDL_SetRenderDrawColor
       SDL_SetRenderTarget

===============================================================================
                                                            *SDL_RendererFlags*


NAME
       SDL_RendererFlags -- Enumerations

SYNOPSIS
       An enumeration of flags used when creating a rendering context.

DESCRIPTION
       Values

       ┌─────────────────────────────┬──────────────────────────────┐
       │ SDL_RENDERER_SOFTWARE       │ the  renderer  is a software │
       │                             │ fallback                     │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_RENDERER_ACCELERATED    │ the renderer  uses  hardware │
       │                             │ acceleration                 │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_RENDERER_PRESENTVSYNC   │ present is synchronized with │
       │                             │ the refresh rate             │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_RENDERER_TARGETTEXTURE  │ the renderer  supports  ren‐ │
       │                             │ dering to texture            │
       └─────────────────────────────┴──────────────────────────────┘

       Note that providing no flags gives priority to available SDL_RENDERER_ACCELER‐
       ATED renderers.

RELATED STRUCTURES
       SDL_RendererInfo

RELATED FUNCTIONS
       SDL_CreateRenderer

===============================================================================
                                                             *SDL_RendererFlip*


NAME
       SDL_RendererFlip -- Enumerations

SYNOPSIS
       An enumeration of flags that can be used in the flip parameter for SDL_Render‐
       CopyEx.

DESCRIPTION
       Values

       ┌──────────────────────┬───────────────────┐
       │ SDL_FLIP_NONE        │ do not flip       │
       ├──────────────────────┼───────────────────┤
       │ SDL_FLIP_HORIZONTAL  │ flip horizontally │
       ├──────────────────────┼───────────────────┤
       │ SDL_FLIP_VERTICAL    │ flip vertically   │
       └──────────────────────┴───────────────────┘

CODE EXAMPLES
       /* cast may be necessary f or some compiler settings or languages (e.g. C++) */
       SDL_RendererFlip flip = SDL_FLIP_HORIZONTAL | SDL_FLIP_VERTICAL;
       SDL_RenderCopyEx(renderer, texture, &srcrect, &dstrect, angle, &center, flip);

REMARKS
       If you want to do a diagonal flip (both horizontal and vertical), use  bitwise
       or ('|' operator).

RELATED FUNCTIONS
       SDL_RenderCopyEx

===============================================================================
                                                             *SDL_RendererInfo*


NAME
       SDL_RendererInfo -- Structure

SYNOPSIS
       A  structure  that contains information on the capabilities of a render driver
       or the current render context.

DATA FIELDS
       ┌──────────────┬─────────────────────┬───────────────────────┐
       │ cosnt char*  │ name                │ the name of the  ren‐ │
       │              │                     │ derer                 │
       ├──────────────┼─────────────────────┼───────────────────────┤
       │ Uint32       │ flags               │ a  mask  of supported │
       │              │                     │ renderer  flags;  see │
       │              │                     │ Remarks for details   │
       ├──────────────┼─────────────────────┼───────────────────────┤
       │ Uint32       │ num_texture_formats │ the  number of avail‐ │
       │              │                     │ able texture formats  │
       ├──────────────┼─────────────────────┼───────────────────────┤
       │ Uint32[16]   │ texture_formats     │ the available texture │
       │              │                     │ formats;  see Remarks │
       │              │                     │ for details           │
       ├──────────────┼─────────────────────┼───────────────────────┤
       │ int          │ max_texture_width   │ the  maximum  texture │
       │              │                     │ width                 │
       ├──────────────┼─────────────────────┼───────────────────────┤
       │ int          │ max_texture_height  │ the  maximum  texture │
       │              │                     │ height                │
       └──────────────┴─────────────────────┴───────────────────────┘

REMARKS
       flags may be 0 or a mask of any of the following SDL_RendererFlags values OR'd
       together:

       ┌─────────────────────────────┬──────────────────────────────┐
       │ SDL_RENDERER_SOFTWARE       │ the  renderer  is a software │
       │                             │ fallback                     │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_RENDERER_ACCELERATED    │ the renderer  uses  hardware │
       │                             │ acceleration                 │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_RENDERER_PRESENTVSYNC   │ present is synchronized with │
       │                             │ the refresh rate             │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_RENDERER_TARGETTEXTURE  │ the renderer  supports  ren‐ │
       │                             │ dering to texture            │
       └─────────────────────────────┴──────────────────────────────┘

       Note that providing no flags gives priority to available SDL_RENDERER_ACCELER‐
       ATED renderers.

       texture_formats is an array of  SDL_PixelFormatEnum  values  representing  the
       available texture formats for the renderer.

   Pixel Format Macros
       ┌────────────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELTYPE(format)              │ the  type  of the pixel for‐ │
       │                                    │ mat; see Remarks for details │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELORDER(format)             │ the ordering of channels  or │
       │                                    │ bits  in  the  pixel format; │
       │                                    │ see Remarks for details      │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELLAYOUT(format)            │ the channel bit  pattern  of │
       │                                    │ the  pixel  format;  see Re‐ │
       │                                    │ marks for details            │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_BITSPERPIXEL(format)           │ the number of bits of  color │
       │                                    │ information   in  the  pixel │
       │                                    │ format                       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_BYTESPERPIXEL(format)          │ the number of bytes used  to │
       │                                    │ represent a pixel            │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_ISPIXELFORMAT_INDEXES(format)  │ true  for pixel formats that │
       │                                    │ have a palette               │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_ISPIXELFORAMT_ALPHA(format)    │ true for pixel formats  that │
       │                                    │ have an alpha channel        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_ISPIXELFORMAT_FOURCC(format)   │ true   for   pixel   formats │
       │                                    │ represnting unique  formats, │
       │                                    │ for example YUV formats      │
       └────────────────────────────────────┴──────────────────────────────┘

   Pixel Format Values
       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_PIXELFORMAT_UNKNOWN      │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX1MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4LSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX4MSB    │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_INDEX8       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB332       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB444       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR555       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA4444     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR1555     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA5551     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR565       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR24        │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGB888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGR888       │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRX8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA8888     │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB2101010  │                              │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_RGBA32       │ alias for RGBA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ARGB32       │ alias for ARGB byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_BGRA32       │ alias for BGRA byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_ABGR32       │ alias for ABGR byte array of │
       │                              │ color data, for the  current │
       │                              │ platform (>= SDL 2.0.5)      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YV12         │ planar  mode:  Y  + V + U (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_IYUV         │ planar mode: Y + U  +  V  (3 │
       │                              │ planes)                      │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YUY2         │ packed  mode: Y0+U0+Y1+V0 (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_UYVY         │ packed mode: U0+Y0+V0+Y1  (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_YVYU         │ packed  mode: Y0+V0+Y1+U0 (1 │
       │                              │ plane)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV12         │ planar mode: Y + U/V  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_PIXELFORMAT_NV21         │ planar mode: Y + V/U  inter‐ │
       │                              │ leaved  (2  planes)  (>= SDL │
       │                              │ 2.0.4)                       │
       └──────────────────────────────┴──────────────────────────────┘

RELATED ENUMERATIONS
       SDL_BlendMode
       SDL_PixelFormatEnum
       SDL_RendererFlags
       SDL_TextureModulate

RELATED FUNCTIONS
       SDL_GetRenderDriverInfo
       SDL_GetRendererInfo
       SDL_RenderCopy

===============================================================================
                                                     *SDL_ResetAssertionReport*


NAME
       SDL_ResetAssertionReport -- Function

SYNOPSIS
       Use this function to clear the list of all assertion failures.

SYNTAX
       ┌──────────────────────────────────────┐
       │ void SDL_ResetAssertionReport(void)  │
       └──────────────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────┐
       │ SDL_assert(1+1 == 3);   // trigger an assertion.          │
       │ printf("%p\n", SDL_GetAssertionReport());   // not NULL.  │
       │ SDL_ResetAssertionReport();                               │
       │ printf("%p\n", SDL_GetAssertionReport());   // NULL       │
       └───────────────────────────────────────────────────────────┘

REMARKS
       This  function  will  clear  the  list  of all assertions triggered up to that
       point. Immediately following this call, SDL_GetAssertionReport()  will  return
       no  items. In addition, any previously-triggered assertions will be reset to a
       trigger_count of zero, and their always_ignore state will be false.

RELATED FUNCTIONS
       SDL_GetAssertionReport

===============================================================================
                                                              *SDL_ResizeEvent*


NAME
       SDL_ResizeEvent - Window resize event structure

STRUCTURE DEFINITION
       typedef struct{
         Uint8 type;
         int w, h;
       } SDL_ResizeEvent;

STRUCTURE DATA
       type                SDL_VIDEORESIZE

       w, h                New width and height of the window

DESCRIPTION
       SDL_ResizeEvent  is  a member of the SDL_Event union and is used when an event
       of type SDL_VIDEORESIZE is reported.

       When SDL_RESIZABLE is passed as a flag to SDL_SetVideoMode the user is allowed
       to  resize the applications window. When the window is resized an SDL_VIDEORE‐
       SIZE is report, with the new window width and height values stored in w and h,
       respectively. When an SDL_VIDEORESIZE is received the window should be resized
       to the new dimensions using SDL_SetVideoMode.

SEE ALSO
       SDL_Event, SDL_SetVideoMode

===============================================================================
                                                            *SDL_RestoreWindow*


NAME
       SDL_RestoreWindow -- Function

SYNOPSIS
       Use this function to restore the size and position of a minimized or maximized
       window.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_RestoreWindow(SDL_Window*    window)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬───────────────────────┐
       │ window  │ the window to restore │
       └─────────┴───────────────────────┘

RELATED FUNCTIONS
       SDL_MaximizeWindow
       SDL_MinimizeWindow

===============================================================================
                                                               *SDL_SYSWM_TYPE*


NAME
       SDL_SYSWM_TYPE -- Enumerations

SYNOPSIS
       An enumeration of the various supported windowing subsystems.

DESCRIPTION
       Values

       ┌─────────────────────┬──────────────────────────────┐
       │ SDL_SYSTEM_UNKNOWN  │                              │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSTEM_WINDOWS  │ Microsoft Windows            │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_X11       │ X Window System              │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_DIRECTFB  │ DirectFB                (see │
       │                     │ https://github.com/Di‐       │
       │                     │ rectFB/directfb)             │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_COCOA     │ Apple Mac OS X               │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_UIKIT     │ Apple iOS                    │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_WAYLAND   │ Wayland (>= SDL 2.0.2)       │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_MIR       │ Mir (>= SDL 2.0.2)           │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_WINRT     │ WinRT (>= SDL 2.0.3)         │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_ANDROID   │ Android (>= SDL 2.0.4)       │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_VIVANTE   │ Vivante (>= SDL 2.0.5)       │
       └─────────────────────┴──────────────────────────────┘

RELATED STRUCTURES
       SDL_SysWMInfo
       SDL_SysWMmsg

RELATED FUNCTIONS
       SDL_GetWindowWMInfo

===============================================================================
                                                   *SDL_SaveAllDollarTemplates*


NAME
       SDL_SaveAllDollarTemplates -- Function

SYNOPSIS
       Use this function to save all currently loaded Dollar Gesture templates.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ int SDL_SaveAllDollarTemplates(SDL_RWops*   dst)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬────────────────────────┐
       │ dst  │ a SDL_RWops to save to │
       └──────┴────────────────────────┘

RETURN VALUE
       Returns  the  number  of  saved  templates  on  success  or 0 on failure; call
       SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_LoadDollarTemplates.
       SDL_SaveDollarTemplate.

===============================================================================
                                                                  *SDL_SaveBMP*


NAME
       SDL_SaveBMP -- Function

SYNOPSIS
       Use this function to save a surface to a BMP file.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ int SDL_SaveBMP(SDL_Surface*    surface,  │
       │                 const char*     file)     │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the   SDL_Surface  structure │
       │          │ containing the image  to  be │
       │          │ saved                        │
       ├──────────┼──────────────────────────────┤
       │ file     │ the file to be saved to      │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the  BMP
       directly.  Other  RGB  formats  with 8-bit or higher get converted to a 24-bit
       surface or, if they have an alpha mask or a colorkey, to a 32-bit surface  be‐
       fore  they  are  saved.  YUV and paletted 1-bit and 4-bit formats are not sup‐
       ported.

RELATED FUNCTIONS
       SDL_LoadBMP
       SDL_SaveBMP_RW

===============================================================================
                                                               *SDL_SaveBMP_RW*


NAME
       SDL_SaveBMP_RW -- Function

SYNOPSIS
       Use  this  function to save a surface to a seekable SDL data stream (memory or
       file) in BMP format.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ int SDL_SaveBMP_RW(SDL_Surface*   surface,  │
       │                    SDL_RWops*     dst,      │
       │                    int            freedst)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the  SDL_Surface   structure │
       │          │ containing  the  image to be │
       │          │ saved                        │
       ├──────────┼──────────────────────────────┤
       │ dst      │ a data stream to save to     │
       ├──────────┼──────────────────────────────┤
       │ freedst  │ non-zero to close the stream │
       │          │ after being written          │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the  BMP
       directly.  Other  RGB  formats  with 8-bit or higher get converted to a 24-bit
       surface or, if they have an alpha mask or a colorkey, to a 32-bit surface  be‐
       fore  they  are  saved.  YUV and paletted 1-bit and 4-bit formats are not sup‐
       ported.

RELATED FUNCTIONS
       SDL_LoadBMP_RW
       SDL_SaveBMP

===============================================================================
                                                       *SDL_SaveDollarTemplate*


NAME
       SDL_SaveDollarTemplate -- Function

SYNOPSIS
       Use this function to save a currently loaded Dollar Gesture template.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ int SDL_SaveDollarTemplate(SDL_GestureID    gestureId,  │
       │                            SDL_RWops*       dst)        │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬────────────────────────┐
       │ gestureId  │ a gesture id           │
       ├────────────┼────────────────────────┤
       │ dst        │ a SDL_RWops to save to │
       └────────────┴────────────────────────┘

RETURN VALUE
       Returns  1  on  success or 0 on failure; call SDL_GetError() for more informa‐
       tion.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_LoadDollarTemplates
       SDL_SaveAllDollarTemplates

===============================================================================
                                                                  *SDL_SemPost*


NAME
       SDL_SemPost -- Function

SYNOPSIS
       Use this function to atomatically increment a semaphore's value and wake wait‐
       ing threads.

SYNTAX
       ┌───────────────────────────────────┐
       │ int SDL_SemPost(SDL_sem*    sem)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬────────────────────────────┐
       │ sem  │ the semaphore to increment │
       └──────┴────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       Typical use of semaphores:

       ┌──────────────────────────────────────┐
       │ SDL_atomic_t done;                   │
       │ SDL_sem *sem;                        │
       │                                      │
       │ SDL_AtomicSet(&done, 0);             │
       │ sem = SDL_CreateSemaphore(0);        │
       │ Thread A:                            │
       │     while (!SDL_AtomicGet(&done)) {  │
       │         add_data_to_queue();         │
       │         SDL_SemPost(sem);            │
       │     }                                │
       │                                      │
       │ Thread B:                            │
       │     while (!SDL_AtomicGet(&done)) {  │
       │         SDL_SemWait(sem);            │
       │         if (data_available()) {      │
       │             get_data_from_queue();   │
       │         }                            │
       │     }                                │
       │ SDL_AtomicSet(&done, 1);             │
       │ SDL_SemPost(sem);                    │
       │ wait_for_threads();                  │
       │ SDL_DestroySemaphore(sem);           │
       └──────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_CreateSemaphore
       SDL_DestroySemaphore
       SDL_SemTryWait
       LSD_SemValue
       SDL_SemWait
       SDL_SemWaitTimeout

===============================================================================
                                                               *SDL_SemTryWait*


NAME
       SDL_SemTryWait -- Function

SYNOPSIS
       Use  this function to see if a semaphore has a positive value and decrement it
       if it does.

SYNTAX
       ┌─────────────────────────────────────┐
       │ int SDL_SemTryWait(SDL_sem*   sem)  │
       └─────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────┐
       │ sem  │ the semaphore to wait on │
       └──────┴──────────────────────────┘

RETURN VALUE
       Returns 0 on the wait succeeds, SDL_MUTEX_TIMEOUT if the wait would block,  or
       a negative error code on failure; call SDL_GetError() for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────┐
       │ SDL_atomic_t done;                                           │
       │ SDL_sem *sem;                                                │
       │                                                              │
       │ SDL_AtomicSet(&done, 0);                                     │
       │ sem = SDL_CreateSemaphore(0);                                │
       │ Thread A:                                                    │
       │     while (!SDL_AtomicGet(&done)) {                          │
       │         add_data_to_queue();                                 │
       │         SDL_SemPost(sem);                                    │
       │     }                                                        │
       │                                                              │
       │ Thread B:                                                    │
       │     while (!SDL_AtomicGet(&done)) {                          │
       │         if (SDL_SemTryWait(sem) == 0 && data_available()) {  │
       │             get_data_from_queue();                           │
       │         }                                                    │
       │         ... do other processing                              │
       │     }                                                        │
       │ SDL_AtomicSet(&done, 1);                                     │
       │ SDL_SemPost(sem);                                            │
       │ wait_for_threads();                                          │
       │ SDL_DestroySemaphore(sem);                                   │
       └──────────────────────────────────────────────────────────────┘

REMARKS
       This  function checks to see if the semaphore pointed to by sem has a positive
       value and atomically decrements the semaphore value if it does. If  the  sema‐
       phore  doesn't have a positive value, the function immediately returns SDL_MU‐
       TEX_TIMEDOUT.

RELATED FUNCTIONS
       SDL_CreateSemaphore
       SDL_DestroySemaphore
       SDL_SemPost
       SDL_SemValue
       SDL_SemWait
       SDL_SemWaitTimeout

===============================================================================
                                                                 *SDL_SemValue*


NAME
       SDL_SemValue -- Function

SYNOPSIS
       Use this function to get the current value of a semaphore.

SYNTAX
       ┌───────────────────────────────────┐
       │ sem SDL_SemValue(SDL_sem*   sem)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬────────────────────────┐
       │ sem  │ the semaphore to query │
       └──────┴────────────────────────┘

RETURN VALUE
       Returns the current value of the semaphore.

RELATED FUNCTIONS
       SDL_CreateSemaphore

===============================================================================
                                                                  *SDL_SemWait*


NAME
       SDL_SemWait -- Function

SYNOPSIS
       Use  this  function  to  wait  until a semaphore has a positive value and then
       decrements it.

SYNTAX
       ┌───────────────────────────────────┐
       │ int SDL_SemWait(SDL_sem*    sem)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬───────────────────────┐
       │ sem  │ the semaphore wait on │
       └──────┴───────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌──────────────────────────────────────┐
       │ SDL_atomic_t done;                   │
       │ SDL_sem *sem;                        │
       │                                      │
       │ SDL_AtomicSet(&done, 0);             │
       │ sem = SDL_CreateSemaphore(0);        │
       │ Thread A:                            │
       │     while (!SDL_AtomicGet(&done)) {  │
       │         add_data_to_queue();         │
       │         SDL_SemPost(sem);            │
       │     }                                │
       │                                      │
       │ Thread B:                            │
       │     while (!SDL_AtomicGet(&done)) {  │
       │         SDL_SemWait(sem);            │
       │         if (data_available()) {      │
       │             get_data_from_queue();   │
       │         }                            │
       │     }                                │
       │ SDL_AtomicSet(&done, 1);             │
       │ SDL_SemPost(sem);                    │
       │ wait_for_threads();                  │
       │ SDL_DestroySemaphore(sem);           │
       └──────────────────────────────────────┘

REMARKS
       This  function  suspends the calling thread until either the semaphore pointed
       to by sem has a positive value or the call is interrupted by a signal  or  er‐
       ror.  If  the  call  is successful, it will atomically decrement the semaphore
       value.

       This function is the equivalent of calling SDL_SemWaitTimeout()  with  a  time
       length of SDL_MUTEX_MAXWAIT.

RELATED FUNCTIONS
       SDL_CreateSemaphore
       SDL_DestroySemaphore
       SDL_SemPost
       SDL_SemTryWait
       SDL_SemValue
       SDL_SemWait
       SDL_SemWaitTimeout

===============================================================================
                                                           *SDL_SemWaitTimeout*


NAME
       SDL_SemWaitTimeout -- Function

SYNOPSIS
       Use  this  function  to  wait  until a semaphore has a positive value and then
       decrement it.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ int SDL_SemWaitTimeout(SDL_sem*   sem,  │
       │                        Uint32     ms)   │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ sem  │ the semaphore to wait on     │
       ├──────┼──────────────────────────────┤
       │ ms   │ the length of the timeout in │
       │      │ milliseconds                 │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns  0  if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not suc‐
       ceed in the alloted time, or a negative error code on failure; call SDL_GetEr‐
       ror() for more information.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────────────────┐
       │ SDL_atomic_t done;                                                        │
       │ SDL_sem *sem;                                                             │
       │                                                                           │
       │ SDL_AtomicSet(&done, 0);                                                  │
       │ sem = SDL_CreateSemaphore(0);                                             │
       │ Thread A:                                                                 │
       │     while (!SDL_AtomicGet(&done)) {                                       │
       │         add_data_to_queue();                                              │
       │         SDL_SemPost(sem);                                                 │
       │     }                                                                     │
       │                                                                           │
       │ Thread B:                                                                 │
       │     const Uint32 timeout = 1000; /* wake up every second */               │
       │                                                                           │
       │     while (!SDL_AtomicGet(&done)) {                                       │
       │         if (SDL_SemWaitTimeout(sem, timeout) == 0 && data_available()) {  │
       │             get_data_from_queue();                                        │
       │         }                                                                 │
       │         ... do other processing                                           │
       │     }                                                                     │
       │ SDL_AtomicSet(&done, 1);                                                  │
       │ SDL_SemPost(sem);                                                         │
       │ wait_for_threads();                                                       │
       │ SDL_DestroySemaphore(sem);                                                │
       └───────────────────────────────────────────────────────────────────────────┘

REMARKS
       This  function  suspends the calling thread until either the semaphore pointed
       to by sem has a positive value, the call is interrupted by a signal or  error,
       or the specified time has elapsed. If the call is successful, it will automat‐
       ically decrement the semaphore value.

RELATED FUNCTIONS
       SDL_CreateSemaphore
       SDL_DestroySemaphore
       SDL_SemPost
       SDL_SemTryWait
       SDL_SemValue
       SDL_SemWait

===============================================================================
                                                                 *SDL_SetAlpha*


NAME
       SDL_SetAlpha - Adjust the alpha properties of a surface

SYNOPSIS
       #include "SDL.h"

       int SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);

DESCRIPTION
              Note:

              This  function  and  the  semantics  of SDL alpha blending have changed
              since version 1.1.4. Up until version 1.1.5, an alpha value  of  0  was
              considered  opaque  and a value of 255 was considered transparent. This
              has now been inverted:  0  (SDL_ALPHA_TRANSPARENT)  is  now  considered
              transparent and 255 (SDL_ALPHA_OPAQUE) is now considered opaque.

       SDL_SetAlpha  is  used for setting the per-surface alpha value and/or enabling
       and disabling alpha blending.

       Thesurface parameter specifies which surface whose alpha attributes  you  wish
       to  adjust.  flags  is  used  to specify whether alpha blending should be used
       (SDL_SRCALPHA) and whether the surface should use RLE acceleration  for  blit‐
       ting  (SDL_RLEACCEL).  flags  can be an OR'd combination of these two options,
       one of these options or 0. If SDL_SRCALPHA is not passed as a  flag  then  all
       alpha information is ignored when blitting the surface. The alpha parameter is
       the per-surface alpha value; a surface need not have an alpha channel  to  use
       per-surface alpha and blitting can still be accelerated with SDL_RLEACCEL.

              Note:

              The  per-surface alpha value of 128 is considered a special case and is
              optimised, so it's much faster than other per-surface values.

       Alpha effects surface blitting in the following ways:

       RGBA->RGB with SDL_SRCALPHA
                           The source is alpha-blended with  the  destination,  using
                           the alpha channel. SDL_SRCCOLORKEY and the per-surface al‐
                           pha are ignored.

       RGBA->RGB without SDL_SRCALPHA
                           The RGB data is copied from the source. The  source  alpha
                           channel and the per-surface alpha value are ignored.

       RGB->RGBA with SDL_SRCALPHA
                           The source is alpha-blended with the destination using the
                           per-surface alpha value. If SDL_SRCCOLORKEY is  set,  only
                           the pixels not matching the colorkey value are copied. The
                           alpha channel of the copied pixels is set to opaque.

       RGB->RGBA without SDL_SRCALPHA
                           The RGB data is copied from the source and the alpha value
                           of  the copied pixels is set to opaque. If SDL_SRCCOLORKEY
                           is set, only the pixels not matching  the  colorkey  value
                           are copied.

       RGBA->RGBA with SDL_SRCALPHA
                           The source is alpha-blended with the destination using the
                           source alpha channel. The alpha channel in the destination
                           surface is left untouched. SDL_SRCCOLORKEY is ignored.

       RGBA->RGBA without SDL_SRCALPHA
                           The  RGBA  data  is  copied to the destination surface. If
                           SDL_SRCCOLORKEY is set, only the pixels not  matching  the
                           colorkey value are copied.

       RGB->RGB with SDL_SRCALPHA
                           The source is alpha-blended with the destination using the
                           per-surface alpha value. If SDL_SRCCOLORKEY is  set,  only
                           the pixels not matching the colorkey value are copied.

       RGB->RGB without SDL_SRCALPHA
                           The RGB data is copied from the source. If SDL_SRCCOLORKEY
                           is set, only the pixels not matching  the  colorkey  value
                           are copied.

              Note:

               Note  that  RGBA->RGBA blits (with SDL_SRCALPHA set) keep the alpha of
              the destination surface. This means that you cannot compose  two  arbi‐
              trary  RGBA  surfaces this way and get the result you would expect from
              "overlaying" them; the destination alpha will work as a mask.

              Also note that per-pixel and per-surface alpha cannot be combined;  the
              per-pixel alpha is always used if available

RETURN VALUE
       This function returns 0, or -1 if there was an error.

SEE ALSO
       SDL_MapRGBA, SDL_GetRGBA, SDL_DisplayFormatAlpha, SDL_BlitSurface

===============================================================================
                                                      *SDL_SetAssertionHandler*


NAME
       SDL_SetAssertionHandler -- Function

SYNOPSIS
       Use this function to set an application-defined assertion handler.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ void SDL_SetAssertionHandler(SDL_AssertionHandler   handler,   │
       │                              void*                  userdata)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ handler   │ the function to call when an │
       │           │ assertion fails or NULL  for │
       │           │ the default handler; see Re‐ │
       │           │ marks for details            │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ a pointer that is passed  to │
       │           │ handler                      │
       └───────────┴──────────────────────────────┘

REMARKS
       This  function allows an application to show its own assertion UI and/or force
       the response to an assertion failure. If the application doesn't provide this,
       SDL  will  try to do the right thing, popping up a system-specific GUI dialog,
       and probably minimizing any fullscreen windows.

       The function prototype for handler is:

       ┌──────────────────────────────────────────────────────────────────────────┐
       │ SDL_AssertState YourAssertionHandler(const SDL_AssertData*    data,      │
       │                                      void*                    userdata)  │
       └──────────────────────────────────────────────────────────────────────────┘
       where YourAssertionHandler is the name of your  function  and  its  parameters
       are:

       ┌───────────┬──────────────────────────────┐
       │ data      │ a pointer to the SDL_Assert‐ │
       │           │ Data structure corresponding │
       │           │ to the current assertion     │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ what  was passed as userdata │
       │           │ to SDL_SetAssertionHandler() │
       └───────────┴──────────────────────────────┘
       This callback should return an SDL_AssertState value indicating how to  handle
       the assertion failure.

       This  callback may fire from any thread, but it runs wrapped in a mutex, so it
       will only fire from one thread at a time.

       This callback is NOT reset to SDL's internal handler upon SDL_Quit()!

RELATED FUNCTIONS
       SDL_GetAssertionHandler

===============================================================================
                                                              *SDL_SetClipRect*


NAME
       SDL_SetClipRect -- Function

SYNOPSIS
       Use this function to set the clipping rectangle for a surface.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ SDL_bool SDL_SetClipRect(SDL_Surface*       surface,  │
       │                          const SDL_Rect*    rect)     │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ be clipped                   │
       ├──────────┼──────────────────────────────┤
       │ rect     │ the SDL_Rect structure  rep‐ │
       │          │ resenting  the clipping rec‐ │
       │          │ tangle, or NULL  to  disable │
       │          │ clipping                     │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  SDL_TRUE if the rectangle intersects the surface, otherwise SDL_FALSE
       and blits will be completely clipped.

REMARKS
       When surface is the destination of a blit, only the area within the clip  rec‐
       tangle is drawn into.

       Note  that blits are automatically clipped to the edges of the source and des‐
       tination surfaces.

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_GetClipRect

===============================================================================
                                                         *SDL_SetClipboardText*


NAME
       SDL_SetClipboardText -- Function

SYNOPSIS
       Use this function to put UTF-8 text into the cilpboard.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ int SDL_SetClipboardText(const char*    text)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ text  │ the  text  to  store  in the │
       │       │ clipboard                    │
       └───────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_GetClipboardText
       SDL_HasClipboardText

===============================================================================
                                                              *SDL_SetColorKey*


NAME
       SDL_SetColorKey -- Function

SYNOPSIS
       Use this function to set the color key (transparent pixel) in a surface.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_SetColorKey(SDL_Surface*    surface,  │
       │                     int             flag,     │
       │                     Uint32          key)      │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ update                       │
       ├──────────┼──────────────────────────────┤
       │ flag     │ SDL_TRUE  to  enable   color │
       │          │ key,  SDL_FALSE  to  disable │
       │          │ color key                    │
       ├──────────┼──────────────────────────────┤
       │ key      │ the transparent pixel        │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       The  color  key defines a pixel value that will be treated as transparent in a
       blit. It is a pixel of the  format  used  by  the  surface,  as  generated  by
       SDL_MapRGB().

       RLE acceleration can substantially speed up blitting of images with large hor‐
       izontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_GetColorKey

===============================================================================
                                                                *SDL_SetColors*


NAME
       SDL_SetColors - Sets a portion of the colormap for the given 8-bit surface.

SYNOPSIS
       #include "SDL.h"

       int SDL_SetColors(SDL_Surface *surface, SDL_Color *colors, int firstcolor, int
       ncolors);

DESCRIPTION
       Sets a portion of the colormap for the given 8-bit surface.

       When surface is the surface associated with the current display,  the  display
       colormap  will  be updated with the requested colors. If SDL_HWPALETTE was set
       in SDL_SetVideoMode flags, SDL_SetColors will always return 1, and the palette
       is guaranteed to be set the way you desire, even if the window colormap has to
       be warped or run under emulation.

       The color components of a SDL_Color structure are 8-bits in size, giving you a
       total of 256^3 =16777216 colors.

       Palettized  (8-bit)  screen surfaces with the SDL_HWPALETTE flag have two pal‐
       ettes, a logical palette that is used for mapping blits  to/from  the  surface
       and  a  physical palette (that determines how the hardware will map the colors
       to the display). SDL_SetColors modifies both palettes  (if  present),  and  is
       equivalent  to  calling  SDL_SetPalette  with  the  flags set to (SDL_LOGPAL |
       SDL_PHYSPAL).

RETURN VALUE
       If surface is not a palettized surface, this function does nothing,  returning
       0. If all of the colors were set as passed to SDL_SetColors, it will return 1.
       If not all the color entries were set exactly as given, it will return 0,  and
       you should look at the surface palette to determine the actual color palette.

EXAMPLE
       /* Create a display surface with a grayscale palette */
       SDL_Surface *screen;
       SDL_Color colors[256];
       int i;
       .
       .
       .
       /* Fill colors with color information */
       for(i=0;i<256;i++){
         colors[i].r=i;
         colors[i].g=i;
         colors[i].b=i;
       }

       /* Create display */
       screen=SDL_SetVideoMode(640, 480, 8, SDL_HWPALETTE);
       if(!screen){
         printf("Couldn't set video mode: %s
       ", SDL_GetError());
         exit(-1);
       }

       /* Set palette */
       SDL_SetColors(screen, colors, 0, 256);
       .
       .
       .
       .

SEE ALSO
       SDL_Color SDL_Surface, SDL_SetPalette, SDL_SetVideoMode

===============================================================================
                                                                *SDL_SetCursor*


NAME
       SDL_SetCursor -- Function

SYNOPSIS
       Use this function to set the active cursor.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_SetCursor(SDL_Cursor*    cursor)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ cursor  │ a cursor to make active; see │
       │         │ Remarks for details          │
       └─────────┴──────────────────────────────┘

REMARKS
       This function sets the currently active cursor to the specified  one.  If  the
       cursor is currently visible, the change will be immediately represented on the
       display. SDL_SetCursor(NULL) can be used to force cursor redraw,  if  this  is
       desired for any reason.

RELATED FUNCTIONS
       SDL_CreateCursor
       SDL_GetCursor
       SDL_ShowCursor

===============================================================================
                                                                 *SDL_SetError*


NAME
       SDL_SetError -- Function

SYNOPSIS
       Use this function to set the SDL error message.

SYNTAX
       ┌───────────────────────────────────────┐
       │ int SDL_SetError(const char*    fmt,  │
       │                  ...)                 │
       └───────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ fmt  │ a   printf()  style  message │
       │      │ format string                │
       ├──────┼──────────────────────────────┤
       │ ...  │ additional parameters match‐ │
       │      │ ing  %  tokens  in  the  fmt │
       │      │ string, if any               │
       └──────┴──────────────────────────────┘

RETURN VALUE
       Returns always -1.

CODE EXAMPLEs
       ┌──────────────────────────────────────────────────┐
       │ SDL_SetError("Something unexpected happened!");  │
       └──────────────────────────────────────────────────┘

       ┌───────────────────────────────────────────────────────────────────────────────┐
       │ int errorCode = 0;                                                            │
       │ errorCode = -37;                                                              │
       │ if (errorCode < 0)                                                            │
       │     SDL_SetError("Something unexpected happened: Error Code %d", errorCode);  │
       └───────────────────────────────────────────────────────────────────────────────┘

REMARKS
       Calling this function will replace any previous error message that was set.

RELATED FUNCTIONS
       SDL_ClearError
       SDL_GetError

===============================================================================
                                                           *SDL_SetEventFilter*


NAME
       SDL_SetEventFilter -- Function

SYNOPSIS
       Use  this function to set up a filter to process all events before they change
       internal state and are posted to the internal event queue.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ void SDL_SetEventFilter(SDL_EventFilter   filter,    │
       │                         void*             userdata)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ filter    │ the function to call when an │
       │           │ event  happens;  see Remarks │
       │           │ for details                  │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ a pointer that is passed  to │
       │           │ filter                       │
       └───────────┴──────────────────────────────┘

REMARKS
       The function prototype for filter is:

       ┌──────────────────────────────────────────────┐
       │ int YourEventFilter(void*         userdata,  │
       │                     SDL_Event*    event)     │
       └──────────────────────────────────────────────┘
       where YourEventFilter is the name of your function and its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ what  was passed as userdata │
       │           │ to SDL_SetEventFilter()      │
       ├───────────┼──────────────────────────────┤
       │ event     │ the event that triggered the │
       │           │ callback                     │
       └───────────┴──────────────────────────────┘
       If filter returns 1, then the event will be added to the internal queue. If it
       returns 0, then the event will be dropped from the  queue,  but  the  internal
       state  will  still  be updated. This allows selective filtering of dynamically
       arriving events.

       WARNING: Be very careful of what you do in the event filter  function,  as  it
       may run in a differnt thread!

       If  the  quit event is generated by an interrupt signal (e.g. Ctrl-C), it will
       be delivered to the application at the next event poll.

       Note: Disabled events  never  make  it  to  the  event  filter  function;  see
       SDL_EventState().

       Note:  If  you  just  want to inspect events without filtering, you should use
       SDL_AddEventWatch() instead.

       Note: Events pushed onto the queue with SDL_PushEvent() get passed through the
       event filter, but events pushed onto the queue with SDL_PeepEvents() do not.

RELATED FUNCTIONS
       SDL_AddEventWatch
       SDL_EventState
       SDL_GetEventFilter
       SDL_PeepEvents
       SDL_PushEvent

===============================================================================
                                                                 *SDL_SetGamma*


NAME
       SDL_SetGamma - Sets the color gamma function for the display

SYNOPSIS
       #include "SDL.h"

       int SDL_SetGamma(float redgamma, float greengamma, float bluegamma);

DESCRIPTION
       Sets  the "gamma function" for the display of each color component. Gamma con‐
       trols the brightness/contrast of colors displayed on the screen. A gamma value
       of 1.0 is identity (i.e., no adjustment is made).

       This  function  adjusts the gamma based on the "gamma function" parameter, you
       can directly specify lookup tables for gamma adjustment with SDL_SetGammaRamp.

       Not all display hardware is able to change gamma.

RETURN VALUE
       Returns -1 on error (or if gamma adjustment is not supported).

SEE ALSO
       SDL_GetGammaRamp SDL_SetGammaRamp

===============================================================================
                                                             *SDL_SetGammaRamp*


NAME
       SDL_SetGammaRamp - Sets the color gamma lookup tables for the display

SYNOPSIS
       #include "SDL.h"

       int SDL_SetGammaRamp(Uint16 *redtable, Uint16 *greentable, Uint16 *bluetable);

DESCRIPTION
       Sets  the  gamma  lookup tables for the display for each color component. Each
       table is an array of 256 Uint16 values, representing a mapping between the in‐
       put  and  output  for that channel. The input is the index into the array, and
       the output is the 16-bit gamma value at that index, scaled to the output color
       precision. You may pass NULL to any of the channels to leave them unchanged.

       This  function adjusts the gamma based on lookup tables, you can also have the
       gamma calculated based on a "gamma function" parameter with SDL_SetGamma.

       Not all display hardware is able to change gamma.

RETURN VALUE
       Returns -1 on error (or if gamma adjustment is not supported).

SEE ALSO
       SDL_SetGamma SDL_GetGammaRamp

===============================================================================
                                                                  *SDL_SetHint*


NAME
       SDL_SetHint -- Function

SYNOPSIS
       Use this function to set a hint with normal priority.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ SDL_bool SDL_SetHint(const char*    name,   │
       │                      const char*    value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ name   │ the  hint  to  set;  see the │
       │        │ list of hints  on  Category‐ │
       │        │ Hints     (https://wiki.lib‐ │
       │        │ sdl.org/CategoryHints#Hints) │
       │        │ for details                  │
       ├────────┼──────────────────────────────┤
       │ value  │ the  value of the hint vari‐ │
       │        │ able                         │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.

CODE EXAMPLES
       ┌───────────────────────────────────────────────────┐
       │ SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1");  │
       └───────────────────────────────────────────────────┘

REMARKS
       Hints will not be set if there is an existing  override  hint  or  environment
       variable  that  takes precedence. You can use SDL_SetHintWithPriority() to set
       the hint with override priority instead.

RELATED FUNCTIONS
       SDL_GetHint
       SDL_SetHintWithPriority

===============================================================================
                                                      *SDL_SetHintWithPriority*


NAME
       SDL_SetHintWithPriority -- Function

SYNOPSIS
       Use this function to set a hint with a specific priority.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ SDL_bool SDL_SetHintWithPriority(const char*        name,      │
       │                                  const char*        value,     │
       │                                  SDL_HintPriority   priority)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ name      │ the  hint  to  set;  see the │
       │           │ list of hints  on  Category‐ │
       │           │ Hints     (https://wiki.lib‐ │
       │           │ sdl.org/CategoryHints#Hints) │
       │           │ for details                  │
       ├───────────┼──────────────────────────────┤
       │ value     │ the  value of the hint vari‐ │
       │           │ able                         │
       ├───────────┼──────────────────────────────┤
       │ priority  │ the  SDL_HintPriority  level │
       │           │ for the hint                 │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.

REMARKS
       The  priority  controls  the  behavior  when setting a hint that already has a
       value. Hints will replace existing hints of their priority and lower. Environ‐
       ment variables are considered to have override priority.

RELATED FUNCTIONS
       SDL_GetHint
       SDL_SetHint

===============================================================================
                                                             *SDL_SetMainReady*


NAME
       SDL_SetMainReady -- Function

SYNOPSIS
       Use  this  function  to  circumvent  failure  of  SDL_Init()  when  not  using
       SDL_main() as an entry point.

SYNTAX
       ┌──────────────────────────────┐
       │ void SDL_SetMainReady(void)  │
       └──────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────┐
       │ #define SDL_MAIN_HANDLED          │
       │ #include "SDL.h"                  │
       │                                   │
       │ int main(int argc, char* argv[])  │
       │ {                                 │
       │   SDL_SetMainReady();             │
       │   SDL_Init(SDL_INIT_VIDEO);       │
       │                                   │
       │   ...                             │
       │                                   │
       │   SDL_Quit();                     │
       │                                   │
       │   return 0;                       │
       │ }                                 │
       └───────────────────────────────────┘

REMARKS
       This function is defined in SDL_main.h, along with the  preprocessor  rule  to
       redefine  main()  as SDL_main(). Thus to ensure that your main() function will
       not be changed, it is necessary to define  SDL_MAIN_HANDLED  before  including
       SDL.h.

       Normally,  we call this function whenever we want to manually proceed initial‐
       ization sequence of SDL ourselves and not let SDL injects its  main  function,
       thus use our main function as it is.

       You should know what you are doing when calling this function.

RELATED FUNCTIONS
       SDL_Init

===============================================================================
                                                              *SDL_SetModState*


NAME
       SDL_SetModState -- Function

SYNOPSIS
       Use this function to set the current key modifier state for the keyboard.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ void SDL_SetModState(SDL_Keymod   modstate)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ modstate  │ the  desired  SDL_Keymod for │
       │           │ the keyboard                 │
       └───────────┴──────────────────────────────┘

REMARKS
       The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose modi‐
       fier  key  states on your application. Simply pass your desired modifier state
       into modstate. This value may be a bitwise,  OR'd  combination  of  SDL_Keymod
       values.

       This does not change the keyboard state, only the key modifier flags.

RELATED FUNCTIONS
       SDL_GetModState

===============================================================================
                                                               *SDL_SetPalette*


NAME
       SDL_SetPalette - Sets the colors in the palette of an 8-bit surface.

SYNOPSIS
       #include "SDL.h"

       int  SDL_SetPalette(SDL_Surface  *surface,  int  flags, SDL_Color *colors, int
       firstcolor, int ncolors);

DESCRIPTION
       Sets a portion of the palette for the given 8-bit surface.

       Palettized (8-bit) screen surfaces with the SDL_HWPALETTE flag have  two  pal‐
       ettes,  a  logical  palette that is used for mapping blits to/from the surface
       and a physical palette (that determines how the hardware will map  the  colors
       to the display). SDL_BlitSurface always uses the logical palette when blitting
       surfaces (if it has to convert between  surface  pixel  formats).  Because  of
       this,  it  is  often useful to modify only one or the other palette to achieve
       various special color effects (e.g., screen fading, color flashes, screen dim‐
       ming).

       This  function  can modify either the logical or physical palette by specifing
       SDL_LOGPAL or SDL_PHYSPALthe in the flags parameter.

       When surface is the surface associated with the current display,  the  display
       colormap  will  be updated with the requested colors. If SDL_HWPALETTE was set
       in SDL_SetVideoMode flags, SDL_SetPalette will always return 1, and  the  pal‐
       ette  is  guaranteed to be set the way you desire, even if the window colormap
       has to be warped or run under emulation.

       The color components of a SDL_Color structure are 8-bits in size, giving you a
       total of 256^3=16777216 colors.

RETURN VALUE
       If  surface is not a palettized surface, this function does nothing, returning
       0. If all of the colors were set as passed to SDL_SetPalette, it  will  return
       1.  If  not all the color entries were set exactly as given, it will return 0,
       and you should look at the surface palette to determine the actual color  pal‐
       ette.

EXAMPLE
               /* Create a display surface with a grayscale palette */
               SDL_Surface *screen;
               SDL_Color colors[256];
               int i;
               .
               .
               .
               /* Fill colors with color information */
               for(i=0;i<256;i++){
                 colors[i].r=i;
                 colors[i].g=i;
                 colors[i].b=i;
               }

               /* Create display */
               screen=SDL_SetVideoMode(640, 480, 8, SDL_HWPALETTE);
               if(!screen){
                 printf("Couldn't set video mode: %s
       ", SDL_GetError());
                 exit(-1);
               }

               /* Set palette */
               SDL_SetPalette(screen, SDL_LOGPAL|SDL_PHYSPAL, colors, 0, 256);
               .
               .
               .
               .

SEE ALSO
       SDL_SetColors, SDL_SetVideoMode, SDL_Surface, SDL_Color

===============================================================================
                                                         *SDL_SetPaletteColors*


NAME
       SDL_SetPaletteColors -- Function

SYNOPSIS
       Use this function to set a range of colors in a palette.

SYNTAX
       ┌──────────────────────────────────────────────────────────┐
       │ int SDL_SetPaletteColors(SDL_Palette*       palette,     │
       │                          const SDL_Color*   colors,      │
       │                          int                firstcolor,  │
       │                          int                ncolors)     │
       └──────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────┬──────────────────────────────┐
       │ palette     │ the SDL_Palette structure to │
       │             │ modify                       │
       ├─────────────┼──────────────────────────────┤
       │ colors      │ an array of SDL_Color struc‐ │
       │             │ tures  to copy into the pal‐ │
       │             │ ette                         │
       ├─────────────┼──────────────────────────────┤
       │ firstcolor  │ the index of the first  pal‐ │
       │             │ ette entry to modify         │
       ├─────────────┼──────────────────────────────┤
       │ ncolors     │ the  number  of  entries  to │
       │             │ modify                       │
       └─────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code if not all of the  colors  could
       be set; call SDL_GetError() for more information.

RELATED FUNCTIONS
       SDL_AllocPalette
       SDL_CreateRGBSurface

===============================================================================
                                                    *SDL_SetPixelFormatPalette*


NAME
       SDL_SetPixelFormatPalette -- Function

SYNOPSIS
       Use this function to set the palette for a pixel format structure.

SYNTAX
       ┌─────────────────────────────────────────────────────────────┐
       │ int SDL_SetPixelFormatPalette(SDL_PixelFormat*    format,   │
       │                               SDL_Palette*        palette)  │
       └─────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ format   │ the  SDL_PixelFormat  struc‐ │
       │          │ ture that will use the  pal‐ │
       │          │ ette                         │
       ├──────────┼──────────────────────────────┤
       │ palette  │ the   SDL_Palette  structure │
       │          │ that will be used            │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

RELATED FUNCTIONS
       SDL_AllocPalette
       SDL_FreePalette

===============================================================================
                                                     *SDL_SetRelativeMouseMode*


NAME
       SDL_SetRelativeMouseMode -- Function

SYNOPSIS
       Use this function to set relative mouse mode.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ int SDL_SetRelativeMouseMode(SDL_bool   enabled)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ enabled  │ whether  or  not  to  enable │
       │          │ relative mode, SDL_TRUE  for │
       │          │ enabled relative mode        │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

       If relative mode is not supported, this return -1.

REMARKS
       While the mouse is in relative mode, the cursor is hidden, and the driver will
       try  to  report  continuous motion in the current window. Only relative motion
       events will be delivered, the mouse position will not change.

RELATED FUNCTIONS
       SDL_GetRelativeMouseMode

===============================================================================
                                                   *SDL_SetRenderDrawBlendMode*


NAME
       SDL_SetRenderDrawBlendMode -- Function

SYNOPSIS
       Use  this function to set the blend mode used for drawing operations (Fill and
       Line).

SYNTAX
       ┌─────────────────────────────────────────────────────────────┐
       │ int SDL_SetRenderDrawBlendMode(SDL_Renderer*    renderer,   │
       │                                SDL_BlendMode    blendMode)  │
       └─────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ renderer   │ the rendering context        │
       ├────────────┼──────────────────────────────┤
       │ blendMode  │ the SDL_BlendMode to use for │
       │            │ blending;  see  Remarks  for │
       │            │ details                      │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       blendMode may be one of the following:

       ┌──────────────────────┬──────────────────────────────┐
       │ SDL_BLENDMODE_NONE   │ no blending                  │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGBA = srcRGBA            │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE_BLEND  │ alpha blending               │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB  =  (srcRGB * srcA) + │
       │                      │ (dstRGB * (1-srcA))          │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstA  =  srcA  +   (dstA   * │
       │                      │ (1-srcA))                    │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE_ADD    │ additive blending            │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB  =  (srcRGB * srcA) + │
       │                      │ dstRGB                       │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstA = dstA                  │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE        │ color modulate               │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB = srcRGB * dstRGB     │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstA = dstA                  │
       └──────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetRenderDrawBlendMode
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderFillRect
       SDL_RenderFillRects

===============================================================================
                                                       *SDL_SetRenderDrawColor*


NAME
       SDL_SetRenderDrawColor -- Function

SYNOPSIS
       Use this function to set the color used for drawing operations (Rect, Line and
       Clear).

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_SetRenderDrawColor(SDL_Renderer*    renderer,  │
       │                            Uint8            r,         │
       │                            Uint8            g,         │
       │                            Uint8            b,         │
       │                            Uint8            a)         │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ r         │ the red value used  to  draw │
       │           │ on the rendering target      │
       ├───────────┼──────────────────────────────┤
       │ g         │ the green value used to draw │
       │           │ on the rendering target      │
       ├───────────┼──────────────────────────────┤
       │ b         │ the blue value used to  draw │
       │           │ on the rendering target      │
       ├───────────┼──────────────────────────────┤
       │ a         │ the alpha value used to draw │
       │           │ on  the  rendering   target; │
       │           │ usually              SDL_AL‐ │
       │           │ PHA_OPAQUE(255). Use SDL_Se‐ │
       │           │ tRenderDrawBlendMode      to │
       │           │ specify how the alpha  chan‐ │
       │           │ nel is used.                 │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────┐
       │ SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);  │
       │ SDL_Rect rectangle;                                │
       │                                                    │
       │ rectangle.x = 0;                                   │
       │ rectangle.y = 0;                                   │
       │ rectangle.w = 50;                                  │
       │ rectangle.h = 50;                                  │
       │ SDL_RenderFillRect(renderer, &rectangle);          │
       └────────────────────────────────────────────────────┘

REMARKS
       Use this function to set the color for drawing or filling  rectangles,  lines,
       and points, and for SDL_RenderClear().

RELATED FUNCTIONS
       SDL_GetRenderDrawColor
       SDL_RenderClear
       SDL_RenderDrawLine
       SDL_RenderDrawLines
       SDL_RenderDrawPoint
       SDL_RenderDrawPoints
       SDL_RenderDrawRect
       SDL_RenderDrawRects
       SDL_RenderFillRect
       SDL_RenderFillRects

===============================================================================
                                                          *SDL_SetRenderTarget*


NAME
       SDL_SetRenderTarget -- Function

SYNOPSIS
       Use this function to set a texture as the current rendering target.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_SetRenderTarget(SDL_Renderer*   renderer,  │
       │                         SDL_Texture*    texture)   │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ renderer  │ the rendering context        │
       ├───────────┼──────────────────────────────┤
       │ texture   │ the  targeted texture, which │
       │           │ must  be  created  with  the │
       │           │ SDL_TEXTUREACCESS_TARGET     │
       │           │ flag, or NULL  for  the  de‐ │
       │           │ fault render target          │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Before using this function, you should  check  the  SDL_RENDERER_TARGETTEXTURE
       bit in the flags of SDL_RendererInfo to see if render targets are supported.

       The default render target is the window for which the renderer was created.

RELATED FUNCTIONS
       SDL_GetRenderTarget

===============================================================================
                                                       *SDL_SetSurfaceAlphaMod*


NAME
       SDL_SetSurfaceAlphaMod -- Function

SYNOPSIS
       Use this function to set an additional alpha value used in blit operations.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_SetSurfaceAlphaMod(SDL_Surface*   surface,  │
       │                            Uint8          alpha)    │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ update                       │
       ├──────────┼──────────────────────────────┤
       │ alpha    │ the alpha  value  multiplied │
       │          │ into blit operations         │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       When this surface is blitted, during the blit operation the source alpha value
       is modulated by this alpha value according to the following formula.

       ┌──────────────────────────────┐
       │ srcA = srcA * (alpha / 255)  │
       └──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetSurfaceAlphaMod
       SDL_SetSurfaceColorMod

===============================================================================
                                                      *SDL_SetSurfaceBlendMode*


NAME
       SDL_SetSurfaceBlendMode -- Function

SYNOPSIS
       Use this function to set the blend mode used for blit operations.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ int SDL_SetSurfaceBlendMode(SDL_Surface*    surface,    │
       │                             SDL_BlendMode   blendMode)  │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ surface    │ the SDL_Surface structure to │
       │            │ update                       │
       ├────────────┼──────────────────────────────┤
       │ blendMode  │ the SDL_BlendMode to use for │
       │            │ blit  blending;  see Remarks │
       │            │ for details                  │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       blendMode may be one of the following:

       ┌──────────────────────┬──────────────────────────────┐
       │ SDL_BLENDMODE_NONE   │ no blending                  │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGBA = srcRGBA            │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE_BLEND  │ alpha blending               │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB  =  (srcRGB * srcA) + │
       │                      │ (dstRGB * (1-srcA))          │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstA  =  srcA  +   (dstA   * │
       │                      │ (1-srcA))                    │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE_ADD    │ additive blending            │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB  =  (srcRGB * srcA) + │
       │                      │ dstRGB                       │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstA = dstA                  │
       ├──────────────────────┼──────────────────────────────┤
       │ SDL_BLENDMODE        │ color modulate               │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstRGB = srcRGB * dstRGB     │
       ├──────────────────────┼──────────────────────────────┤
       │                      │ dstA = dstA                  │
       └──────────────────────┴──────────────────────────────┘
       To copy a surface to another surface (or texture) without  blending  with  the
       existing data, the blendmode of the SOURCE surface should be set to SDL_BLEND‐
       MODE_NONE.

RELATED FUNCTIONS
       SDL_GetSurfaceBlendMode

===============================================================================
                                                       *SDL_SetSurfaceColorMod*


NAME
       SDL_SetSurfaceColorMod -- Function

SYNOPSIS
       Use this function to set an additional color value multiplied into blit opera‐
       tions.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_SetSurfaceColorMod(SDL_Surface*   surface,  │
       │                            Uint8          r,        │
       │                            Uint8          g,        │
       │                            Uint8          b)        │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ update                       │
       ├──────────┼──────────────────────────────┤
       │ r        │ the  red  color value multi‐ │
       │          │ plied into blit operations   │
       ├──────────┼──────────────────────────────┤
       │ g        │ the green color value multi‐ │
       │          │ plied into blit operations   │
       ├──────────┼──────────────────────────────┤
       │ b        │ the  blue color value multi‐ │
       │          │ plied into blit operations   │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       When  this  surface  is  blitted,  during the blit operation each source color
       channel is modulated by the appropriate color value according to the following
       formula:

       ┌──────────────────────────────┐
       │ srcC = srcC * (color / 255)  │
       └──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetSurfaceColorMod
       SDL_SetSurfaceAlphaMod

===============================================================================
                                                        *SDL_SetSurfacePalette*


NAME
       SDL_SetSurfacePalette -- Function

SYNOPSIS
       Use this function to set the palette used by a surface.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_SetSurfacePalette(SDL_Surface*    surface,  │
       │                           SDL_Palette*    palette)  │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ update                       │
       ├──────────┼──────────────────────────────┤
       │ palette  │ the SDL_Palette structure to │
       │          │ use                          │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       A single palette can be shared with many surfaces.

===============================================================================
                                                            *SDL_SetSurfaceRLE*


NAME
       SDL_SetSurfaceRLE -- Function

SYNOPSIS
       Use this function to set the RLE acceleration hint for a surface.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ int SDL_SetSurfaceRLE(SDL_Surface*    surface,  │
       │                       int             flag)     │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ optimize                     │
       ├──────────┼──────────────────────────────┤
       │ flag     │ 0 to  disable,  non-zero  to │
       │          │ enable RLE acceleration      │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       If RLE is enabled, color key and alpha blending blits are much faster, but the
       surface must be locked before directly accessing the pixels.

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_LockSurface
       SDL_UnlockSurface

===============================================================================
                                                         *SDL_SetTextInputRect*


NAME
       SDL_SetTextInputRect -- Function

SYNOPSIS
       Use this function to set the rectangle used to type Unicode text inputs.

SYNTAX
       ┌──────────────────────────────────────────────┐
       │ void SDL_SetTextInputRect(SDL_Rect*   rect)  │
       └──────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────┬──────────────────────────────┐
       │ rect  │ the  SDL_Rect structure rep‐ │
       │       │ resenting the  rectangle  to │
       │       │ receive   text  (ignored  if │
       │       │ NULL)                        │
       └───────┴──────────────────────────────┘

REMARKS
       There is a tutorial (https://wiki.libsdl.org/Tutorials/TextInput).

RELATED FUNCTIONS
       SDL_StartTextInput

===============================================================================
                                                       *SDL_SetTextureAlphaMod*


NAME
       SDL_SetTextureAlphaMod -- Function

SYNOPSIS
       Use this function to set an additional alpha value multiplied into render copy
       operations.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_SetTextureAlphaMod(SDL_Texture*   texture,  │
       │                            Uint8          alpha)    │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to update        │
       ├──────────┼──────────────────────────────┤
       │ alpha    │ the source alpha value  mul‐ │
       │          │ tiplied into copy operations │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       When this texture is rendered, during the  copy  operation  the  source  alpha
       value is modulated by this alpha value according to the following formula:

       ┌──────────────────────────────┐
       │ srcA = srcA * (alpha / 255)  │
       └──────────────────────────────┘
       Alpha modulation is not always supported by the renderer; it will return -1 if
       alpha modulation is not supported.

RELATED FUNCTIONS
       SDL_GetTextureAlphaMod
       SDL_SetTextureColorMod

===============================================================================
                                                      *SDL_SetTextureBlendMode*


NAME
       SDL_SetTextureBlendMode -- Function

SYNOPSIS
       Use  this  function  to  set the blend mode for a texture, used by SDL_Render‐
       Copy().

SYNTAX
       ┌───────────────────────────────────────────────────────────┐
       │ int SDL_SetTextureBlendMode(SDL_Texture*      texture,    │
       │                             SDL_BlendMode*    blendMode)  │
       └───────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ texture    │ the texture to update        │
       ├────────────┼──────────────────────────────┤
       │ blendMode  │ the SDL_BlendMode to use for │
       │            │ texture  blending;  see  Re‐ │
       │            │ marks for details            │
       └────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       blendMode will be filled in with one of the following:

       ┌──────────────────────┬──────────────────────────────────────────────────┐
       │ SDL_BLENDMODE_NONE   │ no blending                                      │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGBA = srcRGBA                                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_BLEND  │ alhpa blending                                   │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = (srcRGB * srcA) + (dstRGB * (1 - srcA)) │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = srcA + (dstA * (1 - srcA))                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_ADD    │ additive blending                                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = (srcRGB * srcA) + dstRGB                │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = dstA                                      │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │ SDL_BLENDMODE_MOD    │ color modulate                                   │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstRGB = srcRGB * dstRGB                         │
       ├──────────────────────┼──────────────────────────────────────────────────┤
       │                      │ dstA = dstA                                      │
       └──────────────────────┴──────────────────────────────────────────────────┘
       If  the  blend mode is not supported, the closest supported mode is chosen and
       this function returns -1.

RELATED FUNCTIONS
       SDL_GetTextureBlendMode
       SDL_RenderCopy

===============================================================================
                                                       *SDL_SetTextureColorMod*


NAME
       SDL_SetTextureColorMod -- Function

SYNOPSIS
       Use this function to set an additional color value multiplied into render copy
       operations.

SYNTAX
       ┌─────────────────────────────────────────────────────┐
       │ int SDL_SetTextureColorMod(SDL_Texture*   texture,  │
       │                            Uint8          r,        │
       │                            Uint8          g,        │
       │                            Uint8          b)        │
       └─────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to update        │
       ├──────────┼──────────────────────────────┤
       │ r        │ the red color  value  multi‐ │
       │          │ plied into copy operations   │
       ├──────────┼──────────────────────────────┤
       │ g        │ the green color value multi‐ │
       │          │ plied into copy operations   │
       ├──────────┼──────────────────────────────┤
       │ b        │ the blue color value  multi‐ │
       │          │ plied into copy operations   │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────┐
       │ SDL_Surface pTexture = SDL_CreateTextureFromSurface(renderer, loadedSurface);  │
       │ SDL_SetTextureColorMod(pTexture, 64, 64, 64);                                  │
       └────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       When this texture is rendered, during the copy  operation  each  source  color
       channel  is modulated by the appropriate color value accoding to the following
       formula:

       ┌──────────────────────────────┐
       │ srcC = srcC * (color / 255)  │
       └──────────────────────────────┘
       Color modulation is not always supported by the renderer; it will return -1 if
       color modulation is not supported.

RELATED FUNCTIONS
       SDL_GetTextureColorMod
       SDL_SetTextureAlphaMod

===============================================================================
                                                        *SDL_SetThreadPriority*


NAME
       SDL_SetThreadPriority -- Function

SYNOPSIS
       Use this function to set the priority for the current thread.

SYNTAX
       ┌────────────────────────────────────────────────────────────┐
       │ int SDL_SetThreadPriority(SDL_ThreadPriority    priority)  │
       └────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ priority  │ the   SDL_ThreadPriority  to │
       │           │ set; see Remarks for details │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       priority may be one of the following:

       ┌─────────────────────────────┬──────────────────────────────┐
       │ SDL_THREAD_PRIORITY_LOW     │ for  non-urgent,  background │
       │                             │ processing                   │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_THREAD_PRIORITY_NORMAL  │ for general purpose process‐ │
       │                             │ ing (default)                │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_THREAD_PRIORITY_HIGH    │ for timing-critical process‐ │
       │                             │ ing                          │
       └─────────────────────────────┴──────────────────────────────┘

===============================================================================
                                                                 *SDL_SetTimer*


NAME
       SDL_SetTimer  -  Set a callback to run after the specified number of millisec‐
       onds has elapsed.

SYNOPSIS
       #include "SDL.h"

       int SDL_SetTimer(Uint32 interval, SDL_TimerCallback callback);

CALLBACK
       /* Function prototype for  the  timer  callback  function  */  typedef  Uint32
       (*SDL_TimerCallback)(Uint32 interval);

DESCRIPTION
       Set  a callback to run after the specified number of milliseconds has elapsed.
       The callback function is passed the current timer  interval  and  returns  the
       next  timer  interval. If the returned value is the same as the one passed in,
       the periodic alarm continues, otherwise a new alarm is scheduled.

       To cancel a currently running timer, call SDL_SetTimer(0, NULL);

       The timer callback function may run in a different thread than your main  con‐
       stant, and so shouldn't call any functions from within itself.

       The maximum resolution of this timer is 10 ms, which means that if you request
       a 16 ms timer, your callback will run approximately 20 ms later on an unloaded
       system.  If you wanted to set a flag signaling a frame update at 30 frames per
       second (every 33 ms), you might set a timer for 30 ms (see example below).

       If you use this function, you need to pass SDL_INIT_TIMER to SDL_Init().

              Note:

              This function is kept for compatibility but has been superseded by  the
              new timer functions SDL_AddTimer and SDL_RemoveTimer which support mul‐
              tiple timers.

EXAMPLES
       SDL_SetTimer((33/10)*10, my_callback);

SEE ALSO
       SDL_AddTimer

===============================================================================
                                                             *SDL_SetVideoMode*


NAME
       SDL_SetVideoMode  -  Set  up a video mode with the specified width, height and
       bits-per-pixel.

SYNOPSIS
       #include "SDL.h"

       SDL_Surface *SDL_SetVideoMode(int width, int height, int bpp, Uint32 flags);

DESCRIPTION
       Set up a video mode with the specified width, height and bits-per-pixel.

       If bpp is 0, it is treated as the current display bits per pixel.

       The flags parameter is the same as the flags field of the  SDL_Surface  struc‐
       ture. OR'd combinations of the following values are valid.

       SDL_SWSURFACE       Create the video surface in system memory

       SDL_HWSURFACE       Create the video surface in video memory

       SDL_ASYNCBLIT       Enables  the  use  of  asynchronous updates of the display
                           surface. This will usually slow down  blitting  on  single
                           CPU machines, but may provide a speed increase on SMP sys‐
                           tems.

       SDL_ANYFORMAT       Normally, if a video surface of  the  requested  bits-per-
                           pixel  (bpp) is not available, SDL will emulate one with a
                           shadow surface. Passing SDL_ANYFORMAT  prevents  this  and
                           causes  SDL  to  use  the video surface, regardless of its
                           pixel depth.

       SDL_HWPALETTE       Give SDL exclusive palette access. Without this  flag  you
                           may  not  always  get  the  the  colors  you  request with
                           SDL_SetColors or SDL_SetPalette.

       SDL_DOUBLEBUF       Enable hardware double buffering; only valid with  SDL_HW‐
                           SURFACE. Calling SDL_Flip will flip the buffers and update
                           the screen. All drawing will take  place  on  the  surface
                           that  is  not displayed at the moment. If double buffering
                           could not be enabled then SDL_Flip  will  just  perform  a
                           SDL_UpdateRect on the entire screen.

       SDL_FULLSCREEN      SDL  will  attempt to use a fullscreen mode. If a hardware
                           resolution change is not possible (for  whatever  reason),
                           the  next  higher  resolution will be used and the display
                           window centered on a black background.

       SDL_OPENGL          Create an OpenGL rendering context. You should have previ‐
                           ously  set  OpenGL  video  attributes  with  SDL_GL_SetAt‐
                           tribute.

       SDL_OPENGLBLIT      Create an OpenGL rendering context, like above, but  allow
                           normal  blitting  operations.  The screen (2D) surface may
                           have an alpha channel, and SDL_UpdateRects  must  be  used
                           for updating changes to the screen surface.

       SDL_RESIZABLE       Create  a  resizable window. When the window is resized by
                           the  user  a  SDL_VIDEORESIZE  event  is   generated   and
                           SDL_SetVideoMode can be called again with the new size.

       SDL_NOFRAME         If  possible,  SDL_NOFRAME  causes  SDL to create a window
                           with no title bar or frame  decoration.  Fullscreen  modes
                           automatically have this flag set.

              Note:

              Whatever flags SDL_SetVideoMode could satisfy are set in the flags mem‐
              ber of the returned surface.

              Note:

              The bpp parameter is the number of bits per pixel, so a bpp of 24  uses
              the  packed  representation  of  3  bytes/pixel.  For the more common 4
              bytes/pixel mode, use a bpp of 32. Somewhat oddly, both 15 and 16  will
              request a 2 bytes/pixel mode, but different pixel formats.

RETURN VALUE
       The framebuffer surface, or NULL if it fails. The surface returned is freed by
       SDL_Quit() and should nt be freed by the caller.

SEE ALSO
       SDL_LockSurface, SDL_SetColors, SDL_Flip, SDL_Surface

===============================================================================
                                                        *SDL_SetWindowBordered*


NAME
       SDL_SetWindowBordered -- Function

SYNOPSIS
       Use this function to set the border state of a window.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ void SDL_SetWindowBordered(SDL_Window*    window,    │
       │                            SDL_bool       bordered)  │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ window    │ the   window   of  which  to │
       │           │ change the border state      │
       ├───────────┼──────────────────────────────┤
       │ bordered  │ SDL_FALSE to remove  border, │
       │           │ SDL_TRUE to add border       │
       └───────────┴──────────────────────────────┘

REMARKS
       This will add or remove the window's SDL_WINDOW_BORDERLESS flag and add or re‐
       move the border from the actual window. This is a no-op if the window's border
       already matches the requested state.

       You can't change the border state of a fullscreen window.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetWindowFlags

===============================================================================
                                                      *SDL_SetWindowBrightness*


NAME
       SDL_SetWindowBrightness -- Function

SYNOPSIS
       Use  this  function  to  set the brightness (gamma multiplier) for the display
       that owns a given window.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_SetWindowBrightness(SDL_Window*   window,      │
       │                             float         brightness)  │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────┬──────────────────────────────┐
       │ window      │ the window  used  to  select │
       │             │ the display whose brightness │
       │             │ will be changed              │
       ├─────────────┼──────────────────────────────┤
       │ brightness  │ the brightness (gamma multi‐ │
       │             │ plier)  value  to  set where │
       │             │ 0.0 is completely  dark  and │
       │             │ 1.0 is normal brightness     │
       └─────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Despite the name and signature, this method sets the brightness of the  entire
       display,  not  an individual window. A window is considered to be owned by the
       display that contains the window's center pixel. (The index  of  this  display
       can  be  retrieved using SDL_GetWindowDisplayIndex().) The brightness set will
       not follow the window if it is moved to anothe display.

RELATED FUNCTIONS
       SDL_GetWindowBrightness
       SDL_SetWindowGammaRamp

===============================================================================
                                                            *SDL_SetWindowData*


NAME
       SDL_SetWindowData -- Function

SYNOPSIS
       Use this function to associate an arbitrary named pointer with a window.

SYNTAX
       ┌──────────────────────────────────────────────────┐
       │ void* SDL_SetWindowData(SDL_Window*   window,    │
       │                         const char    name,      │
       │                         void*         userdata)  │
       └──────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ window    │ the window to associate with │
       │           │ the pointer                  │
       ├───────────┼──────────────────────────────┤
       │ name      │ the name of the pointer      │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ the associated pointer       │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns the previous value associated with name.

REMARKS
       name is case-sensitive.

RELATED FUNCTIONS
       SDL_GetWindowData

===============================================================================
                                                     *SDL_SetWindowDisplayMode*


NAME
       SDL_SetWindowDisplayMode -- Function

SYNOPSIS
       Use  this  function to set the display mode to use when a window is visible at
       fullscreen.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ int SDL_SetWindowDisplayMode(SDL_Window*              window,  │
       │                              const SDL_DisplayMode*   mode)    │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to affect         │
       ├─────────┼──────────────────────────────┤
       │ mode    │ the  SDL_DisplayMode  struc‐ │
       │         │ ture  representing  the mode │
       │         │ to use, or NULL to  use  the │
       │         │ window's  dimensions and the │
       │         │ desktop's format and refresh │
       │         │ rate                         │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       This only affects the display mode used when  the  window  is  fullscreen.  To
       change  the  window size when the window is not fullscreen, use SDL_SetWindow‐
       Size().

RELATED FUNCTIONS
       SDL_GetWindowDisplayMode
       SDL_SetWindowFullscreen

===============================================================================
                                                      *SDL_SetWindowFullscreen*


NAME
       SDL_SetWindowFullscreen -- Function

SYNOPSIS
       Use this function to set a window's fullscreen state.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_SetWindowFullscreen(SDL_Window*   window,  │
       │                             Uint32        flags)   │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to change         │
       ├─────────┼──────────────────────────────┤
       │ flags   │ SDL_WINDOW_FULLSCREEN,       │
       │         │ SDL_WINDOW_FULLSCREEN_DESK‐  │
       │         │ TOP  or  0;  see Remarks for │
       │         │ details                      │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       flags  may  be  SDL_WINDOW_FULLSCREEN,  for "real" fullscreen with a videomode
       change; SDL_WINDOW_FULLSCREEN_DESKTOP for "fake"  fullscreen  that  takes  the
       size ofthe desktop; and 0 for windowed mode.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_GetWindowDisplayMode
       SDL_SetWindowDisplayMode

===============================================================================
                                                       *SDL_SetWindowGammaRamp*


NAME
       SDL_SetWindowGammaRamp -- Function

SYNOPSIS
       Use this function to set the gamma ramp for the display that owns a given win‐
       dow.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ int SDL_SetWindowGammaRamp(SDL_Window*      window,  │
       │                            const Uint16*    red,     │
       │                            const Uint16*    green,   │
       │                            const Uint16*    blue)    │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window  used  to  select │
       │         │ the display whose gamma ramp │
       │         │ will be changed              │
       ├─────────┼──────────────────────────────┤
       │ red     │ a  256  element   array   of │
       │         │ 16-bit quantities represent‐ │
       │         │ ing  the  translation  table │
       │         │ for the red channel, or NULL │
       ├─────────┼──────────────────────────────┤
       │ green   │ a   256   element  array  of │
       │         │ 16-bit quantities represent‐ │
       │         │ ing  the  translation  table │
       │         │ for the  green  channel,  or │
       │         │ NULL                         │
       ├─────────┼──────────────────────────────┤
       │ blue    │ a   256   element  array  of │
       │         │ 16-bit quantities represent‐ │
       │         │ ing  the  translation  table │
       │         │ for  the  blue  channel,  or │
       │         │ NULL                         │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       Set the gamma translation table for the red, green, and blue channels  of  the
       video  hardware. Each table is an array of 256 16-bit quantities, representing
       a mapping between the input and output for that channel. The input is the  in‐
       dex  into  the  array, and the output is the 16-bit gamma value at that index,
       scaled to the output color precision. Desite  the  name  and  signature,  this
       method  sets  th gamma ramp of the entire display, not an individual window. A
       window is considered to be owned by the display  that  contains  the  window's
       center  pixel.  (The  index of this display can be retrieved using SDL_GetWin‐
       dowDisplayIndex().) The gamma ramp set will not follow the  window  if  it  is
       moved to another display.

RELATED FUNCTIONS
       SDL_GetWindowGammaRamp

===============================================================================
                                                            *SDL_SetWindowGrab*


NAME
       SDL_SetWindowGrab -- Function

SYNOPSIS
       Use this function to set a window's input grab mode.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ void SDL_SetWindowGrab(SDL_Window*    window,   │
       │                        SDL_bool       grabbed)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ window   │ the window for which the in‐ │
       │          │ put grab mode should be set  │
       ├──────────┼──────────────────────────────┤
       │ grabbed  │ SDL_TRUE to  grab  input  or │
       │          │ SDL_FALSE to release input   │
       └──────────┴──────────────────────────────┘

REMARKS
       When input is grabbed, the mouse is confined to the window.

       If  the  caller  enables a grab while another window is currently grabbed, the
       other window loses its grab in favor of the caller's window.

RELATED FUNCTIONS
       SDL_GetGrabbedWindow
       SDL_GetWindowGrab

===============================================================================
                                                         *SDL_SetWindowHitTest*


NAME
       SDL_SetWindowHitTest -- Function

SYNOPSIS
       Use  this  function  to provide a callback that decides if a window region has
       special properties.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ int SDL_SetWindowHitTest(SDL_Window*    window,         │
       │                          SDL_HitTest    callback,       │
       │                          void*          callback_data)  │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────────┬──────────────────────────────┐
       │ window         │ the window to set  hit-test‐ │
       │                │ ing on                       │
       ├────────────────┼──────────────────────────────┤
       │ callback       │ the  function  to  call when │
       │                │ doing a hit-test             │
       ├────────────────┼──────────────────────────────┤
       │ callback_data  │ an app-defined void  pointer │
       │                │ passed to callback           │
       └────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0  on success or -1 on error (including unsupported); call SDL_GetEr‐
       ror() for more information.

REMARKS
       The function prototype for callback is:

       ┌──────────────────────────────────────────────────────────┐
       │ SDL_HitTestResult SDL_HitTest(SDL_Window*         win,   │
       │                               const SDL_Point*    area,  │
       │                               void*               data)  │
       └──────────────────────────────────────────────────────────┘
       where SDL_HitTest is your function name and its parameters are:

       ┌───────┬──────────────────────────────┐
       │ win   │ the  SDL_Window  where  hit- │
       │       │ testing was set on           │
       ├───────┼──────────────────────────────┤
       │ area  │ an SDL_Point which should be │
       │       │ hit-tested                   │
       ├───────┼──────────────────────────────┤
       │ data  │ what wass  passed  as  call‐ │
       │       │ back_data   to   SDL_SetWin‐ │
       │       │ dowHitTest()                 │
       └───────┴──────────────────────────────┘
       callback should return an SDL_HitTestResult.

       Normally windows are dragged and resized by decorations provided by the system
       window  manager (a title bar, borders, etc), but for some apps, it makes sense
       to drag them from somewhere else inside the window itself;  for  example,  one
       might  have  a  borderless window that wants to be draggable from any part, or
       simulate its own title bar, etc.

       This function lets the app provide a callback  that  designates  pieces  of  a
       given  window  as  special. This callback is run during event processing if we
       need to tell the OS to treat a region of the window specially; the use of this
       callback is known as "hit testing".

       Mouse input may not be delivered to your application if it is within a special
       area; the OS will often apply that input to moving the window or resizing  the
       window and not deliver it to the application.

       Specifying  NULL  for a callback disables hit-testing. Hit-testing is disabled
       by default.

       Platforms that don't support this functionality will  return  -1  uncondition‐
       ally, even if you're attempting to disable hit-testing.

       Your  callback may fire at any time, and its firing does not indicate any spe‐
       cific behavior (for example, on Windows, this certainly might fire when the OS
       is  deciding  whether to drag your window, but it fires for lots of other rea‐
       sons, too, some unrelated to anything you probably care  about  and  when  the
       mouse  isn't  actually  at the location it is testing). Since this can fire at
       any time, you should try to keep your callback efficient,  devoid  of  alloca‐
       tions, etc.

       This function is available since SDL 2.0.4.

===============================================================================
                                                            *SDL_SetWindowIcon*


NAME
       SDL_SetWindowIcon -- Function

SYNOPSIS
       Use this function to set the icon for a window.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_SetWindowIcon(SDL_Window*    window,  │
       │                        SDL_Surface*   icon)    │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to change         │
       ├─────────┼──────────────────────────────┤
       │ icon    │ an   SDL_Surface   structure │
       │         │ containing the icon for  the │
       │         │ window                       │
       └─────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ // Using SDL2 to set a window icon                                                                             │
       │                                                                                                                │
       │ #include "SDL.h"                                                                                               │
       │                                                                                                                │
       │ int main(int argc, char* argv[]){                                                                              │
       │                                                                                                                │
       │   SDL_Event e;                                                                                                 │
       │                                                                                                                │
       │   SDL_Init(SDL_INIT_VIDEO);   // Initialize SDL2                                                               │
       │                                                                                                                │
       │   SDL_Window *window = SDL_CreateWindow(    // Open a new window                                               │
       │     "SDL2 window icon demo", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 480, SDL_WINDOW_RESIZABLE  │
       │   );                                                                                                           │
       │                                                                                                                │
       │   SDL_Surface *surface;     // Declare an SDL_Surface to be filled in with pixel data from an image file       │
       │   Uint16 pixels[16*16] = {  // ...or with raw pixel data:                                                      │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0aab, 0x0789, 0x0bcc, 0x0eee, 0x09aa, 0x099a, 0x0ddd,                                            │
       │     0x0fff, 0x0eee, 0x0899, 0x0fff, 0x0fff, 0x1fff, 0x0dde, 0x0dee,                                            │
       │     0x0fff, 0xabbc, 0xf779, 0x8cdd, 0x3fff, 0x9bbc, 0xaaab, 0x6fff,                                            │
       │     0x0fff, 0x3fff, 0xbaab, 0x0fff, 0x0fff, 0x6689, 0x6fff, 0x0dee,                                            │
       │     0xe678, 0xf134, 0x8abb, 0xf235, 0xf678, 0xf013, 0xf568, 0xf001,                                            │
       │     0xd889, 0x7abc, 0xf001, 0x0fff, 0x0fff, 0x0bcc, 0x9124, 0x5fff,                                            │
       │     0xf124, 0xf356, 0x3eee, 0x0fff, 0x7bbc, 0xf124, 0x0789, 0x2fff,                                            │
       │     0xf002, 0xd789, 0xf024, 0x0fff, 0x0fff, 0x0002, 0x0134, 0xd79a,                                            │
       │     0x1fff, 0xf023, 0xf000, 0xf124, 0xc99a, 0xf024, 0x0567, 0x0fff,                                            │
       │     0xf002, 0xe678, 0xf013, 0x0fff, 0x0ddd, 0x0fff, 0x0fff, 0xb689,                                            │
       │     0x8abb, 0x0fff, 0x0fff, 0xf001, 0xf235, 0xf013, 0x0fff, 0xd789,                                            │
       │     0xf002, 0x9899, 0xf001, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0xe789,                                            │
       │     0xf023, 0xf000, 0xf001, 0xe456, 0x8bcc, 0xf013, 0xf002, 0xf012,                                            │
       │     0x1767, 0x5aaa, 0xf013, 0xf001, 0xf000, 0x0fff, 0x7fff, 0xf124,                                            │
       │     0x0fff, 0x089a, 0x0578, 0x0fff, 0x089a, 0x0013, 0x0245, 0x0eff,                                            │
       │     0x0223, 0x0dde, 0x0135, 0x0789, 0x0ddd, 0xbbbc, 0xf346, 0x0467,                                            │
       │     0x0fff, 0x4eee, 0x3ddd, 0x0edd, 0x0dee, 0x0fff, 0x0fff, 0x0dee,                                            │
       │     0x0def, 0x08ab, 0x0fff, 0x7fff, 0xfabc, 0xf356, 0x0457, 0x0467,                                            │
       │     0x0fff, 0x0bcd, 0x4bde, 0x9bcc, 0x8dee, 0x8eff, 0x8fff, 0x9fff,                                            │
       │     0xadee, 0xeccd, 0xf689, 0xc357, 0x2356, 0x0356, 0x0467, 0x0467,                                            │
       │     0x0fff, 0x0ccd, 0x0bdd, 0x0cdd, 0x0aaa, 0x2234, 0x4135, 0x4346,                                            │
       │     0x5356, 0x2246, 0x0346, 0x0356, 0x0467, 0x0356, 0x0467, 0x0467,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff,                                            │
       │     0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0fff                                             │
       │   };                                                                                                           │
       │   surface = SDL_CreateRGBSurfaceFrom(pixels,16,16,16,16*2,0x0f00,0x00f0,0x000f,0xf000);                        │
       │                                                                                                                │
       │   // The icon is attached to the window pointer                                                                │
       │   SDL_SetWindowIcon(window, surface);                                                                          │
       │                                                                                                                │
       │   // ...and the surface containing the icon pixel data is no longer required.                                  │
       │   SDL_FreeSurface(surface);                                                                                    │
       │                                                                                                                │
       │   // Loop until the user closes the window or presses any key.                                                 │
       │   for( ; e.type != SDL_QUIT && e.type != SDL_KEYDOWN; SDL_PollEvent(&e));                                      │
       │                                                                                                                │
       │   SDL_DestroyWindow(window);   // Close and destroy the window.                                                │
       │   SDL_Quit();                  // Clean up and exit.                                                           │
       │   return 0;                                                                                                    │
       │ }                                                                                                              │
       └────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

===============================================================================
                                                      *SDL_SetWindowInputFocus*


NAME
       SDL_SetWindowInputFocus -- Function

SYNOPSIS
       Use this function to explicitly set input focus to the window.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_SetWindowInputFocus(SDL_Window*   window)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the  window  that should get │
       │         │ the input focus              │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       You almost certainly want SDL_RaiseWindow() instead of this function. Use this
       with caution, as you might give focus to a window that is completely  obscured
       by other windows.

       This function is only supported on X11.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_RaiseWindow

===============================================================================
                                                     *SDL_SetWindowMaximumSize*


NAME
       SDL_SetWindowMaximumSize -- Function

SYNOPSIS
       Use this function to set the maximum size of a window's client area.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ void SDL_SetWindowMaximumSize(SDL_Window*   window,  │
       │                               int           max_w,   │
       │                               int           max_h)   │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to change         │
       ├─────────┼──────────────────────────────┤
       │ max_w   │ the  maximum  width  of  the │
       │         │ window in pixels             │
       ├─────────┼──────────────────────────────┤
       │ max_h   │ the maximum  height  of  the │
       │         │ window in pixels             │
       └─────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetWindowMaximumSize
       SDL_SetWindowMinimumSize

===============================================================================
                                                     *SDL_SetWindowMinimumSize*


NAME
       SDL_SetWindowMinimumSize -- Function

SYNOPSIS
       Use this function to set the minimum size of a window's client area.

SYNTAX
       ┌──────────────────────────────────────────────────────┐
       │ void SDL_SetWindowMinimumSize(SDL_Window*   window,  │
       │                               int           min_w,   │
       │                               int           min_h)   │
       └──────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to change         │
       ├─────────┼──────────────────────────────┤
       │ min_w   │ the  minimum  width  of  the │
       │         │ window in pixels             │
       ├─────────┼──────────────────────────────┤
       │ min_h   │ the minimum  height  of  the │
       │         │ window in pixels             │
       └─────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetWindowMinimumSize
       SDL_SetWindowMaximumSize

===============================================================================
                                                        *SDL_SetWindowModalFor*


NAME
       SDL_SetWindowModalFor -- Function

SYNOPSIS
       Use this function to set the window as a modal for another window.

SYNTAX
       ┌─────────────────────────────────────────────────────────┐
       │ int SDL_SetWindowModalFor(SDL_Window*   modal_window,   │
       │                           SDL_Window*   parent_window)  │
       └─────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────────┬──────────────────────────────┐
       │ modal_window   │ the  window  that  should be │
       │                │ set modal                    │
       ├────────────────┼──────────────────────────────┤
       │ parent_window  │ the parent  window  for  the │
       │                │ modal window                 │
       └────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       This function is only supported on X11.

VERSION
       This function is available since SDL 2.0.5.

===============================================================================
                                                         *SDL_SetWindowOpacity*


NAME
       SDL_SetWindowOpacity -- Function

SYNOPSIS
       Use this function to set the opacity for a window.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ int SDL_SetWindowOpacity(SDL_Window*    window,   │
       │                          float          opacity)  │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ window   │ the  window  which  will  be │
       │          │ made transparent or opaque   │
       ├──────────┼──────────────────────────────┤
       │ opacity  │ the opacity  value  (0.0f  - │
       │          │ transparent, 1.0f - opaque)  │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       The parameter opacity will be clamped internally between 0.0 (transparent) and
       1.0f (opaque).

       This function also returns -1 if setting the opacity isn't supported.

       This  function is only supported on DirectFB, X11, Cocoa (Apple macOS) and Mi‐
       crosoft Windows.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_GetWindowOpacity

===============================================================================
                                                        *SDL_SetWindowPosition*


NAME
       SDL_SetWindowPosition -- Function

SYNOPSIS
       Use this function to set the position of a window.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_SetWindowPosition(SDL_Window*    window,  │
       │                            int            x,       │
       │                            int            y)       │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to reposition     │
       ├─────────┼──────────────────────────────┤
       │ x       │ the x coordinate of the win‐ │
       │         │ dow in screen coordinate, or │
       │         │ SDL_WINDOWPOS_CENTERED    or │
       │         │ SDL_WINDOWPOS_UNDEFINED      │
       ├─────────┼──────────────────────────────┤
       │ y       │ the y coordinate of the win‐ │
       │         │ dow in screen coordinate, or │
       │         │ SDL_WINDOWPOS_CENTERED    or │
       │         │ SDL_WINDOWPOS_UNDEFINED      │
       └─────────┴──────────────────────────────┘

REMARKS
       The window coordinate origin is the upper left of the display.

RELATED FUNCTIONS
       SDL_GetWindowPosition

===============================================================================
                                                       *SDL_SetWindowResizable*


NAME
       SDL_SetWindowResizable -- Function

SYNOPSIS
       Use this function to set the user-resizable state of a window.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ void SDL_SetWindowResizable(SDL_Window*   window,     │
       │                             SDL_bool      resizable)  │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬──────────────────────────────┐
       │ window     │ the   window   of  which  to │
       │            │ change the resizable state   │
       ├────────────┼──────────────────────────────┤
       │ resizable  │ SDL_TRUE to allow  resizing, │
       │            │ SDL_FALSE to disallow        │
       └────────────┴──────────────────────────────┘

REMARKS
       This  will add or remove the window's SDL_WINDOW_RESIZABLE flag and allow/dis‐
       allow user resizing of the window. This is a no-op if the  window's  resizable
       state already matches the requested state.

       Note: You can't change the resizable state of a fullscreen window.

VERSION
       This function is available since SDL 2.0.5.

RELATED FUNCTIONS
       SDL_GetWindowFlags

===============================================================================
                                                            *SDL_SetWindowSize*


NAME
       SDL_SetWindowSize -- Function

SYNOPSIS
       Use this function to set the size of a window's client area.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_SetWindowSize(SDL_Window*    window,  │
       │                        int            w,       │
       │                        int            h)       │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to change         │
       ├─────────┼──────────────────────────────┤
       │ w       │ the  width  of the window in │
       │         │ pixels,  in  screen  coordi‐ │
       │         │ nates, must be > 0           │
       ├─────────┼──────────────────────────────┤
       │ h       │ the  height of the window in │
       │         │ pixels,  in  screen  coordi‐ │
       │         │ nates, must be > 0           │
       └─────────┴──────────────────────────────┘

REMARKS
       The  window  size in screen coordinates may differ from the size in pixels, if
       the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with  high-
       dpi support (e.g. iOS or macOS x). Use SDL_GL_GetDrawableSize() or SDL_GetRen‐
       dererOutputSize() to get the real client area size in pixels.

       Fullscreen windows automatically match the size of the display mode,  and  you
       should use SDL_SetWindowDisplayMode() to change their size.

RELATED FUNCTIONS
       SDL_GetWindowSize
       SDL_SetWindowDisplayMode

===============================================================================
                                                           *SDL_SetWindowTitle*


NAME
       SDL_SetWindowTitle -- Function

SYNOPSIS
       Use this function to set the title of a window.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_SetWindowTitle(SDL_Window*   window,  │
       │                         const char*   title)   │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to change         │
       ├─────────┼──────────────────────────────┤
       │ title   │ the  desired window title in │
       │         │ UTF-8 format                 │
       └─────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
       │ // dynamically setting a window title                                                                                    │
       │                                                                                                                          │
       │ #include "SDL.h"                                                                                                         │
       │                                                                                                                          │
       │ int main(int argc, char* argv[]){                                                                                        │
       │                                                                                                                          │
       │   SDL_Window *window;                                                                                                    │
       │   SDL_Event e;                                                                                                           │
       │                                                                                                                          │
       │   const char *titles[] = { // just for fun, let's make the title animate like a marquee and annoy users                  │
       │     "t", "thi", "this w", "this win", "this windo", "this window's", "this window's ti", "this window's title",          │
       │     "chis window's title is", "chih window's title is ", "chih wandnw's title is ", "c  h wandnw'g title is ",           │
       │     "c  h  a  nw'g titln is ", "c  h  a  n  g  i  n ig ", "c  h  a  n  g  i  n  g!", "",                                 │
       │     "c  h  a  n  g  i  n  g!", "", "c  h  a  n  g  i  n  g!", "c  h  a  n  g  i  n  g!"                                  │
       │   };                                                                                                                     │
       │                                                                                                                          │
       │   SDL_Init(SDL_INIT_VIDEO); // Init SDL2                                                                                 │
       │                                                                                                                          │
       │   // Create a window.                                                                                                    │
       │   window = SDL_CreateWindow(                                                                                             │
       │     "This will surely be overwritten", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 320, 240, SDL_WINDOW_RESIZABLE  │
       │   );                                                                                                                     │
       │                                                                                                                          │
       │   // Enter the main loop. Press any key or hit the x to exit.                                                            │
       │   for( ; e.type!=SDL_QUIT&&e.type!=SDL_KEYDOWN; SDL_PollEvent(&e)){                                                      │
       │     static int i = 0, t = 0;                                                                                             │
       │                                                                                                                          │
       │     if(!(++t%9)){ // every 9th frame...                                                                                  │
       │       SDL_SetWindowTitle(window, titles[i]);            // loop through the                                              │
       │       if(++i >= sizeof(titles)/sizeof(titles[0])) i = 0; // array of titles                                              │
       │     }                                                                                                                    │
       │                                                                                                                          │
       │     SDL_Delay(10);                                                                                                       │
       │                                                                                                                          │
       │   }                                                                                                                      │
       │                                                                                                                          │
       │   SDL_DestroyWindow(window);                                                                                             │
       │   SDL_Quit();                                                                                                            │
       │   return 0;                                                                                                              │
       │ }                                                                                                                        │
       └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_GetWindowTitle

===============================================================================
                                                    *SDL_SetWindowsMessageHook*


NAME
       SDL_SetWindowsMessageHook -- Function

SYNOPSIS
       Use  this function to set a function that is called for every windows message,
       before TranslateMessage().

SYNTAX
       ┌────────────────────────────────────────────────────────────────────┐
       │ void SDL_SetWindowsMessageHook(SDL_WindowsMessageHook   callback,  │
       │                                void*                    userdata)  │
       └────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ callback  │ the function to call for ev‐ │
       │           │ ery message; see Remarks for │
       │           │ details                      │
       ├───────────┼──────────────────────────────┤
       │ userdata  │ a pointer that is passed  to │
       │           │ callback                     │
       └───────────┴──────────────────────────────┘

REMARKS
       This function is available on Microsoft Windows.

       The function prototype for callback is:

       ┌────────────────────────────────────────────────────────┐
       │ void SDL_WindowsMessageHook(void*           userdata,  │
       │                             void*           hWnd,      │
       │                             unsigned int    message,   │
       │                             Uint64          wParam,    │
       │                             Sint64          lParam)    │
       └────────────────────────────────────────────────────────┘
       where its parameters are:

       ┌───────────┬──────────────────────────────┐
       │ userdata  │ what  was passed as userdata │
       │           │ to    SDL_SetWindowsMessage‐ │
       │           │ Hook()                       │
       └───────────┴──────────────────────────────┘

VERSION
       This function is available since SDL 2.0.4.

===============================================================================
                                                               *SDL_ShowCursor*


NAME
       SDL_ShowCursor -- Function

SYNOPSIS
       Use this function to toggle whether or not the cursor is shown.

SYNTAX
       ┌────────────────────────────────────┐
       │ int SDL_ShowCursor(int    toggle)  │
       └────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ toggle  │ SDL_ENABLE  to show the cur‐ │
       │         │ sor, SDL_DISABLE to hide it, │
       │         │ SDL_QUERY  to query the cur‐ │
       │         │ rent state                   │
       └─────────┴──────────────────────────────┘

RETURN VALUE
       Returns SDL_ENABLE if the cursor is shown, or SDL_DISABLE  if  the  cursor  is
       hidden,  or a negative error code on failure; call SDL_GetError() for more in‐
       formation.

CODE EXAMPLES
       ┌───────────────────────────────────┐
       │ int main(int argc, char *argv[])  │
       │ {                                 │
       │   /* creates a blank cursor */    │
       │   SDL_ShowCursor(SDL_DISABLE);    │
       │   /* ... */                       │
       │   return 0;                       │
       │ }                                 │
       └───────────────────────────────────┘

REMARKS
       The cursor starts off displayed but can be turned off. Passing SDL_ENABLE dis‐
       plays the cursor and passing SDL_DISABLE hides it.

       The current state of the mouse cursor can be queried by passing SDL_QUERY; ei‐
       ther SDL_DISABLE or SDL_ENABLE will be returned.

       toggle may be any of the following:

       ┌─────┬───────────────┬───────────────────────┐
       │ -1  │  SDL_QUERY    │ returns  the  current │
       │     │               │ visibility   of   the │
       │     │               │ cursor                │
       ├─────┼───────────────┼───────────────────────┤
       │ 0   │  SDL_DISABLE  │ makes the cursor hid‐ │
       │     │               │ den  (also  a  return │
       │     │               │ value as to the  cur‐ │
       │     │               │ rent   state  of  the │
       │     │               │ cursor)               │
       ├─────┼───────────────┼───────────────────────┤
       │ 1   │  SDL_ENABLE   │ makes the cursor vis‐ │
       │     │               │ ible  (also  a return │
       │     │               │ value as to the  cur‐ │
       │     │               │ rent   state  of  the │
       │     │               │ cursor)               │
       └─────┴───────────────┴───────────────────────┘

RELATED FUNCTIONS
       SDL_CreateCursor
       SDL_SetCursor

===============================================================================
                                                           *SDL_ShowMessageBox*


NAME
       SDL_ShowMessageBox -- Function

SYNOPSIS
       Use this function to create a modal message box.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────┐
       │ int SDL_ShowMessageBox(const SDL_MessageBoxData*    messageboxdata,  │
       │                        int*                         buttonid)        │
       └──────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────────────┬──────────────────────────────┐
       │ messageboxdata  │ the       SDL_MessageBoxData │
       │                 │ structure with  title,  text │
       │                 │ and other options            │
       ├─────────────────┼──────────────────────────────┤
       │ buttonid        │ the pointer to which user id │
       │                 │ of  hit  button  should   be │
       │                 │ copied                       │
       └─────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                   │
       │                                                                    │
       │ int main(int argc, char *argv[])                                   │
       │ {                                                                  │
       │     const SDL_MessageBoxButtonData buttons[] = {                   │
       │         { /* .flags, .buttonid, .text */        0, 0, "no" },      │
       │         { SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT, 1, "yes" },     │
       │         { SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT, 2, "cancel" },  │
       │     };                                                             │
       │     const SDL_MessageBoxColorScheme colorScheme = {                │
       │         { /* .colors (.r, .g, .b) */                               │
       │             /* [SDL_MESSAGEBOX_COLOR_BACKGROUND] */                │
       │             { 255,   0,   0 },                                     │
       │             /* [SDL_MESSAGEBOX_COLOR_TEXT] */                      │
       │             {   0, 255,   0 },                                     │
       │             /* [SDL_MESSAGEBOX_COLOR_BUTTON_BORDER] */             │
       │             { 255, 255,   0 },                                     │
       │             /* [SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND] */         │
       │             {   0,   0, 255 },                                     │
       │             /* [SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED] */           │
       │             { 255,   0, 255 }                                      │
       │         }                                                          │
       │     };                                                             │
       │     const SDL_MessageBoxData messageboxdata = {                    │
       │         SDL_MESSAGEBOX_INFORMATION, /* .flags */                   │
       │         NULL, /* .window */                                        │
       │         "example message box", /* .title */                        │
       │         "select a button", /* .message */                          │
       │         SDL_arraysize(buttons), /* .numbuttons */                  │
       │         buttons, /* .buttons */                                    │
       │         &colorScheme /* .colorScheme */                            │
       │     };                                                             │
       │     int buttonid;                                                  │
       │     if (SDL_ShowMessageBox(&messageboxdata, &buttonid) < 0) {      │
       │         SDL_Log("error displaying message box");                   │
       │         return 1;                                                  │
       │     }                                                              │
       │     if (buttonid == -1) {                                          │
       │         SDL_Log("no selection");                                   │
       │     } else {                                                       │
       │         SDL_Log("selection was %s", buttons[buttonid].text);       │
       │     }                                                              │
       │     return 0;                                                      │
       │ }                                                                  │
       └────────────────────────────────────────────────────────────────────┘

REMARKS
       This function should be called on the thread that created the  parent  window,
       or on the main thread if the messagebox has no parent. It will block execution
       of that thread until the user clicks a button or closes the messagebox.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_ShowSimpleMessageBox

===============================================================================
                                                     *SDL_ShowSimpleMessageBox*


NAME
       SDL_ShowSimpleMessageBox -- Function

SYNOPSIS
       Use this function to display a simple modal message box.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ int SDL_ShowSimpleMessageBox(Uint32         flags,    │
       │                              const char*    title,    │
       │                              const char*    message,  │
       │                              SDL_Window*    window)   │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ flags    │ an  SDL_MessageBoxFlag;  see │
       │          │ Remarks for details          │
       ├──────────┼──────────────────────────────┤
       │ title    │ UTF-8 title text             │
       ├──────────┼──────────────────────────────┤
       │ message  │ UTF-8 message text           │
       ├──────────┼──────────────────────────────┤
       │ window   │ the parent window,  or  NULL │
       │          │ for no parent                │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────────┐
       │ SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR,                              │
       │                          "Missing file",                                    │
       │                          "File is missing. Please reinstall the program.",  │
       │                          NULL);                                             │
       └─────────────────────────────────────────────────────────────────────────────┘

REMARKS
       flags may be any of the following:

       ┌─────────────────────────────┬──────────────────────┐
       │ SDL_MESSAGE_ERROR           │ error dialog         │
       ├─────────────────────────────┼──────────────────────┤
       │ SDL_MESSAGEBOX_WARNING      │ warning dialog       │
       ├─────────────────────────────┼──────────────────────┤
       │ SDL_MESSAGEBOX_INFORMATION  │ informational dialog │
       └─────────────────────────────┴──────────────────────┘
       This function may be called at any time, even before SDL_Init(). This makes it
       useful for reporting errors like a failure to create a renderer or OpenGL con‐
       text.

       On X11, SDL rolls its own dialog box with X11 primitives instead of  a  formal
       toolkit like GTK+ or Qt.

       Note  that  if  SDL_Init()  would fail because there isn't any available video
       target, this function is likely to fail for the same reasons.  If  this  is  a
       concern, check the return value from this function and fall back to writing to
       stderr if you can.

===============================================================================
                                                               *SDL_ShowWindow*


NAME
       SDL_ShowWindow -- Function

SYNOPSIS
       Use this function to show a window.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_ShowWindow(SDL_Window*   window)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬────────────────────┐
       │ window  │ the window to show │
       └─────────┴────────────────────┘

REMARKS
       In SDL 1.2, you might have used BOOL WINAPI ShowWindow(_In_HWND hWnd, _In_ int
       nCmdShow) for Win32 builds. SDL_ShowWindow() replaces this.

RELATED FUNCTIONS
       SDL_HideWindow
       SDL_RaiseWindow

===============================================================================
                                                           *SDL_StartTextInput*


NAME
       SDL_StartTextInput -- Function

SYNOPSIS
       Use this function to start accepting Unicode text input events.

SYNTAX
       ┌────────────────────────────────┐
       │ void SDL_StartTextInput(void)  │
       └────────────────────────────────┘

REMARKS
       This  function  will  start accepting Unicode text input events in the focused
       SDL window, and  start  emitting  SDL_TEXTINPUT  and  SDL_TEXTEDITING  events.
       Please use this function in pair with SDL_StopTextInput().

       On some platforms using this function activates the screen keyboard.

       There is a tutorial (https://wiki.libsdl.org/Tutorials/TextInput).

RELATED FUNCTIONS
       SDL_SetTextInputRect
       SDL_StopTextInput

===============================================================================
                                                            *SDL_StopTextInput*


NAME
       SDL_StopTextInput -- Function

SYNOPSIS
       Use this function to stop receiving any text input events.

SYNTAX
       ┌───────────────────────────────┐
       │ void SDL_StopTextInput(void)  │
       └───────────────────────────────┘

REMARKS
       There is a tutorial (https://wiki.libsdl.org/Tutorials/TextInput).

RELATED FUNCTIONS
       SDL_StartTextInput

===============================================================================
                                                                  *SDL_Surface*


NAME
       SDL_Surface -- Structure

SYNOPSIS
       A structure that contains a collection of pixels used in software blitting.

DATA FIELDS
       ┌───────────────────┬───────────┬───────────────────────┐
       │ Uint32            │ flags     │ (internal use)        │
       ├───────────────────┼───────────┼───────────────────────┤
       │ SDL_PixelFormat*  │ format    │ the   format  of  the │
       │                   │           │ pixels stored in  the │
       │                   │           │ surface; see SDL_Pix‐ │
       │                   │           │ elFormat for  details │
       │                   │           │ (read-only)           │
       ├───────────────────┼───────────┼───────────────────────┤
       │ int               │ w, h      │ the  width and height │
       │                   │           │ in pixels (read-only) │
       ├───────────────────┼───────────┼───────────────────────┤
       │ int               │ pitch     │ the length of  a  row │
       │                   │           │ of  pixels  in  bytes │
       │                   │           │ (read-only)           │
       ├───────────────────┼───────────┼───────────────────────┤
       │ void*             │ pixels    │ the  pointer  to  the │
       │                   │           │ actual   pixel  data; │
       │                   │           │ see Remarks  for  de‐ │
       │                   │           │ tails (read-write)    │
       ├───────────────────┼───────────┼───────────────────────┤
       │ void*             │ userdata  │ an  arbitrary pointer │
       │                   │           │ you  can  set  (read- │
       │                   │           │ write)                │
       ├───────────────────┼───────────┼───────────────────────┤
       │ int               │ locked    │ used   for   surfaces │
       │                   │           │ that require  locking │
       │                   │           │ (internal use)        │
       ├───────────────────┼───────────┼───────────────────────┤
       │ void*             │ lock_data │ used for surface that │
       │                   │           │ require locking  (in‐ │
       │                   │           │ ternal use)           │
       ├───────────────────┼───────────┼───────────────────────┤
       │ SDL_Rect          │ clip_rect │ an SDL_Rect structure │
       │                   │           │ used to clip blits to │
       │                   │           │ the surface which can │
       │                   │           │ be  set  by   DL_Set‐ │
       │                   │           │ ClipRect()     (read- │
       │                   │           │ only)                 │
       ├───────────────────┼───────────┼───────────────────────┤
       │ SDL_BlitMap*      │ map       │ info  for  fast  blit │
       │                   │           │ mapping to other sur‐ │
       │                   │           │ faces (internal use)  │
       ├───────────────────┼───────────┼───────────────────────┤
       │ int               │ refcount  │ reference count  that │
       │                   │           │ can be incremented by │
       │                   │           │ the application       │
       └───────────────────┴───────────┴───────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────────┐
       │ /* This is meant to show how to edit a surface's pixels on the CPU,          │
       │ but normally you should use SDL_FillRect() to wipe a surface's contents. */  │
       │ void WipeSurface(SDL_Surface *surface)                                       │
       │ {                                                                            │
       │   /* This is fast for surfaces that don't require locking. */                │
       │   /* Once locked, surface->pixels is safe to process. */                     │
       │   SDL_LockSurface(surface);                                                  │
       │                                                                              │
       │   /* This assumes that color value zero is black. Use                        │
       │      SDL_MapRGBA() for more robust surface color mapping! */                 │
       │   /* height times pitch is the size of the surface's whole buffer. */        │
       │   SDL_memset(surface->pixels, 0, surface->h * surface->pitch);               │
       │                                                                              │
       │   SDL_UnlockSurface(surface);                                                │
       │ }                                                                            │
       └──────────────────────────────────────────────────────────────────────────────┘

REMARKS
       With most surfaces you can access the pixels directly. Surfaces that have been
       optimized with SDL_SetSurfaceRLE() should be locked with SDL_LockSurface() be‐
       fore accessing pixels. When you are done you should  call  SDL_UnlockSurface()
       before blitting.

RELATED FUNCTIONS
       SDL_BlitSurface
       SDL_ConvertSurface
       SDL_CreateRGBSurface
       SDL_CreateRGBSurfaceFrom
       SDL_FillRect
       SDL_FillRects
       SDL_FreeSurface
       SDL_GetClipRect
       SDL_GetColorKey
       SDL_GetSurfaceAlphaMod
       SDL_GetSurfaceBlendMode
       SDL_GetSurfaceColorMod
       SDL_LoadBMP_RW
       SDL_LockSurface
       SDL_LowerBlit
       SDL_MUSTLOCK
       SDL_SaveBMP_RW
       SDL_SetClipRect
       SDL_SetColorKey
       SDL_SetSurfaceAlphaMod
       SDL_SetSurfaceBlendMode
       SDL_SetSurfaceColorMod
       SDL_SetSurfacePalette
       SDL_SetSurfaceRLE
       SDL_SoftStretch
       SDL_UnlockSurface

===============================================================================
                                                                   *SDL_Swap16*


NAME
       SDL_Swap16 -- Function

SYNOPSIS
       Use this function to swap the byte order of a 16-bit value.

SYNTAX
       ┌─────────────────────────────────┐
       │ Uint16 SDL_Swap16(Uint16    x)  │
       └─────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the swapped value.

RELATED FUNCTIONS
       SDL_SwapBE16
       SDL_SwapLE16

===============================================================================
                                                                   *SDL_Swap32*


NAME
       SDL_Swap32 -- Function

SYNOPSIS
       Use this function to swap the byte order of a 32-bit value.

SYNTAX
       ┌─────────────────────────────────┐
       │ Uint32 SDL_Swap32(Uint32    x)  │
       └─────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the swapped value.

RELATED FUNCTIONS
       SDL_SwapBE32
       SDL_SwapLE32

===============================================================================
                                                                   *SDL_Swap64*


NAME
       SDL_Swap64 -- Function

SYNOPSIS
       Use this function to swap the byte order of a 64-bit value.

SYNTAX
       ┌─────────────────────────────────┐
       │ Uint64 SDL_Swap64(Uint64    x)  │
       └─────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the swapped value.

RELATED FUNCTIONS
       SDL_SwapBE64
       SDL_SwapLE64

===============================================================================
                                                                 *SDL_SwapBE16*


NAME
       SDL_SwapBE16 -- Function

SYNOPSIS
       Use  this  function to swap the byte order of a 16-bit big-endian value to na‐
       tive ordering.

SYNTAX
       ┌───────────────────────────────────┐
       │ Uint16 SDL_SwapBE16(Uint16    x)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the native 16-bit value.

RELATED FUNCTIONS
       SDL_Swap16
       SDL_SwapLE16

===============================================================================
                                                                 *SDL_SwapBE32*


NAME
       SDL_SwapBE32 -- Function

SYNOPSIS
       Use  this  function to swap the byte order of a 32-bit big-endian value to na‐
       tive ordering.

SYNTAX
       ┌───────────────────────────────────┐
       │ Uint32 SDL_SwapBE32(Uint32    x)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the native 32-bit value.

RELATED FUNCTIONS
       SDL_Swap32
       SDL_SwapLE32

===============================================================================
                                                                 *SDL_SwapBE64*


NAME
       SDL_SwapBE64 -- Function

SYNOPSIS
       Use  this  function to swap the byte order of a 64-bit big-endian value to na‐
       tive ordering.

SYNTAX
       ┌───────────────────────────────────┐
       │ Uint64 SDL_SwapBE64(Uint64    x)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the native 64-bit value.

RELATED FUNCTIONS
       SDL_Swap64
       SDL_SwapLE64

===============================================================================
                                                                *SDL_SwapFloat*


NAME
       SDL_SwapFloat -- Function

SYNOPSIS
       Use this function to swap the byte order of a floating point value.

SYNTAX
       ┌─────────────────────────────────┐
       │ float SDL_SwapFloat(float   x)  │
       └─────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the swapped value.

RELATED FUNCTIONS
       SDL_SwapFloatBE
       SDL_SwapFloatLE

===============================================================================
                                                              *SDL_SwapFloatBE*


NAME
       SDL_SwapFloatBE -- Function

SYNOPSIS
       Use  this function to swap the byte order of a big-endian floating point value
       to native ordering.

SYNTAX
       ┌───────────────────────────────────┐
       │ float SDL_SwapFloatBE(float   x)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the native floating point value.

RELATED FUNCTIONS
       SDL_SwapFloat
       SDL_SwapFloatLE

===============================================================================
                                                              *SDL_SwapFloatLE*


NAME
       SDL_SwapFloatLE -- Function

SYNOPSIS
       Use  this  function  to  swap the byte order of a little-endian floating point
       value to native ordering.

SYNTAX
       ┌───────────────────────────────────┐
       │ float SDL_SwapFloatLE(float   x)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the native floating point value.

RELATED FUNCTIONS
       SDL_SwapFloat
       SDL_SwapFloatBE

===============================================================================
                                                                 *SDL_SwapLE16*


NAME
       SDL_SwapLE16 -- Function

SYNOPSIS
       Use  this  function  to swap the byte order of a 16-bit little-endian value to
       native ordering.

SYNTAX
       ┌───────────────────────────────────┐
       │ Uint16 SDL_SwapLE16(Uint16    x)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the native 16-bit value.

RELATED FUNCTIONS
       SDL_Swap16
       SDL_SwapBE16

===============================================================================
                                                                 *SDL_SwapLE32*


NAME
       SDL_SwapLE32 -- Function

SYNOPSIS
       Use  this  function  to swap the byte order of a 32-bit little-endian value to
       native ordering.

SYNTAX
       ┌───────────────────────────────────┐
       │ Uint32 SDL_SwapLE32(Uint32    x)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the native 32-bit value.

RELATED FUNCTIONS
       SDL_Swap32
       SDL_SwapBE32

===============================================================================
                                                                 *SDL_SwapLE64*


NAME
       SDL_SwapLE64 -- Function

SYNOPSIS
       Use  this  function  to swap the byte order of a 64-bit little-endian value to
       native ordering.

SYNTAX
       ┌───────────────────────────────────┐
       │ Uint64 SDL_SwapLE64(Uint64    x)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ x  │ the value to be swapped │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns the native 64-bit value.

RELATED FUNCTIONS
       SDL_Swap64
       SDL_SwapBE64

===============================================================================
                                                               *SDL_SysWMEvent*


NAME
       SDL_SysWMEvent -- Structure

SYNOPSIS
       A structure that contains a video driver dependent system event.

DATA FIELDS
       ┌──────────────────┬───────────┬───────────────────────┐
       │ Uint32           │ type      │ SDL_SYSWMEVENT        │
       ├──────────────────┼───────────┼───────────────────────┤
       │ Uint32           │ timestamp │ timestamp    of   the │
       │                  │           │ event                 │
       ├──────────────────┼───────────┼───────────────────────┤
       │ SDL_SysWMEvent*  │ msg       │ driver      dependent │
       │                  │           │ data,    defined   in │
       │                  │           │ SDL_syswm.h           │
       └──────────────────┴───────────┴───────────────────────┘

REMARKS
       This event is disabled by default. You can enable  it  with  SDL_EventState().
       You  are encouraged to avoid this if you can find a less platform-specific way
       to accomplish your goals.

       If you want to use this event you should include SDL_syswm.h and  have  access
       to the appropriate system headers.

       SDL_SysWMEvent is a member of the SDL_Event union and is used when an event of
       type SDL_SYSWMEVENT is reported. You would access it through the event's syswm
       field.

       If you want to obtain system-specific information about the window manager you
       can fill in the  version  member  of  an  SDL_SysWMinfo  structure  using  the
       SDL_VERSION()  macro  found  in  SDL_version.h,  and  pass  it to the function
       SDL_GetWindowWMInfo().

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_SysWMinfo
       SDL_SysWMmsg

RELATED FUNCTIONS
       SDL_EventState
       SDL_GetWindowWMInfo

===============================================================================
                                                                *SDL_SysWMInfo*


NAME
       SDL_SysWMinfo -- Structure

SYNOPSIS
       A structure that contains system-dependent information about a window.

DATA FIELDS
       ┌──────────────────────────────────────────────────────────────────────────┐
       │                             All Subsystems                               │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ SDL_version           │ version                  │ an SDL_version struc‐ │
       │                       │                          │ ture  that   contains │
       │                       │                          │ the  current SDL ver‐ │
       │                       │                          │ sion                  │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ SDL_SYSWM_TYPE        │ subsystem                │ the windowing  system │
       │                       │                          │ type; see Remarks for │
       │                       │                          │ details               │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ int                   │ dummy                    │ unused (to help  com‐ │
       │                       │                          │ pilers  when  no spe‐ │
       │                       │                          │ cific    system    is │
       │                       │                          │ available)            │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                            SDL_SYSWM_WINDOWS                             │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ HWND                  │ win.window               │ the window handle     │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ HDC                   │ win.hdc                  │ the   window   device │
       │                       │                          │ context    (>=    SDL │
       │                       │                          │ 2.0.4)                │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ HINSTANCE             │ win.hinstance            │ the  window hinstance │
       │                       │                          │ (>= SDL 2.0.6)        │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                     SDL_SYSWM_WINRT (>= SDL 2.0.3)                       │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ IInspectable*         │ winrt.window             │ the WinRT CoreWindow  │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                              SDL_SYSWM_X11                               │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ Display*              │ x11.display              │ the X11 display       │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ Window                │ x11.window               │ the X11 window        │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                           SDL_SYSWM_DIRECTFB                             │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ IDirectFB*            │ dfb.dfb                  │ the DirectFB main in‐ │
       │                       │                          │ terface               │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ IDirectFBWindow*      │ dfb.window               │ the  DirectFB  window │
       │                       │                          │ handle                │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ IDirectFBSurface*     │ dfb.surface              │ the  DirectFB  client │
       │                       │                          │ surface               │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                             SDL_SYSWM_COCOA                              │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ NSWindow*             │ cocoa.window             │ the Cocoa window      │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                             SDL_SYSWM_UIKIT                              │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ UIWindow*             │ uikit.window             │ the UIKit window      │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ GLuint                │ uikit.framebuffer        │ the  GL view's Frame‐ │
       │                       │                          │ buffer   Object;   it │
       │                       │                          │ must  be  bound  when │
       │                       │                          │ rendering   to    the │
       │                       │                          │ screen  using  GL (>= │
       │                       │                          │ SDL 2.0.4)            │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ GLuint                │ uikit.colorbuffer        │ the GL  view's  color │
       │                       │                          │ Renderbuffer  Object; │
       │                       │                          │ it must be bound when │
       │                       │                          │ SDL_GL_SwapWindow()   │
       │                       │                          │ is  called  (>=   SDL │
       │                       │                          │ 2.0.4)                │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ GLuint                │ uikit.resolveFramebuffer │ the  Framebuffer  Ob‐ │
       │                       │                          │ ject which holds  the │
       │                       │                          │ resolve color Render‐ │
       │                       │                          │ buffer, when MSAA  is │
       │                       │                          │ used (>= SDL 2.0.4)   │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                    SDL_SYSWM_WAYLAND (>= SDL 2.0.2)                      │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ wl_display*           │ wl.display               │ the Wayland display   │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ wl_surface*           │ wl.surface               │ the Wayland surface   │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ wl_shell_surface*     │ wl.shell_surface         │ the           Wayland │
       │                       │                          │ shell_surface (window │
       │                       │                          │ manager handle)       │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                      SDL_SYSWM_MIR (>= SDL 2.0.2)                        │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ MirConnection*        │ mir.connection           │ the    Mir    display │
       │                       │                          │ server connection     │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ MirSurface*           │ mir.surface              │ the Mir surface       │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                    SDL_SYSWM_ANDROID (>= SDL 2.0.4)                      │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ ANativeWindow*        │ android.window           │ the  Android   native │
       │                       │                          │ window                │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ EGLSurface            │ android.surface          │ the  Android EGL sur‐ │
       │                       │                          │ face                  │
       ├───────────────────────┴──────────────────────────┴───────────────────────┤
       │                    SDL_SYSWM_VIVANTE (>= SDL 2.0.5)                      │
       ├───────────────────────┬──────────────────────────┬───────────────────────┤
       │ EGLNativeDisplayType  │ vivante.display          │ the Vivante EGL  dis‐ │
       │                       │                          │ play type             │
       ├───────────────────────┼──────────────────────────┼───────────────────────┤
       │ EGLNativeWindowType   │ vivante.window           │ theh Vivante EGL win‐ │
       │                       │                          │ dow type              │
       └───────────────────────┴──────────────────────────┴───────────────────────┘

REMARKS
       This structure is filled in by SDL_GetWindowWMInfo().

       This structure holds love level information about the window and subsystem  is
       set to the windowing system in use, one of:

       ┌─────────────────────┬──────────────────────────────┐
       │ SDL_SYSWM_UNKNOWN   │                              │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_WINDOWS   │ Microsoft Windows            │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_X11       │ X Window System              │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_DIRECTFB  │ DirectFB (see http://www.di‐ │
       │                     │ rectfb.net/)                 │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_COCOA     │ Apple macOS                  │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_UIKIT     │ Apple iOS                    │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_WAYLAND   │ Wayland (>= SDL 2.0.2)       │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_MIR       │ Mir (>= SDL 2.0.2)           │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_WINRT     │ WinRT (>= SDL 2.0.3)         │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_ANDROID   │ Android (>= SDL 2.0.4)       │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_VIVANTE   │ Vivante (>= SDL 2.0.5)       │
       └─────────────────────┴──────────────────────────────┘

RELATED ENUMERATIONS
       SDL_SYSWM_TYPE

RELATED STRUCTURES
       SDL_version

RELATED FUNCTIONS
       SDL_GetWindowWMInfo

===============================================================================
                                                                 *SDL_SysWMmsg*


NAME
       SDL_SysWMmsg -- Structure

SYNOPSIS
       A structure that contains system-dependent window manager messages.

DATA FIELDS
       ┌─────────────────────────────────────────────────────────┐
       │                     All Subsystems                      │
       ├─────────────────┬───────────────┬───────────────────────┤
       │ SDL_version     │ version       │ an SDL_version struc‐ │
       │                 │               │ ture  that   contains │
       │                 │               │ the  current SDL ver‐ │
       │                 │               │ sion                  │
       ├─────────────────┼───────────────┼───────────────────────┤
       │ SDL_SYSWM_TYPE  │ subsystem     │ the windowing  system │
       │                 │               │ type; see Remarks for │
       │                 │               │ details               │
       ├─────────────────┼───────────────┼───────────────────────┤
       │ int             │ dummy         │ unused (to help  com‐ │
       │                 │               │ pilers  when  no spe‐ │
       │                 │               │ cific    system    is │
       │                 │               │ available)            │
       ├─────────────────┴───────────────┴───────────────────────┤
       │                   SDL_SYSWM_WINDOWS                     │
       ├─────────────────┬───────────────┬───────────────────────┤
       │ HWND            │ win.window    │ the  window  for  the │
       │                 │               │ message               │
       ├─────────────────┼───────────────┼───────────────────────┤
       │ UINT            │ win.msg       │ the type of message   │
       ├─────────────────┼───────────────┼───────────────────────┤
       │ WPARAM          │ win.wParam    │ WORD message  parame‐ │
       │                 │               │ ter                   │
       ├─────────────────┼───────────────┼───────────────────────┤
       │ LPARAM          │ win.lParam    │ LONG  message parame‐ │
       │                 │               │ ter                   │
       ├─────────────────┴───────────────┴───────────────────────┤
       │                     SDL_SYSWM_X11                       │
       ├─────────────────┬───────────────┬───────────────────────┤
       │ XEvent          │ x11.event     │ the native x11  event │
       │                 │               │ structure             │
       ├─────────────────┴───────────────┴───────────────────────┤
       │                   SDL_SYSWM_DIRECTFB                    │
       ├─────────────────┬───────────────┬───────────────────────┤
       │ DFBEvent        │ dfb.event     │ the DirectFB event    │
       ├─────────────────┴───────────────┴───────────────────────┤
       │                    SDL_SYSWM_COCOA                      │
       ├─────────────────┬───────────────┬───────────────────────┤
       │ int             │ cocoa.dummy   │ unused (>= SDL 2.0.4) │
       ├─────────────────┴───────────────┴───────────────────────┤
       │                    SDL_SYSWM_UIKIT                      │
       ├─────────────────┬───────────────┬───────────────────────┤
       │ int             │ uikit.dummy   │ unused (>= SDL 2.0.4) │
       ├─────────────────┴───────────────┴───────────────────────┤
       │                   SDL_SYSWM_VIVANTE                     │
       ├─────────────────┬───────────────┬───────────────────────┤
       │ int             │ vivante.dummy │ unused (>= SDL 2.0.5) │
       └─────────────────┴───────────────┴───────────────────────┘

REMARKS
       subsystem may be one of the following:

       ┌─────────────────────┬──────────────────────────────┐
       │ SDL_SYSWM_UNKNOWN   │                              │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_WINDOWS   │ Microsoft Windows            │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_X11       │ X Window System              │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_DIRECTFB  │ DirectFB (see http://www.di‐ │
       │                     │ rectfb.net/)                 │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_COCOA     │ Apple macOS                  │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_UIKIT     │ Apple iOS                    │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_WAYLAND   │ Wayland (>= SDL 2.0.2)       │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_MIR       │ Mir (>= SDL 2.0.2)           │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_WINRT     │ WinRT (>= SDL 2.0.3)         │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_ANDROID   │ Android (>= SDL 2.0.4)       │
       ├─────────────────────┼──────────────────────────────┤
       │ SDL_SYSWM_VIVANTE   │ Vivante (>= SDL 2.0.5)       │
       └─────────────────────┴──────────────────────────────┘
       There are currently no Cocoa or UIKit window events.

RELATED ENUMERATIONS
       SDL_SYSWM_TYPE

RELATED STRUCTURES
       SDL_version

===============================================================================
                                                             *SDL_TICKS_PASSED*


NAME
       SDL_TICKS_PASSED -- Macro

SYNOPSIS
       Use this macro to compare SDL ticks values.

SYNTAX
       ┌─────────────────────────┐
       │ SDL_TICKS_PASSED(A, B)  │
       └─────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────┐
       │ A  │ the first ticks values  │
       ├────┼─────────────────────────┤
       │ B  │ the second ticks values │
       └────┴─────────────────────────┘

RETURN VALUE
       Returns "true" if A has passed B.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────┐
       │ /* if you want to wait 100ms, you could do this: */  │
       │ Uint32 timeout = SDL_GetTicks() + 100;               │
       │ while (!SDL_TICKS_PASSED(SDL_GetTicks(), timeout))   │
       │ {                                                    │
       │   /* ... do work until timeout has elapsed           │
       │ }                                                    │
       └──────────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.1.

RELATED FUNCTIONS
       SDL_GetTicks()

===============================================================================
                                                                *SDL_TLSCreate*


NAME
       SDL_TLSCreate -- Function

SYNOPSIS
       Use  this  function  to  create  an identifier that is globally visible to all
       threads but refers to data that is thread-specific.

SYNTAX
       ┌────────────────────────────────┐
       │ SDL_TLSID SDL_TLSCreate(void)  │
       └────────────────────────────────┘

RETURN VALUE
       Returns the newly created thread local storage identifier or 0 on error.

CODE EXAMPLES
       ┌────────────────────────────────────────────────┐
       │ static SDL_SpinLock tls_lock;                  │
       │ static SDL_TLSID thread_local_storage;         │
       │                                                │
       │ void SetMyThreadData(void *value)              │
       │ {                                              │
       │   if (!thread_local_storage)                   │
       │   {                                            │
       │     SDL_AtomicLock(&tls_lock);                 │
       │     if (!thread_local_storage)                 │
       │     {                                          │
       │       thread_local_storage = SDL_TLSCreate();  │
       │     }                                          │
       │     SDL_AtomicUnlock(&tls_lock);               │
       │   }                                            │
       │   SDL_TLSSet(thread_local_storage, value, 0);  │
       │ }                                              │
       │                                                │
       │ void *GetMyThreadData(void)                    │
       │ {                                              │
       │   return SDL_TLSGet(thread_local_storage);     │
       │ }                                              │
       └────────────────────────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_TLSGet
       SDL_TLSSet

===============================================================================
                                                                   *SDL_TLSGet*


NAME
       SDL_TLSGet -- Function

SYNOPSIS
       Use  this  function to get the value associated with a thread local storage ID
       for the current thread.

SYNTAX
       ┌────────────────────────────────────┐
       │ void* SDL_TLSGet(SDL_TLSID    id)  │
       └────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────┬─────────────────────────────┐
       │ id  │ the thread local storage ID │
       └─────┴─────────────────────────────┘

RETURN VALUE
       Returns the value associated with the ID for the current thread or NULL if  no
       value has been set; call SDL_GetError() for more information.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_TLSCreate
       SDL_TLSSet

===============================================================================
                                                                   *SDL_TLSSet*


NAME
       SDL_TLSSet -- Function

SYNOPSIS
       Use  this  function to set the value associated with a thread local storage ID
       for the current thread.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ int SDL_TLSSet(SDL_TLSID      id,           │
       │                const void*    value,        │
       │                void (*destructor) (void*))  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       The function prototype for destructor is:

       ┌───────────────────────────────┐
       │ void destructor(void* value)  │
       └───────────────────────────────┘
       where its parameters are:

       ┌────────┬──────────────────────────────┐
       │ value  │ what  was passed as value to │
       │        │ SDL_TLSSet()                 │
       └────────┴──────────────────────────────┘

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_TLSCreate
       SDL_TLSGet

===============================================================================
                                                         *SDL_TextEditingEvent*


NAME
       SDL_TextEditingEvent -- Structure

SYNOPSIS
       A structure that contains keyboard text editing event information.

DATA FIELDS
       ┌───────────┬───────────┬───────────────────────┐
       │ Uint32    │ type      │ SDL_TEXTEDITING       │
       ├───────────┼───────────┼───────────────────────┤
       │ Uint32    │ timestamp │ timestamp    of   the │
       │           │           │ event                 │
       ├───────────┼───────────┼───────────────────────┤
       │ Uint32    │ windowID  │ the window with  key‐ │
       │           │           │ board focus, if any   │
       ├───────────┼───────────┼───────────────────────┤
       │ char[32]  │ text      │ the   null-terminated │
       │           │           │ editing text in UTF-8 │
       │           │           │ encoding              │
       ├───────────┼───────────┼───────────────────────┤
       │ Sint32    │ start     │ the location to begin │
       │           │           │ editing from          │
       ├───────────┼───────────┼───────────────────────┤
       │ Sint32    │ length    │ the number of charac‐ │
       │           │           │ ters to edit from the │
       │           │           │ start point           │
       └───────────┴───────────┴───────────────────────┘

REMARKS
       SDL_TextEditingEvent is a member of the SDL_Event union and is  used  when  an
       event  of  type  SDL_TEXTEDITING  is reported. You would access it through the
       event's edit field.

       There is a tutorial (see https://wiki.libsdl.org/Tutorials/TextInput).

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_TextInputEvent

RELATED FUNCTIONS
       SDL_StarTextInput
       SDL_StopTextInput

===============================================================================
                                                           *SDL_TextInputEvent*


NAME
       SDL_TextInputEvent -- Structure

SYNOPSIS
       A structure that contains keyboard text input event information.

DATA FIELDS
       ┌───────────┬───────────┬───────────────────────┐
       │ Uint32    │ type      │ SDL_TEXTINPUT         │
       ├───────────┼───────────┼───────────────────────┤
       │ Uint32    │ timestamp │ timestamp    of   the │
       │           │           │ event                 │
       ├───────────┼───────────┼───────────────────────┤
       │ Uint32    │ windowID  │ the window with  key‐ │
       │           │           │ board focus, if any   │
       ├───────────┼───────────┼───────────────────────┤
       │ char[32]  │ text      │ the   null-terminated │
       │           │           │ input text  in  UTF-8 │
       │           │           │ encoding              │
       └───────────┴───────────┴───────────────────────┘

REMARKS
       SDL_TextInputEvent  is  a  member  of  the SDL_Event union and is used when an
       event of type SDL_TEXTINPUT is reported.  You  would  access  it  through  the
       event's text field.

       There is a tutorial (see https://wiki.libsdl.org/Tutorials/TextInput).

       Detailed   explanation   (from   SDL   mailing   list  (see  http://lists.lib‐
       sdl.org/pipermail/sdl-libsdl.org/2013-August/090073.html by Jiang Jiang <gzjj‐
       god at gmail.com>)

       ┌─────────────────────────────────────────────────────────────────────────┐
       │ In a typical GUI application, the OS will be responsible for telling    │
       │ you the candidate text (via SDL_TEXTEDITING), you can choose how (and   │
       │ where) to show it in your UI.                                           │
       │ Let's say with an input method I typed "abc" and got unicode character  │
       │ "X", the SDL application will first receive three SDL_TEXTEDITING       │
       │ events with 'a', 'ab' and 'abc', then finally receive SDL_TEXTINPUT     │
       │ event with unicode character 'X'.                                       │
       │ During this text compositing process, user can press any arbitrary      │
       │ keys such as Function, backspace, both the SDL application and OS       │
       │ input method will receive it and decide whether to deal with these      │
       │ keys or not. For instance when user press backspace, most input         │
       │ methods will delete the last candidate character typed and SDL app      │
       │ will receive a new SDL_TEXTEDITING event (let's say user typed a, b,    │
       │ backspace, c, then the application will receive 4 events containing     │
       │                                                                         │
       │ [[SDL_SetTextInputRect]]() gives the OS a hint for where to show the    │
       │ candidate text list, since the OS doesn't know where you want to draw   │
       │ the text you received via SDL_TEXTEDITING event.                        │
       └─────────────────────────────────────────────────────────────────────────┘

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event
       SDL_TextEditingEvent

RELATED FUNCTIONS
       SDL_StartTextInput
       SDL_StopTextInput

===============================================================================
                                                                  *SDL_Texture*


NAME
       SDL_Texture -- Structure

SYNOPSIS
       A  structure  that  contains  an  efficient, driver-specific representation of
       pixel data.

RELATED FUNCTIONS
       |SDL_CreateTexture| |SDL_CreateTextureFromSurface| |SDL_DestroyTexture|
       |SDL_GetTextureAlphaMod| |SDL_GetTextureBlendMode| |SDL_GetTextureColorMod|
       |SDL_LockTexture| |SDL_QueryTexture| |SDL_RenderCopy|
       |SDL_SetTextureAlphaMod| |SDL_SetTextureBlendMode| |SDL_SetTextureColorMod|
       |SDL_UnlockTexture| |SDL_UpdateTexture|

===============================================================================
                                                            *SDL_TextureAccess*


NAME
       SDL_TextureAccess -- Enumerations

SYNOPSIS
       An enumeration of texture access patterns.

DESCRIPTION
       Values

       ┌──────────────────────────────┬──────────────────────────────┐
       │ SDL_TEXTUREACCESS_STATIC     │ changes rarely, not lockable │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_TEXTUREACCESS_STREAMING  │ changes frequently, lockable │
       ├──────────────────────────────┼──────────────────────────────┤
       │ SDL_TEXTUREACCESS_TARGET     │ can be used as a render tar‐ │
       │                              │ get                          │
       └──────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_CreateTexture
       SDL_LockTexture
       SDL_QueryTexture

===============================================================================
                                                          *SDL_TextureModulate*


NAME
       SDL_TextureModulate -- Enumerations

SYNOPSIS
       An enumeration of the texture channel modulation used in SDL_RenderCopy().

DESCRIPTION
       Values

       ┌────────────────────────────┬─────────────────────┐
       │ SDL_TEXTUREMODULATE_NONE   │ no modulation       │
       ├────────────────────────────┼─────────────────────┤
       │ SDL_TEXTUREMODULATE_COLOR  │ srcC = srcC * color │
       ├────────────────────────────┼─────────────────────┤
       │ SDL_TEXTUREMODULATE_ALPHA  │ srcA = srcA * alpha │
       └────────────────────────────┴─────────────────────┘

RELATED STRUCTURES
       SDL_RendererInfo

RELATED FUNCTIONS
       SDL_RenderCopy

===============================================================================
                                                                 *SDL_ThreadID*


NAME
       SDL_ThreadID -- Function

SYNOPSIS
       Use this function to get the thread identifier for the current thread.

SYNTAX
       ┌──────────────────────────────────┐
       │ SDL_ThreadID SDL_ThreadID(void)  │
       └──────────────────────────────────┘

RETURN VALUE
       Returns the ID of the current thread.

CODE EXAMPLES
       ┌────────────────────────────────────────────────┐
       │ SDL_ThreadID  threadID;                        │
       │                                                │
       │ /* Retrieve our current thread identitifer */  │
       │ threadID = SDL_ThreadID();                     │
       └────────────────────────────────────────────────┘

REMARKS
       This  thread  identifier is as reported by the underlying operating system. If
       SDL is running on a platform that does not support threads, the  return  value
       will always be zero.

       This function also returns a valid thread ID when called from the main thread.

RELATED FUNCTIONS
       SDL_GetThreadID

===============================================================================
                                                           *SDL_ThreadPriority*


NAME
       SDL_ThreadPriority -- Enumerations

SYNOPSIS
       An enumeration of the available thread priorities.

DESCRIPTION
       Values

       ┌─────────────────────────────┬──────────────────────────────┐
       │ SDL_THREAD_PRIORITY_LOW     │ for  non-urgent,  background │
       │                             │ processing                   │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_THREAD_PRIORITY_NORMAL  │ for general purpose process‐ │
       │                             │ ing (default)                │
       ├─────────────────────────────┼──────────────────────────────┤
       │ SDL_THREAD_PRIORITY_HIGH    │ for timing-critical process‐ │
       │                             │ ing                          │
       └─────────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_SetThreadPriority

===============================================================================
                                                         *SDL_TouchFingerEvent*


NAME
       SDL_TouchFingerEvent -- Structure

SYNOPSIS
       A structure that contains finger touch event information.

DATA FIELDS
       ┌───────────────┬───────────┬───────────────────────┐
       │ Uint32        │ type      │ SDL_FINGERMOTION,     │
       │               │           │ SDL_FINGERDOWN,    or │
       │               │           │ SDL_FINGERUP          │
       ├───────────────┼───────────┼───────────────────────┤
       │ Uint32        │ timestamp │ timestamp    of   the │
       │               │           │ event                 │
       ├───────────────┼───────────┼───────────────────────┤
       │ SDL_TouchID   │ touchId   │ the touch device id   │
       ├───────────────┼───────────┼───────────────────────┤
       │ SDL_FingerID  │ fingerId  │ the finger id         │
       ├───────────────┼───────────┼───────────────────────┤
       │ float         │ x         │ the  x-axis  location │
       │               │           │ of  the  touch event, │
       │               │           │ normalized (0...1)    │
       ├───────────────┼───────────┼───────────────────────┤
       │ float         │ y         │ the  y-axis  location │
       │               │           │ of  the  touch event, │
       │               │           │ normalized (0...1)    │
       ├───────────────┼───────────┼───────────────────────┤
       │ float         │ dx        │ the distance moved in │
       │               │           │ the  x-axis,  normal‐ │
       │               │           │ ized (-1...1)         │
       ├───────────────┼───────────┼───────────────────────┤
       │ float         │ dy        │ the distance moved in │
       │               │           │ the  y-axis,  normal‐ │
       │               │           │ ized (-1...1)         │
       ├───────────────┼───────────┼───────────────────────┤
       │ float         │ pressure  │ the quantity of pres‐ │
       │               │           │ sure applied, normal‐ │
       │               │           │ ized (0...1)          │
       └───────────────┴───────────┴───────────────────────┘

REMARKS
       SDL_TouchFingerEvent is a member of the SDL_Event union and is  used  when  an
       event  of  type SDL_FINGERMOTION, SDL_FINGERDOWN, or SDL_FINGERUP is reported.
       You would access it through the event's tfinger field.

VERSION
       This structure is available since SDL 2.0.0.

RELATED ENUMERATIONS
       SDL_EventType

RELATED STRUCTURES
       SDL_Event

===============================================================================
                                                        *SDL_TriggerBreakpoint*


NAME
       SDL_TriggerBreakpoint -- Macro

SYNOPSIS
       Use this function to trigger a breakpoint during debugging.

SYNTAX
       ┌───────────────────────────────────┐
       │ void SDL_TriggerBreakpoint(void)  │
       └───────────────────────────────────┘

REMARKS
       If  the  program  is  running  under  a debugger, this function will trigger a
       breakpoint. It is typically used temporarily during debugging  or  with  other
       error  handling. Note that if a debugger isn't running, on some platforms this
       can terminate your application.

       This isn't actually a function, but rather a macro. The intention is that  the
       debugger  will  stop  on exactly this line of code instead of somewhere inside
       the SDL library. As such, the assertion facility (https://wiki.libsdl.org/Cat‐
       egoryAssertions)  uses  this  so  that the debugger stops on the exact line of
       code where an SDL_assert failed.

===============================================================================
                                                             *SDL_TryLockMutex*


NAME
       SDL_TryLockMutex -- Function

SYNOPSIS
       Use this function to try to lock a mutex without blocking.

SYNTAX
       ┌───────────────────────────────────────────┐
       │ int SDL_TryLockMutex(SDL_mutex*   mutex)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────┐
       │ mutex  │ the mutex to try to lock │
       └────────┴──────────────────────────┘

RETURN VALUE
       Returns  0,  SDL_MUTEX_TIMEDOUT,  or -1 on error; call SDL_GetError() for more
       information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────────┐
       │ int status;                                        │
       │ SDL_mutex *mutex;                                  │
       │                                                    │
       │ mutex = SDL_CreateMutex();                         │
       │ if (!mutex)                                        │
       │ {                                                  │
       │   fprintf(stderr, "Couldn't create mutex\n");      │
       │   return;                                          │
       │ }                                                  │
       │                                                    │
       │ status = SDL_TryLockMutex(mutex);                  │
       │                                                    │
       │ if (status == 0)                                   │
       │ {                                                  │
       │   printf("Locked mutex\n");                        │
       │   SDL_UnlockMutex(mutex);                          │
       │ }                                                  │
       │ else if (status == SDL_MUTEX_TIMEDOUT)             │
       │ {                                                  │
       │   /* Mutex not available for locking right now */  │
       │ }                                                  │
       │ else                                               │
       │ {                                                  │
       │   fprintf(stderr, "Couldn't lock mutex\n");        │
       │ }                                                  │
       │                                                    │
       │ SDL_DestroyMutex(mutex);                           │
       └────────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_CreateMutex
       SDL_DestroyMutex
       SDL_LockMutex
       SDL_UnlockMutex

===============================================================================
                                                                *SDL_UnionRect*


NAME
       SDL_UnionRect -- Function

SYNOPSIS
       Use this function to calculate the union of two rectangles.

SYNTAX
       ┌────────────────────────────────────────────────┐
       │ void SDL_UnionRect(const SDL_Rect*    A,       │
       │                    const SDL_Rect*    B,       │
       │                    SDL_Rect*          result)  │
       └────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ A       │ an SDL_Rect structure repre‐ │
       │         │ senting the first rectangle  │
       ├─────────┼──────────────────────────────┤
       │ B       │ an SDL_Rect structure repre‐ │
       │         │ senting the second rectangle │
       ├─────────┼──────────────────────────────┤
       │ result  │ an SDL_Rect structure filled │
       │         │ in with the union of rectan‐ │
       │         │ gle A and B                  │
       └─────────┴──────────────────────────────┘

===============================================================================
                                                             *SDL_UnloadObject*


NAME
       SDL_UnloadObject -- Function

SYNOPSIS
       Use this function to unload a shared object from memory.

SYNTAX
       ┌────────────────────────────────────────┐
       │ void SDL_UnloadObject(void*   handle)  │
       └────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ handle  │ a valid shared object handle │
       │         │ returned by SDL_LoadObject() │
       └─────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_LoadFunction
       SDL_LoadObject

===============================================================================
                                                              *SDL_UnlockAudio*


NAME
       SDL_UnlockAudio -- Function

SYNOPSIS
       This  function  is  a legacy means of unlocking the audio device. New programs
       might want to use SDL_UnlockAudioDevice() instead.

SYNTAX
       ┌─────────────────────────────┐
       │ void SDL_UnlockAudio(void)  │
       └─────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────┐
       │ void MyAudioCallback(void* userdata, Uint8* stream, int len)  │
       │ {                                                             │
       │   printf("The audio callback is running!\n");                 │
       │   SDL_memset(stream, 0, len);                                 │
       │   printf("The audio callback is done!\n");                    │
       │ }                                                             │
       │                                                               │
       │ // don't lock for 2 seconds at a time in real life, please.   │
       │ SDL_Delay(2000);  // callback runs for 2 seconds              │
       │ SDL_LockAudio();                                              │
       │ printf("The audio callback can't be running right now!0);     │
       │ SDL_Delay(2000);                                              │
       │ printf("Ok, unlocking!0);                                     │
       │ SDL_UnlockAudio();                                            │
       │ SDL_Delay(2000);  // callback runs for 2 seconds              │
       └───────────────────────────────────────────────────────────────┘

REMARKS
       This function is equivalent to calling

       ┌────────────────────────────┐
       │ SDL_UnlockAudioDevice(1);  │
       └────────────────────────────┘
       and is only useful if you used the legacy SDL_OpenAudio() function.

RELATED FUNCTIONS
       SDL_LockAudio
       SDL_UnlockAudioDevice

===============================================================================
                                                        *SDL_UnlockAudioDevice*


NAME
       SDL_UnlockAudioDevice -- Function

SYNOPSIS
       Use  this  function  to unlock the audio callback function for a specified de‐
       vice.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ void SDL_UnlockAudioDevice(SDL_AudioDeviceID    dev)  │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────┬──────────────────────────────┐
       │ dev  │ the ID of the device  to  be │
       │      │ unlocked                     │
       └──────┴──────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────┐
       │ void MyAudioCallback(void* userdata, Uint8* stream, int len)  │
       │ {                                                             │
       │   printf("The audio callback is running!\n");                 │
       │   SDL_memset(stream, 0, len); // just silence.                │
       │   printf("The audio callback is done!\n");                    │
       │ }                                                             │
       │                                                               │
       │ // don't lock for 2 seconds at a time in real life, please.   │
       │ extern SDL_AudioDeviceID devid;                               │
       │ SDL_Delay(2000);                                              │
       │ SDL_LockAudioDevice(devid);                                   │
       │ printf("The audio callback can't be running right now!\n");   │
       │ SDL_Delay(2000);                                              │
       │ printf("Ok, unlocking!0);                                     │
       │ SDL_UnlockAudioDevice(devid);                                 │
       │ SDL_Delay(2000);    // callback runs for 2 seconds.           │
       └───────────────────────────────────────────────────────────────┘

REMARKS
       Unlocks  a previous SDL_LockAudioDevice() call. Please see that function's re‐
       marks (https://wiki.libsdl.org/SDL_LockAudioDevice#Remarks) for more details.

RELATED FUNCTIONS
       SDL_LockAudioDevice

===============================================================================
                                                              *SDL_UnlockMutex*


NAME
       SDL_UnlockMutex -- Function

SYNOPSIS
       Use this function to unlock a mutex created with SDL_CreateMutex().

SYNTAX
       ┌───────────────────────────────────────────┐
       │ int SDL_UnlockMutex(SDL_mutex*    mutex)  │
       └───────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬─────────────────────┐
       │ mutex  │ the mutex to unlock │
       └────────┴─────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌────────────────────────────────────────────────┐
       │ SDL_mutex* mutex;                              │
       │                                                │
       │ mutex = SDL_CreateMutex();                     │
       │ if (!mutex)                                    │
       │ {                                              │
       │   fprintf(stderr, "Couldn't create mutex\n");  │
       │   return;                                      │
       │ }                                              │
       │                                                │
       │ if (SDL_LockMutex(mutex) == 0)                 │
       │ {                                              │
       │   /* Do stuff while mutex is locked */         │
       │   SDL_UnlockMutex(mutex);                      │
       │ }                                              │
       │ else                                           │
       │ {                                              │
       │   fprintf(stderr, "Couldn't lock mutex\n");    │
       │ }                                              │
       │                                                │
       │ SDL_DestroyMutex(mutex);                       │
       └────────────────────────────────────────────────┘

RELATED FUNCTIONS
       SDL_CreateMutex
       SDL_DestroyMutex
       SDL_LockMutex
       SDL_TryLockMutex

===============================================================================
                                                            *SDL_UnlockSurface*


NAME
       SDL_UnlockSurface -- Function

SYNOPSIS
       Use this function to release a surface after directly accessing the pixels.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ void SDL_UnlockSurface(SDL_Surface*   surface)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ surface  │ the SDL_Surface structure to │
       │          │ be unlocked                  │
       └──────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────┐
       │ /* Make the pixels pointer valid in the surface */  │
       │                                                     │
       │ SDL_LockSurface(surface);                           │
       │                                                     │
       │ /* Surface is locked */                             │
       │ /* Direct pixel access on surface here */           │
       │                                                     │
       │ SDL_UnlockSurface(surface);                         │
       │                                                     │
       │ /* Surface is now unlocked */                       │
       └─────────────────────────────────────────────────────┘

REMARKS
       Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to and
       read  from  surface->pixels, using the pixel format stored in surface->format.
       Once you are done accessing the surface, you should use SDL_UnlockSurface() to
       release it.

       Not  all  surfaces  require  locking. If SDL_MUSTLOCK(surface) evaluates to 0,
       then you can read and write to the surface at any time, and the  pixel  format
       of the surface will not change.

RELATED FUNCTIONS
       SDL_LockSurface

===============================================================================
                                                            *SDL_UnlockTexture*


NAME
       SDL_UnlockTexture -- Function

SYNOPSIS
       Use  this function to unlock a texture, uploading the changes to video memory,
       if needed.

SYNTAX
       ┌─────────────────────────────────────────────────┐
       │ void SDL_UnlockTexture(SDL_Texture*   texture)  │
       └─────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ a    texture    locked    by │
       │          │ SDL_LockTexture()            │
       └──────────┴──────────────────────────────┘

REMARKS
       WARNING:  See SDL bug #1586 (https://bugzilla.libsdl.org/show_bug.cgi?id=1586)
       before using this function!

RELATED FUNCTIONS
       SDL_LockTexture

===============================================================================
                                                         *SDL_UnlockYUVOverlay*


NAME
       SDL_UnlockYUVOverlay - Unlock an overlay

SYNOPSIS
       #include "SDL.h"

       void SDL_UnlockYUVOverlay(SDL_Overlay *overlay);

DESCRIPTION
       The  opposite  to  SDL_LockYUVOverlay. Unlocks a previously locked overlay. An
       overlay must be unlocked before it can be displayed.

SEE ALSO
       SDL_UnlockYUVOverlay, SDL_CreateYUVOverlay, SDL_Overlay

===============================================================================
                                                               *SDL_UpdateRect*


NAME
       SDL_UpdateRect - Makes sure the given area is updated on the given screen.

SYNOPSIS
       #include "SDL.h"

       void  SDL_UpdateRect(SDL_Surface *screen, Sint32 x, Sint32 y, Sint32 w, Sint32
       h);

DESCRIPTION
       Makes sure the given area is updated on the given screen. The  rectangle  must
       be confined within the screen boundaries (no clipping is done).

       If  'x',  'y',  'w'  and  'h' are all 0, SDL_UpdateRect will update the entire
       screen.

       This function should not be called while 'screen' is locked.

SEE ALSO
       SDL_UpdateRects, SDL_Rect, SDL_Surface, SDL_LockSurface

===============================================================================
                                                              *SDL_UpdateRects*


NAME
       SDL_UpdateRects  -  Makes  sure the given list of rectangles is updated on the
       given screen.

SYNOPSIS
       #include "SDL.h"

       void SDL_UpdateRects(SDL_Surface *screen, int numrects, SDL_Rect *rects);

DESCRIPTION
       Makes sure the given list of rectangles is updated on the  given  screen.  The
       rectangles  must  all be confined within the screen boundaries (no clipping is
       done).

       This function should not be called while screen is locked.

              Note:

              It is adviced to call this function only once  per  frame,  since  each
              call has some processing overhead. This is no restriction since you can
              pass any number of rectangles each time.

              The rectangles are not automatically merged or checked for overlap.  In
              general, the programmer can use his knowledge about his particular rec‐
              tangles to merge them in an efficient way, to avoid overdraw.

SEE ALSO
       SDL_UpdateRect, SDL_Rect, SDL_Surface, SDL_LockSurface

===============================================================================
                                                            *SDL_UpdateTexture*


NAME
       SDL_UpdateTexture -- Function

SYNOPSIS
       Use this function to update the given texture rectangle with new pixel data.

SYNTAX
       ┌───────────────────────────────────────────────────┐
       │ int SDL_UpdateTexture(SDL_Texture*      texture,  │
       │                       const SDL_Rect*   rect,     │
       │                       const void*       pixels,   │
       │                       int               pitch)    │
       └───────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to update        │
       ├──────────┼──────────────────────────────┤
       │ rect     │ an SDL_Rect structure repre‐ │
       │          │ senting the area to  update, │
       │          │ or NULL to update the entire │
       │          │ texture                      │
       ├──────────┼──────────────────────────────┤
       │ pixels   │ the raw pixel  data  in  the │
       │          │ format of the texture        │
       ├──────────┼──────────────────────────────┤
       │ pitch    │ the number of bytes in a row │
       │          │ of  pixel  data,   including │
       │          │ padding between lines        │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       The pixel data must be in the pixel format of the texture.  Use  SDL_QueryTex‐
       ture() to query the pixel format of the texture.

       This is fairy slow function, intended for use with static textures that do not
       change often.

       If the texture is intended to be updated often, it is preferred to create  the
       texture  as  streaming  and  use the locking functions referenced below. While
       this function will work with streaming textures, for optimization reasons  you
       may not get the pixels back if you lock the texture afterward.

RELATED FUNCTIONS
       SDL_CreateTexture
       SDL_LockTexture
       SDL_UnlockTexture

===============================================================================
                                                      *SDL_UpdateWindowSurface*


NAME
       SDL_UpdateWindowSurface -- Function

SYNOPSIS
       Use this function to copy the window surface to the screen.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ int SDL_UpdateWindowSurface(SDL_Window*   window)  │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────┐
       │ window  │ the window to update │
       └─────────┴──────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       This is the function you use to reflect any changes  to  the  surface  on  the
       screen.

       This function is equivalent to the SDL 1.2 API SDL_Flip().

RELATED FUNCTIONS
       SDL_GetWindowSurface
       SDL_UpdateWindowSurfaceRects

===============================================================================
                                                 *SDL_UpdateWindowSurfaceRects*


NAME
       SDL_UpdateWindowSurfaceRects -- Function

SYNOPSIS
       Use this function to copy areas of the window surface to the screen.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ int SDL_UpdateWindowSurfaceRects(SDL_Window*        window,    │
       │                                  const SDL_Rect*    rects,     │
       │                                  int                numrects)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ window    │ the window to update         │
       ├───────────┼──────────────────────────────┤
       │ rects     │ any array of SDL_Rect struc‐ │
       │           │ tures representing areas  of │
       │           │ the surface to copy          │
       ├───────────┼──────────────────────────────┤
       │ numrects  │ the number of rectangles     │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0 on success or a negative error code on failure; call SDL_GetError()
       for more information.

REMARKS
       This is the function you use to reflect changes to portions of the surface  on
       the screen.

       This function is equivalent to the SDL 1.2 API SDL_UpdateRects().

RELATED FUNCTIONS
       SDL_GetWindowSurface
       SDL_UpdateWindowSurface

===============================================================================
                                                         *SDL_UpdateYUVTexture*


NAME
       SDL_UpdateYUVTexture -- Function

SYNOPSIS
       Use  this  function to update a rectangle within a planar YV12 or IYUV texture
       with new pixel data.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ int SDL_UpdateYUVTexture(SDL_Texture*       texture,  │
       │                          const SDL_Rect*    rect,     │
       │                          const Uint8*       Yplane,   │
       │                          int                Ypitch,   │
       │                          const Uint8*       Uplane,   │
       │                          int                Upitch,   │
       │                          const Uint8*       Vplane,   │
       │                          int                Vpitch)   │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ texture  │ the texture to update        │
       ├──────────┼──────────────────────────────┤
       │ rect     │ a pointer to  the  rectangle │
       │          │ of pixels to update, or NULL │
       │          │ to update the entire texture │
       ├──────────┼──────────────────────────────┤
       │ Yplane   │ the raw pixel data for the Y │
       │          │ plane                        │
       ├──────────┼──────────────────────────────┤
       │ Ypitch   │ the  number of bytes between │
       │          │ rows of pixel data for the Y │
       │          │ plane                        │
       ├──────────┼──────────────────────────────┤
       │ Uplane   │ the raw pixel data for the U │
       │          │ plane                        │
       ├──────────┼──────────────────────────────┤
       │ Upitch   │ the number of bytes  between │
       │          │ rows of pixel data for the U │
       │          │ plane                        │
       ├──────────┼──────────────────────────────┤
       │ Vplane   │ the raw pixel data for the V │
       │          │ plane                        │
       ├──────────┼──────────────────────────────┤
       │ Vpitch   │ the  number of bytes between │
       │          │ rows of pixel data for the V │
       │          │ plane                        │
       └──────────┴──────────────────────────────┘

RETURN VALUE
       Returns  0  on  success or -1 if the texture is not valid; call SDL_GetError()
       for more information.

REMARKS
       You can use SDL_UpdateTexture() as long as your pixel  data  is  a  contiguous
       block  of Y and U/V planes in the proper order, but this function is available
       if your pixel data is not contiguous.

VERSION
       This function is available since SDL 2.0.1.

RELATED FUNCTIONS
       SDL_UpdateTexture

===============================================================================
                                                                *SDL_UserEvent*


NAME
       SDL_UserEvent -- Structure

SYNOPSIS
       A structure that contains an application-defined event type.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ value  obtained  from │
       │         │           │ SDL_RegisterEvents()  │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ timestamp   of    the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ windowID  │ the  associated  win‐ │
       │         │           │ dow, if any           │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ code      │ user  defined   event │
       │         │           │ code                  │
       ├─────────┼───────────┼───────────────────────┤
       │ void*   │ data1     │ user   defined   data │
       │         │           │ pointer               │
       ├─────────┼───────────┼───────────────────────┤
       │ void*   │ data2     │ user   defined   data │
       │         │           │ pointer               │
       └─────────┴───────────┴───────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────┐
       │ Uint32 myEventType = SDL_RegisterEvents(1);                        │
       │ if (myEventType != ((Uint32)-1)) {                                 │
       │   SDL_Event event;                                                 │
       │   SDL_memset(&event, 0, sizeof(event));  /* or SDL_zero(event) */  │
       │   event.type = myEventType;                                        │
       │   event.user.code = my_event_code;                                 │
       │   event.user.data1 = significant_data;                             │
       │   event.user.data2 = 0;                                            │
       │   SDL_PushEvent(&event);                                           │
       │ }                                                                  │
       └────────────────────────────────────────────────────────────────────┘

REMARKS
       SDL_UserEvent  is  in  the  user  member of the SDL_Event union. This event is
       unique; it is never created by SDL but only by the application. The event  can
       be  pushed  onto  the  event  queue using SDL_PushEvent(). The contents of the
       structure members are completely up to the programmer; the only requirement is
       that type is a value obtained from SDL_RegisterEvents().

RELATED ENUMERATIONS
       SDL_EventType

RELATED FUNCTIONS
       SDL_PushEvent
       SDL_RegisterEvents

===============================================================================
                                                                  *SDL_VERSION*


NAME
       SDL_VERSION -- Macro

SYNOPSIS
       Use this macro to determine the SDL version your program was compiled against.

SYNTAX
       ┌─────────────────┐
       │ SDL_VERSION(x)  │
       └─────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ x  │ an  SDL_version structure to │
       │    │ initialize                   │
       └────┴──────────────────────────────┘

RETURN VALUE
       Fills the selected struct with:

       ┌─────────────────────────────────┐
       │ (x)->major = SDL_MAJOR_VERSION  │
       │ (x)->minor = SDL_MINOR_VERSION  │
       │ (x)->patch = SDL_PATCHLEVEL     │
       └─────────────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────────┐
       │ SDL_version compiled;                                         │
       │ SDL_version linked;                                           │
       │                                                               │
       │ SDL_VERSION(&compiled);                                       │
       │ SDL_GetVersion(&linked);                                      │
       │ printf("We compiled against SDL version %d.%d.%d ...\n",      │
       │        compiled.major, compiled.minor, compiled.patch);       │
       │ printf("But we are linking against SDL version %d.%d.%d.\n",  │
       │        linked.major, linked.minor, linked.patch);             │
       └───────────────────────────────────────────────────────────────┘

REMARKS
       This macro fills in an SDL_version structure with the version of  the  library
       you  compiled  against.  This  is determined by what header the compiler uses.
       Note that if you dynamically linked the library, you  might  have  a  slightly
       newer  or  older  version  at  runtime.  That  version  can be determined with
       SDL_GetVersion() which, unlike SDL_VERSION(), is not a macro.

RELATED STRUCTURES
       SDL_version

RELATED FUNCTIONS
       SDL_GetVersion

===============================================================================
                                                               *SDL_VERSIONNUM*


NAME
       SDL_VERSIONNUM -- Macro

SYNOPSIS
       Use  this  macro  to convert separate version components into a single numeric
       value.

SYNTAX
       ┌──────────────────────────┐
       │ SDL_VERSIONNUM(X, Y, Z)  │
       └──────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ X  │ major version;  reported  in │
       │    │ thousands place              │
       ├────┼──────────────────────────────┤
       │ Y  │ minor  version;  reported in │
       │    │ hundreds place               │
       ├────┼──────────────────────────────┤
       │ Z  │ update version (patchlevel); │
       │    │ reported  in  tens  and ones │
       │    │ places                       │
       └────┴──────────────────────────────┘

REMARKS
       This assumes that there will never be more than 100 patchlevels.

       Example:

       SDL_VERSIONNUM(1,2,3) -> (1203)

RELATED MACROS
       SDL_COMPILEDVERSION
       SDL_VERSION_ATLEAST

===============================================================================
                                                          *SDL_VERSION_ATLEAST*


NAME
       SDL_VERSION_ATLEAST -- Macro

SYNOPSIS
       Use  this  macro  to  determine whether the SDL version compiled against is at
       least as new as the specified version.

SYNTAX
       ┌───────────────────────────────┐
       │ SDL_VERSION_ATLEAST(X, Y, Z)  │
       └───────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬─────────────────────────────┐
       │ X  │ major version               │
       ├────┼─────────────────────────────┤
       │ Y  │ minor version               │
       ├────┼─────────────────────────────┤
       │ Z  │ update version (patchlevel) │
       └────┴─────────────────────────────┘

RETURN VALUE
       This macro will evaulate to true if compiled with SDL version at least X.Y.Z.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────┐
       │ if (!SDL_VERSION_ATLEAST(2,0,0))                                    │
       │ {                                                                   │
       │   SDL_Log("SDL_VERSION %i is less than 2.0.0", SDL_MAJOR_VERSION);  │
       │   return 1;                                                         │
       │ }                                                                   │
       └─────────────────────────────────────────────────────────────────────┘

RELATED MACROS
       SDL_COMPILEDVERSION
       SDL_VERSIONNUM

===============================================================================
                                                          *SDL_VideoDriverName*


NAME
       SDL_VideoDriverName - Obtain the name of the video driver

SYNOPSIS
       #include "SDL.h"

       char *SDL_VideoDriverName(char *namebuf, int maxlen);

DESCRIPTION
       The  buffer  pointed to by namebuf is filled up to a maximum of maxlen charac‐
       ters (include the NULL terminator) with the  name  of  the  initialised  video
       driver.  The  driver  name  is  a  simple  one  word  identifier like "x11" or
       "windib".

RETURN VALUE
       Returns NULL if video has not been initialised with SDL_Init or a  pointer  to
       namebuf otherwise.

SEE ALSO
       SDL_Init SDL_InitSubSystem

===============================================================================
                                                                *SDL_VideoInfo*


NAME
       SDL_VideoInfo - Video Target information

STRUCTURE DEFINITION
       typedef struct{
         Uint32 hw_available:1;
         Uint32 wm_available:1;
         Uint32 blit_hw:1;
         Uint32 blit_hw_CC:1;
         Uint32 blit_hw_A:1;
         Uint32 blit_sw:1;
         Uint32 blit_sw_CC:1;
         Uint32 blit_sw_A:1;
         Uint32 blit_fill;
         Uint32 video_mem;
         SDL_PixelFormat *vfmt;
       } SDL_VideoInfo;

STRUCTURE DATA
       hw_available        Is it possible to create hardware surfaces?

       wm_available        Is there a window manager available

       blit_hw             Are hardware to hardware blits accelerated?

       blit_hw_CC          Are hardware to hardware colorkey blits accelerated?

       blit_hw_A           Are hardware to hardware alpha blits accelerated?

       blit_sw             Are software to hardware blits accelerated?

       blit_sw_CC          Are software to hardware colorkey blits accelerated?

       blit_sw_A           Are software to hardware alpha blits accelerated?

       blit_fill           Are color fills accelerated?

       video_mem           Total amount of video memory in Kilobytes

       vfmt                Pixel format of the video device

DESCRIPTION
       This (read-only) structure is returned by SDL_GetVideoInfo. It contains infor‐
       mation on either the 'best' available mode (if called before SDL_SetVideoMode)
       or the current video mode.

SEE ALSO
       SDL_PixelFormat, SDL_GetVideoInfo

===============================================================================
                                                                *SDL_VideoInit*


NAME
       SDL_VideoInit -- Function

SYNOPSIS
       Use  this  function to initialize the video subsystem, optionally specifying a
       video driver.

SYNTAX
       ┌───────────────────────────────────────────────┐
       │ int SDL_VideoInit(const char*   driver_name)  │
       └───────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────────┬──────────────────────────────┐
       │ driver_name  │ the name of a  video  driver │
       │              │ to  initialize,  or NULL for │
       │              │ the default driver           │
       └──────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────────────────┐
       │ #include "SDL.h"                                                        │
       │ #include <stdio.h> /* for printf() */                                   │
       │ #include <stdlib.h> /* for atexit() */                                  │
       │                                                                         │
       │ SDL_bool videoinit = SDL_FALSE;                                         │
       │                                                                         │
       │ void OnQuit(void) {                                                     │
       │     if (videoinit) {                                                    │
       │         SDL_VideoQuit();                                                │
       │     }                                                                   │
       │     SDL_Quit();                                                         │
       │ }                                                                       │
       │                                                                         │
       │ int main(int argc, char** argv) {                                       │
       │     if (SDL_Init(0) != 0) {                                             │
       │         printf("Error initializing SDL:  %s\n", SDL_GetError());        │
       │         return 1;                                                       │
       │     }                                                                   │
       │     atexit(OnQuit);                                                     │
       │                                                                         │
       │     if (SDL_VideoInit(NULL) != 0) {                                     │
       │         printf("Error initializing SDL video:  %s\n", SDL_GetError());  │
       │         return 2;                                                       │
       │     }                                                                   │
       │     videoinit = SDL_TRUE;                                               │
       │                                                                         │
       │     /* ... */                                                           │
       │                                                                         │
       │     return 0;                                                           │
       │ }                                                                       │
       │                                                                         │
       └─────────────────────────────────────────────────────────────────────────┘

REMARKS
       This  function initializes the video subsystem, setting up a connection to the
       window manager, etc, and determines the available display modes and pixel for‐
       mats, but does not initialize a window or graphics mode.

       If you use this function and you haven't used the SDL_INIT_VIDEO flag with ei‐
       ther SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit() before
       calling SDL_Quit().

       It  is  safe  to  call this function multiple times. SDL_VideoInit() will call
       SDL_VideoQuit() itself if the video subsystem has already been initialized.

       You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find  a  spe‐
       cific driver_name.

RELATED FUNCTIONS
       SDL_GetNumVideoDrivers
       SDL_GetVideoDriver
       SDL_InitSubSystem
       SDL_VideoQuit

===============================================================================
                                                              *SDL_VideoModeOK*


NAME
       SDL_VideoModeOK - Check to see if a particular video mode is supported.

SYNOPSIS
       #include "SDL.h"

       int SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags);

DESCRIPTION
       SDL_VideoModeOK returns 0 if the requested mode is not supported under any bit
       depth, or returns the bits-per-pixel of the closest available  mode  with  the
       given width, height and requested surface flags (see SDL_SetVideoMode).

       The  bits-per-pixel  value  returned is only a suggested mode. You can usually
       request and bpp you want when setting the video mode and SDL will emulate that
       color depth with a shadow video surface.

       The  arguments  to  SDL_VideoModeOK  are  the  same  ones  you  would  pass to
       SDL_SetVideoMode

EXAMPLE
       SDL_Surface *screen;
       Uint32 bpp;
       .
       .
       .
       printf("Checking mode 640x480@16bpp.
       ");
       bpp=SDL_VideoModeOK(640, 480, 16, SDL_HWSURFACE);

       if(!bpp){
         printf("Mode not available.
       ");
         exit(-1);
       }

       printf("SDL Recommends 640x480@%dbpp.
       ", bpp);
       screen=SDL_SetVideoMode(640, 480, bpp, SDL_HWSURFACE);
       .
       .

SEE ALSO
       SDL_SetVideoMode, SDL_GetVideoInfo

===============================================================================
                                                                *SDL_VideoQuit*


NAME
       SDL_VideoQuit -- Function

SYNOPSIS
       Use  this  function  to  shut  down  the  video subsystem, if initialized with
       SDL_VideoInit().

SYNTAX
       ┌───────────────────────────┐
       │ void SDL_VideoQuit(void)  │
       └───────────────────────────┘

REMARKS
       This function closes all windows, and restores the original video mode.

RELATED FUNCTIONS
       SDL_VideoInit

===============================================================================
                                                            *SDL_WM_GetCaption*


NAME
       SDL_WM_GetCaption - Gets the window title and icon name.

SYNOPSIS
       #include "SDL.h"

       void SDL_WM_GetCaption(char **title, char **icon);

DESCRIPTION
       Set pointers to the window title and icon name.

SEE ALSO
       SDL_WM_SetCaption, SDL_WM_SetIcon

===============================================================================
                                                             *SDL_WM_GrabInput*


NAME
       SDL_WM_GrabInput - Grabs mouse and keyboard input.

SYNOPSIS
       #include "SDL.h"

       SDL_GrabMode SDL_WM_GrabInput(SDL_GrabMode mode);

DESCRIPTION
       Grabbing  means  that  the  mouse  is  confined to the application window, and
       nearly all keyboard input is passed directly to the application, and  not  in‐
       terpreted by a window manager, if any.

       When mode is SDL_GRAB_QUERY the grab mode is not changed, but the current grab
       mode is returned.

       typedef enum {
         SDL_GRAB_QUERY,
         SDL_GRAB_OFF,
         SDL_GRAB_ON
       } SDL_GrabMode;

RETURN VALUE
       The current/new SDL_GrabMode.

===============================================================================
                                                         *SDL_WM_IconifyWindow*


NAME
       SDL_WM_IconifyWindow - Iconify/Minimise the window

SYNOPSIS
       #include "SDL.h"

       int SDL_WM_IconifyWindow(void);

DESCRIPTION
       If  the application is running in a window managed environment SDL attempts to
       iconify/minimise it. If SDL_WM_IconifyWindow is  successful,  the  application
       will receive a SDL_APPACTIVE loss event.

RETURN VALUE
       Returns  non-zero  on  success or 0 if iconification is not support or was re‐
       fused by the window manager.

===============================================================================
                                                            *SDL_WM_SetCaption*


NAME
       SDL_WM_SetCaption - Sets the window tile and icon name.

SYNOPSIS
       #include "SDL.h"

       void SDL_WM_SetCaption(const char *title, const char *icon);

DESCRIPTION
       Sets the title-bar and icon name of the display window.

SEE ALSO
       SDL_WM_GetCaption, SDL_WM_SetIcon

===============================================================================
                                                               *SDL_WM_SetIcon*


NAME
       SDL_WM_SetIcon - Sets the icon for the display window.

SYNOPSIS
       #include "SDL.h"

       void SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask);

DESCRIPTION
       Sets the icon for the display window. Win32 icons must be 32x32.

       This function must be called before the first call to SDL_SetVideoMode.

       It takes an icon surface, and a mask in MSB format.

       If mask is NULL, the entire icon surface will be used as the icon.

EXAMPLE
       SDL_WM_SetIcon(SDL_LoadBMP("icon.bmp"), NULL);

SEE ALSO
       SDL_SetVideoMode, SDL_WM_SetCaption

===============================================================================
                                                      *SDL_WM_ToggleFullScreen*


NAME
       SDL_WM_ToggleFullScreen - Toggles fullscreen mode

SYNOPSIS
       #include "SDL.h"

       int SDL_WM_ToggleFullScreen(SDL_Surface *surface);

DESCRIPTION
       Toggles  the  application  between windowed and fullscreen mode, if supported.
       (X11 is the only target currently supported, BeOS support is experimental).

RETURN VALUE
       Returns 0 on failure or 1 on success.

===============================================================================
                                                                *SDL_WaitEvent*


NAME
       SDL_WaitEvent -- Function

SYNOPSIS
       Use this function to wait indefinitely for the next available event.

SYNTAX
       ┌─────────────────────────────────────────┐
       │ int SDL_WaitEvent(SDL_Event*    event)  │
       └─────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ event  │ the  SDL_Event  structure to │
       │        │ be filled in with  the  next │
       │        │ event  from  the  queue,  or │
       │        │ NULL                         │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on success or 0 if there was an error while waiting for events; call
       SDL_GetError() for more information.

REMARKS
       If  event  is not NULL, the next event is removed from the queue and stored in
       the SDL_Event structure pointed to by event.

       As this function implicitly calls SDL_PumpEvents(), you  can  only  call  this
       function in the thread that initialized the video subsystem.

RELATED FUNCTIONS
       SDL_PollEvent
       SDL_PumpEvents
       SDL_WaitEventTimeout

===============================================================================
                                                               *SDL_WaitThread*


NAME
       SDL_WaitThread -- Function

SYNOPSIS
       Use this function to wait for a thread to finish.

SYNTAX
       ┌────────────────────────────────────────────┐
       │ void SDL_WaitThread(SDL_Thread*   thread,  │
       │                     int*          status)  │
       └────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ thread  │ the  SDL_Thread pointer that │
       │         │ was   returned   from    the │
       │         │ SDL_CreateThread() call that │
       │         │ started this thread          │
       ├─────────┼──────────────────────────────┤
       │ status  │ pointer to an  integer  that │
       │         │ will  receive  the value re‐ │
       │         │ turned from the thread func‐ │
       │         │ tion  by  its  'return',  or │
       │         │ NULL  to  not  receive  such │
       │         │ value  back. See Remarks for │
       │         │ details.                     │
       └─────────┴──────────────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────────────────────────────────────┐
       │ #include <stdio.h>                                                                 │
       │ #include "SDL_thread.h"                                                            │
       │ #include "SDL_timer.h"                                                             │
       │                                                                                    │
       │ // Very simple thread - counts 0 to 9 delaying 50ms between increments             │
       │ static int TestThread(void *ptr)                                                   │
       │ {                                                                                  │
       │     int cnt;                                                                       │
       │                                                                                    │
       │     for (cnt = 0; cnt < 10; ++cnt) {                                               │
       │         printf("\nThread counter: %d", cnt);                                       │
       │         SDL_Delay(50);                                                             │
       │     }                                                                              │
       │                                                                                    │
       │     // Return the final value to the SDL_WaitThread function above                 │
       │     return cnt;                                                                    │
       │ }                                                                                  │
       │                                                                                    │
       │ int main(int argc, char *argv[])                                                   │
       │ {                                                                                  │
       │     SDL_Thread *thread;                                                            │
       │     int         threadReturnValue;                                                 │
       │                                                                                    │
       │     printf("\nSimple SDL_CreateThread test:");                                     │
       │                                                                                    │
       │     // Simply create a thread                                                      │
       │     thread = SDL_CreateThread(TestThread, "TestThread", (void *)NULL);             │
       │                                                                                    │
       │     if (NULL == thread) {                                                          │
       │         printf("\nSDL_CreateThread failed: %s\n", SDL_GetError());                 │
       │     } else {                                                                       │
       │         // Wait for the thread to complete. The thread functions return code will  │
       │         //       be placed in the "threadReturnValue" variable when it completes.  │
       │         //                                                                         │
       │         SDL_WaitThread(thread, &threadReturnValue);                                │
       │         printf("\nThread returned value: %d", threadReturnValue);                  │
       │     }                                                                              │
       │                                                                                    │
       │     return 0;                                                                      │
       │ }                                                                                  │
       │                                                                                    │
       └────────────────────────────────────────────────────────────────────────────────────┘

REMARKS
       Wait for a thread to finish. Threads that haven't been  detached  will  remain
       (as a "zombie") until this function cleans them up. Not doing so is a resource
       leak.

       Once a thread has been cleaned up through this function, the  SDL_Thread  that
       references  it  becomes  invalid  and should not be referenced again. As such,
       only one thread may call SDL_WaitThread() on another.

       The return code for the thread function is placed in the area  pointed  to  by
       status, if status is not NULL.

       You  may  not  wait  on  a  thread  that  has  been  used in a call to SDL_De‐
       tachThread(). Use either that function or this one, but not both, or  behavior
       is undefined.

       It is safe to pass a NULL thread to this function; it is a no-op.

       Note that the thread pointer is freed by this function and is not valid after‐
       ward.

RELATED FUNCTIONS
       SDL_CreateThread
       SDL_DetachThread

===============================================================================
                                                                *SDL_WarpMouse*


NAME
       SDL_WarpMouse - Set the position of the mouse cursor.

SYNOPSIS
       #include "SDL.h"

       void SDL_WarpMouse(Uint16 x, Uint16 y);

DESCRIPTION
       Set the position of the mouse cursor (generates a mouse motion event).

SEE ALSO
       SDL_MouseMotionEvent

===============================================================================
                                                          *SDL_WarpMouseGlobal*


NAME
       SDL_WarpMouseGlobal -- Function

SYNOPSIS
       Use  this  function  to  move the mouse to the given position in global screen
       space.

SYNTAX
       ┌───────────────────────────────────┐
       │ int SDL_WarpMouseGlobal(int   x,  │
       │                         int   y)  │
       └───────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────┐
       │ x  │ the x coordinate │
       ├────┼──────────────────┤
       │ y  │ the y coordinate │
       └────┴──────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       This function generates a mouse motion event.

       A failure of this function usually means that it is unsupported by a platform.

RELATED FUNCTIONS
       SDL_WarpMouseInWindow

===============================================================================
                                                        *SDL_WarpMouseInWindow*


NAME
       SDL_WarpMouseInWindow -- Function

SYNOPSIS
       Use this function to move the mouse to the given position within the window.

SYNTAX
       ┌────────────────────────────────────────────────────┐
       │ void SDL_WarpMouseInWindow(SDL_Window*    window,  │
       │                            int            x,       │
       │                            int            y)       │
       └────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌─────────┬──────────────────────────────┐
       │ window  │ the window to move the mouse │
       │         │ into, or NULL for  the  cur‐ │
       │         │ rent mouse focus             │
       ├─────────┼──────────────────────────────┤
       │ x       │ the  x coordinate within the │
       │         │ window                       │
       ├─────────┼──────────────────────────────┤
       │ y       │ the y coordinate within  the │
       │         │ window                       │
       └─────────┴──────────────────────────────┘

REMARKS
       This function generates a mouse motion event.

RELATED FUNCTIONS
       SDL_WarpMouseGlobal

===============================================================================
                                                                  *SDL_WasInit*


NAME
       SDL_WasInit -- Function

SYNOPSIS
       Use  this function to get a mask of the specified subsystems which have previ‐
       ously been initialized.

SYNTAX
       ┌─────────────────────────────────────┐
       │ Uint32 SDL_WasInit(Uint32   flags)  │
       └─────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ flags  │ any of  the  flags  used  by │
       │        │ SDL_Init();  see Remarks for │
       │        │ details                      │
       └────────┴──────────────────────────────┘

RETURN VALUE
       If flags is 0 it returns a mask of all initialized  subsystems,  otherwise  it
       returns the initialization status of the specified subsystems.

       The return value does not include SDL_INIT_NOPARACHUTE.

CODE EXAMPLES
       Get init data on all the subsystems

       ┌─────────────────────────────────────────────────────┐
       │ Uint32 subsystem_init;                              │
       │                                                     │
       │ subsystem_init = SDL_WasInit(SDL_INIT_EVERYTHING);  │
       │                                                     │
       │ if (subsystem_init & SDL_INIT_VIDEO) {              │
       │   printf("Video is initialized.\n");                │
       │ } else {                                            │
       │   printf("Video is not initialized.\n");            │
       │ }                                                   │
       └─────────────────────────────────────────────────────┘
       Just check for one specific subsystem

       ┌───────────────────────────────────────────┐
       │ if (SDL_WasInit(SDL_INIT_VIDEO) != 0) {   │
       │   printf("Video is initialized.\n");      │
       │ } else {                                  │
       │   printf("Video is not initialized.\n");  │
       │ }                                         │
       └───────────────────────────────────────────┘
       Check for two subsystems

       ┌───────────────────────────────────────────────────────────┐
       │ Uint32 subsystem_mask = SDL_INIT_VIDEO | SDL_INIT_AUDIO;  │
       │                                                           │
       │ if (SDL_WasInit(subsystem_mask) == subsystem_mask) {      │
       │   printf("Video and Audio initialized.\n");               │
       │ } else {                                                  │
       │   printf("Video and Audio not initialized.\n");           │
       │ }                                                         │
       └───────────────────────────────────────────────────────────┘

REMARKS
       These  are  the flags which may be passed to SDL_WasInit() and may be OR'd to‐
       gether to query multiple subsystems simultaneously.

       ┌──────────────────────────┬──────────────────────────────┐
       │ SDL_INIT_TIMER           │ timer subsystem              │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_AUDIO           │ audio subsystem              │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_VIDEO           │ video  subsystem;  automati‐ │
       │                          │ cally initializes the events │
       │                          │ subsystem                    │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_JOYSTICK        │ joystick  subsystems;  auto‐ │
       │                          │ matically   initializes  the │
       │                          │ events subsystem             │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_HAPTIC          │ haptic (force feedback) sub‐ │
       │                          │ system                       │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_GAMECONTROLLER  │ controller  subsystem; auto‐ │
       │                          │ matically  initializes   the │
       │                          │ joystick subsystem           │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_EVENTS          │ events subsystem             │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_EVERYTHING      │ all of the above subsystems  │
       ├──────────────────────────┼──────────────────────────────┤
       │ SDL_INIT_NOPARACHUTE     │ compatibility;  this flag is │
       │                          │ ignored                      │
       └──────────────────────────┴──────────────────────────────┘

RELATED FUNCTIONS
       SDL_Init
       SDL_InitSubSystem

===============================================================================
                                                    *SDL_WinRTGetFSPathUNICODE*


NAME
       SDL_WinRTGetFSPathUNICODE -- Function

SYNOPSIS
       Use this function to retrieve a WinRT defined path on the local file system.

SYNTAX
       ┌──────────────────────────────────────────────────────────────────────┐
       │ const wchar_t* SDL_WinRTGetFSPathUNICODE(SDL_WinRT_Path   pathType)  │
       └──────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ pathType  │ the  type  of  path  to  re‐ │
       │           │ trieve,        one        of │
       │           │ SDL_WinRT_Path               │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns a UCS-2 string (16-bit, wide-char) containing the path, or NULL if the
       path is not available for any reason; call SDL_GetError()  for  more  informa‐
       tion.

REMARKS
       Not  all  paths  are  available on all versions of Windows. This is especially
       true on Windows Phone. Check the documentation for  the  given  SDL_WinRT_Path
       for more information on which path types are supported where.

       Documentation  on  most app-specific path types on WinRT can be found on MSDN,
       at        the        URL:         http://msdn.microsoft.com/en-us/library/win‐
       dows/apps/hh464917.aspx.

VERSION
       This function is available since SDL 2.0.3.

RELATED FUNCTIONS
       SDL_WinRTGetFSPathUTF8

===============================================================================
                                                       *SDL_WinRTGetFSPathUTF8*


NAME
       SDL_WinRTGetFSPathUTF8 -- Function

SYNOPSIS
       Use this function to retrieve a WinRT defined path on the local file system.

SYNTAX
       ┌────────────────────────────────────────────────────────────────┐
       │ const char* SDL_WinRTGetFSPathUTF8(SDL_WinRT_Path   pathType)  │
       └────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────┬──────────────────────────────┐
       │ pathType  │ the  type  of  path  to  re‐ │
       │           │ trieve,        one        of │
       │           │ SDL_WinRT_Path               │
       └───────────┴──────────────────────────────┘

RETURN VALUE
       Returns a UTF-8 string (8-bit, multi-byte) containing the path, or NULL if the
       path is not available for any reason; call SDL_GetError()  for  more  informa‐
       tion.

REMARKS
       Not  all  paths  are  available on all versions of Windows. This is especially
       true on Windows Phone. Check the documentation for  the  given  SDL_WinRT_Path
       for more information on which path types are supported where.

       Documentation  on  most app-specific path types on WinRT can be found on MSDN,
       at        the        URL:         http://msdn.microsoft.com/en-us/library/win‐
       dows/apps/hh464917.aspx.

VERSION
       This function is available since SDL 2.0.3.

RELATED FUNCTIONS
       SDL_WinRTGetFSPathUNICODE

===============================================================================
                                                              *SDL_WinRTRunApp*


NAME
       SDL_WinRTRunApp -- Function

SYNOPSIS
       Use this function to initialize and launch an SDL/WinRT application.

SYNTAX
       ┌────────────────────────────────────────────────────────┐
       │ int SDL_WinRTRunApp(MainFunction        mainFunction,  │
       │                     void*               reserved)      │
       └────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌───────────────┬──────────────────────────────┐
       │ mainFunction  │ the    SDL   app's   C-style │
       │               │ main(); see Remarks for  de‐ │
       │               │ tails                        │
       ├───────────────┼──────────────────────────────┤
       │ reserved      │ reserved   for  future  use; │
       │               │ should be NULL               │
       └───────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or -1 on failure; call SDL_GetError()  to  retrieve  more
       information on the failure.

REMARKS
       The function prototype for mainFunction is:

       ┌──────────────────────────────────────────┐
       │ int MainFunction(int argc, char **argv)  │
       └──────────────────────────────────────────┘
       where its parameters are:

       ┌───────┬─────────────────────────┐
       │ argc  │ the number of arguments │
       ├───────┼─────────────────────────┤
       │ argv  │ an array of arguments   │
       └───────┴─────────────────────────┘

VERSION
       This function is available since SDL 2.0.3.

===============================================================================
                                                               *SDL_WinRT_Path*


NAME
       SDL_WinRT_Path -- Enumerations

SYNOPSIS
       An enumeration of WinRT / Windows Phone path types.

DESCRIPTION
       Values

       ┌────────────────────────────────────┬──────────────────────────────┐
       │ SDL_WINRT_PATH_INSTALLED_LOCATION  │ the  installed  apps's  root │
       │                                    │ directory;  files  here  are │
       │                                    │ likely to be read-only       │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINRT_PATH_LOCAL_FOLDER        │ the  app's local data store; │
       │                                    │ files may be written here    │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINRT_PATH_ROAMING_FOLDER      │ the app's roaming data store │
       │                                    │ (unsupported    on   Windows │
       │                                    │ Phone); files  written  here │
       │                                    │ may  be  copied to other ma‐ │
       │                                    │ chines via a network connec‐ │
       │                                    │ tion.                        │
       ├────────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINRT_PATH_TEMP_FOLDER         │ the   app's  temporary  data │
       │                                    │ store (unsupported  on  Win‐ │
       │                                    │ dows  Phone);  files written │
       │                                    │ here may be deleted  at  any │
       │                                    │ time                         │
       └────────────────────────────────────┴──────────────────────────────┘

VERSIONS
       This enumeration is available since SDL 2.0.3.

RELATED FUNCTIONS
       SDL_WinRTGetFSPathUNICODE
       SDL_WinRTGetFSPathUTF8

===============================================================================
                                                              *SDL_WindowEvent*


NAME
       SDL_WindowEvent -- Structure

SYNOPSIS
       A structure that contains window state change event data.

DATA FIELDS
       ┌─────────┬───────────┬───────────────────────┐
       │ Uint32  │ type      │ SDL_WINDOWEVENT       │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ timestamp │ timestamp    of   the │
       │         │           │ event                 │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint32  │ windowID  │ the associated window │
       ├─────────┼───────────┼───────────────────────┤
       │ Uint8   │ event     │ SDL_WindowEventID     │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ data1     │ event dependent data  │
       ├─────────┼───────────┼───────────────────────┤
       │ Sint32  │ data2     │ event dependent data  │
       └─────────┴───────────┴───────────────────────┘

CODE EXAMPLES
       ┌────────────────────────────────────────────────────┐
       │ void PrintEvent(const SDL_Event *event)            │
       │ {                                                  │
       │   if (event->type == SDL_WINDOWEVENT) {            │
       │     switch (event->window.event) {                 │
       │     case SDL_WINDOWEVENT_SHOWN:                    │
       │       SDL_Log("Window %d shown",                   │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_HIDDEN:                   │
       │       SDL_Log("Window %d hidden",                  │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_EXPOSED:                  │
       │       SDL_Log("Window %d exposed",                 │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_MOVED:                    │
       │       SDL_Log("Window %d moved to %d, %d",         │
       │         event->window.windowID,                    │
       │         event->window.data1,                       │
       │         event->window.data2);                      │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_RESIZED:                  │
       │       SDL_Log("Window %d resized to %dx%d",        │
       │         event->window.windowID,                    │
       │         event->window.data1,                       │
       │         event->window.data2);                      │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_SIZE_CHANGED:             │
       │       SDL_Log("Window %d size changed to %dx%d",   │
       │         event->window.windowID,                    │
       │         event->window.data1,                       │
       │         event->window.data2);                      │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_MINIMIZED:                │
       │       SDL_Log("Window %d minimized",               │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_MAXIMIZED:                │
       │       SDL_Log("Window %d maximized",               │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_RESTORED:                 │
       │       SDL_Log("Window %d restored",                │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_ENTER:                    │
       │       SDL_Log("Mouse entered window %d",           │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_LEAVE:                    │
       │       SDL_Log("Mouse left window %d",              │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_FOCUS_GAINED:             │
       │       SDL_Log("Window %d gained keyboard focus",   │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_FOCUS_LOST:               │
       │       SDL_Log("Window %d lost keyboard focus",     │
       │         event->window.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_CLOSE:                    │
       │       SDL_Log("Window %d closed",                  │
       │         event->window.windowID);                   │
       │       break;                                       │
       │ #if SDL_VERSION_ATLEAST(2, 0, 5)                   │
       │     case SDL_WINDOWEVENT_TAKE_FOCUS:               │
       │       SDL_Log("Window %d is offered a focus",      │
       │         event->widnow.windowID);                   │
       │       break;                                       │
       │     case SDL_WINDOWEVENT_HIT_TEST:                 │
       │       SDL_Log("Window %d has a special hit test",  │
       │         event->window.windowID);                   │
       │       break;                                       │
       │ #endif                                             │
       │     default:                                       │
       │       SDL_Log("Window %d got unknown event %d",    │
       │         event->window.windowID,                    │
       │         event->window.event);                      │
       │       break;                                       │
       │     }                                              │
       │   }                                                │
       │ }                                                  │
       └────────────────────────────────────────────────────┘

REMARKS
       SDL_WindowEvent is a member of the SDL_Event union and is used when  an  event
       of  type  SDL_WINDOWEVENT is reported. You would access it through the event's
       window field.

RELATED ENUMERATIONS
       SDL_EventType
       SDL_WindowEventID

RELATED STRUCTURES
       SDL_Event

===============================================================================
                                                            *SDL_WindowEventID*


NAME
       SDL_WindowEventID -- Enumerations

SYNOPSIS
       An enumeration of window events.

DESCRIPTION
       Values

       ┌───────────────────────────────┬──────────────────────────────┐
       │ SDL_WINDOWEVENT_NONE          │ (never used)                 │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_SHOWN         │ window has been shown        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_HIDDEN        │ window has been hidden       │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_EXPOSED       │ window  has been exposed and │
       │                               │ should be redrawn            │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_MOVED         │ window  has  been  moved  to │
       │                               │ data1, data2                 │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_RESIZED       │ window  has  been resized to │
       │                               │ data1xdata2; this  event  is │
       │                               │ always  preceded by SDL_WIN‐ │
       │                               │ DOWEVENT_SIZE_CHANGED        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_SIZE_CHANGED  │ window size has changed, ei‐ │
       │                               │ ther  as  a result of an API │
       │                               │ call or through  the  system │
       │                               │ or  user changing the window │
       │                               │ size; this event is followed │
       │                               │ by   SDL_WINDOWEVENT_RESIZED │
       │                               │ if the size was  changed  by │
       │                               │ an  external event, i.e. the │
       │                               │ user or the window manager.  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_MINIMIZED     │ window has been minimized    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_MAXIMIZED     │ window has been maximized    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_RESTORED      │ window has been restored  to │
       │                               │ normal size and position     │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_ENTER         │ window  has gained mouse fo‐ │
       │                               │ cus                          │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_LEAVE         │ window has lost mouse focus  │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_FOCUS_GAINED  │ window has  gained  keyboard │
       │                               │ focus                        │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_FOCUS_LOST    │ window has lost keyboard fo‐ │
       │                               │ cus                          │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_CLOSE         │ the window manager  requests │
       │                               │ that the window be closed    │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_TAKE_FOCUS    │ window  is  being  offered a │
       │                               │ focus (should SDL_SetWindow‐ │
       │                               │ InputFocus()  on itself or a │
       │                               │ subwindow,  or  ignore)  (>= │
       │                               │ SDL 2.0.5)                   │
       ├───────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOWEVENT_HIT_TEST      │ window  had  a hit test that │
       │                               │ wasn't    SDL_HITTEST_NORMAL │
       │                               │ (>= SDL 2.0.5)               │
       └───────────────────────────────┴──────────────────────────────┘

CODE EXAMPLES
       #include <stdlib.h>
       #include "SDL.h"

       int main(int argc, char *argv[]) {
         int width = 640;
         int height = 480;

         if (SDL_Init(SDL_INIT_VIDEO) != 0) {
           return 1;
         }
         atexit(SDL_QUIT);

         SDL_Window* window = SDL_CreateWindow("Example", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_RESIZABLE);
         Uint32 windowID = SDL_GetWindowID(window);

         while(1) {
           SDL_Event event;
           while (SDL_PollEvent(&event)) {
             switch (event.type) {
               case SDL_WINDOWEVENT: {
                 if (event.window.windowID == windowID) {
                   switch (event.window.event) {
                     case SDL_WINDOWEVENT_SIZE_CHANGED: {
                       width = event.window.data1;
                       height = event.window.data2;
                       break;
                     }

                     case SDL_WINDOWEVENT_CLOSE: {
                       event.type = SDL_QUIT;
                       SDL_PushEvent(&event);
                       break;
                     }
                   }
                 }
                 break;
               }

               case SDL_QUIT: {
                 return 0;
               }

               /* ... */
             }
           }

           /* ... */

           SDL_Delay(1);
         }
       }

RELATED STRUCTURES
       SDL_WindowEvent

RELATED FUNCTIONS
       SDL_GetWindowFormID
       SDL_GetWindowID

===============================================================================
                                                              *SDL_WindowFlags*


NAME
       SDL_WindowFlags -- Enumerations

SYNOPSIS
       An enumeration of window states.

DESCRIPTION
       Values

       ┌────────────────────────────────┬──────────────────────────────┐
       │ SDL_WINDOW_FULLSCREEN          │ fullscreen window            │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_FULLSCREEN_DESKTOP  │ fullscreen  windnow  at  the │
       │                                │ current desktop resolution   │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_OPENGL              │ window  usable  with  OpenGL │
       │                                │ context                      │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_SHOWN               │ window is visible            │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_HIDDEN              │ window is not visible        │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_BORDERLESS          │ no window decoration         │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_RESIZABLE           │ window can be resized        │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MINIMIZED           │ window is minimized          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MAXIMIZED           │ window is maximized          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_INPUT_GRABBED       │ window has grabbed input fo‐ │
       │                                │ cus                          │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_INPUT_FOCUS         │ window has input fous        │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MOUSE_FOCUS         │ window has mouse focus       │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_FOREIGN             │ window not created by SDL    │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_ALLOW_HIGHDPI       │ window should be created  in │
       │                                │ high-DPI  mode  if supported │
       │                                │ (>= SDL 2.0.1)               │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_MOUSE_CAPTURE       │ window  has  mouse  captured │
       │                                │ (unrelated to INPUT_GRABBED, │
       │                                │ >= SDL 2.0.4)                │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_ALWAYS_ON_TOP       │ window  should   always   be │
       │                                │ above  others  (X11 only, >= │
       │                                │ SDL 2.0.5)                   │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_SKIP_TASKBAR        │ window should not  be  added │
       │                                │ to the taskbar (X11 only, >= │
       │                                │ SDL 2.0.5)                   │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_UTILITY             │ window should be treated  as │
       │                                │ a  utility window (X11 only, │
       │                                │ >= SDL 2.0.5)                │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_TOOLTIP             │ window should be treated  as │
       │                                │ a  tooltip (X11 only, >= SDL │
       │                                │ 2.0.5)                       │
       ├────────────────────────────────┼──────────────────────────────┤
       │ SDL_WINDOW_POPUP_MENU          │ window should be treated  as │
       │                                │ a  popup  menu (X11 only, >= │
       │                                │ SDL 2.0.5)                   │
       └────────────────────────────────┴──────────────────────────────┘

REMARKS
       The SDL_WINDOW_OPENGL flag prepares your window for use with OpenGL,  but  you
       will still need to create an OpenGL context using SDL_GL_CreateContext() after
       window creation, before calling any OpenGL functions.

       On Apple's OS X you must set the NSHighResolutionCapable  Info.plist  property
       to YES, otherwise you will not receive a high DPI OpenGL canvas.

VERSIONS
       This enumeration is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_CreateWindow
       SDL_GetWindowFlags
       SDL_HideWindow
       SDL_MaximizeWindow
       SDL_MinimizeWindow
       SDL_SetWindowFullscreen
       SDL_SetWindowGrab
       SDL_ShowWindow

===============================================================================
                                                                *SDL_WriteBE16*


NAME
       SDL_WriteBE16 -- Function

SYNOPSIS
       Use  this function to write 16 bits in native format to a SDL_RWops as big-en‐
       dian data.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ size_t SDL_WriteBE16(SDL_RWops*     dst,    │
       │                      Uint16         value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ dst    │ the  stream  to  which  data │
       │        │ will be written              │
       ├────────┼──────────────────────────────┤
       │ value  │ the  data  to be written, in │
       │        │ native format                │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on successful write, 0 on error.

REMARKS
       SDL byteswaps the data only if necessary, so the application always  specifies
       native format, and the data written will be in big-endian format.

RELATED FUNCTIONS
       SDL_WriteLE16

===============================================================================
                                                                *SDL_WriteBE32*


NAME
       SDL_WriteBE32 -- Function

SYNOPSIS
       Use  this function to write 32 bits in native format to a SDL_RWops as big-en‐
       dian data.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ size_t SDL_WriteBE32(SDL_RWops*     dst,    │
       │                      Uint32         value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ dst    │ the  stream  to  which  data │
       │        │ will be written              │
       ├────────┼──────────────────────────────┤
       │ value  │ the  data  to be written, in │
       │        │ native format                │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on success write, 0 on error.

REMARKS
       SDL byteswaps the data only if necessary, so the application always  specifies
       native format, and the data written will be in big-endian format.

RELATED FUNCTIONS
       SDL_WriteLE32

===============================================================================
                                                                *SDL_WriteBE64*


NAME
       SDL_WriteBE64 -- Function

SYNOPSIS
       Use  this function to write 64 bits in native format to a SDL_RWops as big-en‐
       dian data.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ size_t SDL_WriteBE64(SDL_RWops*     data,   │
       │                      Uint64         value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ dst    │ the  stream  to  which  data │
       │        │ will be written              │
       ├────────┼──────────────────────────────┤
       │ value  │ the  data  to be written, in │
       │        │ native format                │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on successful write, 0 on error

REMARKS
       SDL byteswaps the data only if necessary, so the application specifies  native
       format, and the data written will be in big-endian format.

RELATED FUNCTIONS
       SDL_WriteLE64

===============================================================================
                                                                *SDL_WriteLE16*


NAME
       SDL_WriteLE16 -- Function

SYNOPSIS
       Use  this function to write 16 bits in native format to a SDL_RWops as little-
       endian data.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ size_t SDL_WriteLE16(SDL_RWops*     dst,    │
       │                      Uint16         value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ dst    │ the  stream  to  which  data │
       │        │ will be written              │
       ├────────┼──────────────────────────────┤
       │ value  │ the  data  to be written, in │
       │        │ native format                │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on successful write, 0 on error.

REMARKS
       SDL byteswaps the data only if necessary, so the application always  specifies
       native format, and the data written will be in little-endian format.

RELATED FUNCTIONS
       SDL_WriteBE16

===============================================================================
                                                                *SDL_WriteLE32*


NAME
       SDL_WriteLE32 -- Function

SYNOPSIS
       Use  this function to write 32 bits in native format to a SDL_RWops as little-
       endian data.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ size_t SDL_WriteLE32(SDL_RWops*     dst,    │
       │                      Uint32         value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ dst    │ the  stream  to  which  data │
       │        │ will be written              │
       ├────────┼──────────────────────────────┤
       │ value  │ the  data  to be written, in │
       │        │ native format                │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on successful write, 0 on error

REMARKS
       SDL byteswaps the data only necessary, so the application always specifies na‐
       tive format, and the data written will be in little-endian format.

RELATED FUNCTIONS
       SDL_WriteBE32

===============================================================================
                                                                *SDL_WriteLE64*


NAME
       SDL_WriteLE64 -- Function

SYNOPSIS
       Use this function to write 64 bits in native format to SDL_RWops as little-en‐
       dian data.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ size_t SDL_WriteLE64(SDL_RWops*     dst,    │
       │                      Uint64         value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬──────────────────────────────┐
       │ dst    │ the  stream  to  which  data │
       │        │ will be written              │
       ├────────┼──────────────────────────────┤
       │ value  │ the  data  to be written, in │
       │        │ native format                │
       └────────┴──────────────────────────────┘

RETURN VALUE
       Returns 1 on successful write, 0 on error.

REMARKS
       SDL byteswaps the data only if necessary, so the application always  specifies
       native format, and the data written will be in little-endian format.

RELATED FUNCTIONS
       SDL_WriteBE64

===============================================================================
                                                                  *SDL_WriteU8*


NAME
       SDL_WriteU8 -- Function

SYNOPSIS
       Use this function to write a byte to an SDL_RWops.

SYNTAX
       ┌─────────────────────────────────────────────┐
       │ size_t SDL_WriteU8(SDL_RWops*       dst,    │
       │                    Uint8            value)  │
       └─────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────┬───────────────────────────┐
       │ dst    │ the SDL_RWops to write to │
       ├────────┼───────────────────────────┤
       │ value  │ the byte value to write   │
       └────────┴───────────────────────────┘

RETURN VALUE
       Returns  1  on  success or 0 on failure; call SDL_GetError() for more informa‐
       tion.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_ReadU8

===============================================================================
                                                                     *SDL_acos*


NAME
       SDL_acos -- Function

SYNOPSIS
       Use this function to compute arc cosine of x.

SYNTAX
       ┌─────────────────────────────────┐
       │ double SDL_acos(double      x)  │
       └─────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────┬──────────────────────────────┐
       │ x  │ floating point value, in ra‐ │
       │    │ dians                        │
       └────┴──────────────────────────────┘

RETURN VALUE
       Returns arc cosine of x.

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────┐
       │ /* acos(x) = Pi/2 - asin(x) */                           │
       │ SDL_Log("acos(0):\t\t%f", SDL_acos(0));                  │
       │ SDL_Log("Pi/2 - asin(0):\t%f", M_PI / 2 - SDL_asin(0));  │
       │                                                          │
       │ /* acos(-x) = Pi - acos(x) */                            │
       │ SDL_Log("acos(-(-1)):\t%f", SDL_acos(-(-1)));            │
       │ SDL_Log("Pi - acos(-1):\t%f", M_PI - SDL_acos(-1));      │
       └──────────────────────────────────────────────────────────┘

REMARKS
       The definition of y = acos(x) is x = cos(y).  Domain: -1 <= x <= 1 Range: 0 <=
       y <= Pi

VERSION
       This function is available since SDL 2.0.2.

===============================================================================
                                                                   *SDL_assert*


NAME
       SDL_assert -- Macro

SYNOPSIS
       Use this macro to create an assertion for debugging.

SYNTAX
       ┌─────────────────────────────┐
       │ void SDL_assert(condition)  │
       └─────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬─────────────────────────┐
       │ condition  │ the expression to check │
       └────────────┴─────────────────────────┘

CODE EXAMPLES
       ┌───────────────────────────────────────────────────────────┐
       │ SDL_assert(1 == 0);     // trigger an assertion           │
       │ SDL_assert(1 == 1);     // does NOT trigger an assertion  │
       └───────────────────────────────────────────────────────────┘

REMARKS
       This  macro is enabled only when the SDL_ASSERT_LEVEL is set to 2 or 3, other‐
       wise it is disabled.  See  the  Assertions  Category  page  (https://wiki.lib‐
       sdl.org/CategoryAssertions) for details.

RELATED FUNCTIONS
       SDL_assert_paranoid
       SDL_assert_release

===============================================================================
                                                              *SDL_assert_data*


NAME
       SDL_assert_data -- Structure

SYNOPSIS
       A structure that contains information about an assertion

DATA FIELDS
       ┌────────────────────────────────┬───────────────┬───────────────────────┐
       │ int                            │ always_ignore │ 1 if set, 0 otherwise │
       ├────────────────────────────────┼───────────────┼───────────────────────┤
       │ unsigned int                   │ trigger_count │ number  of times this │
       │                                │               │ assertion  was  trig‐ │
       │                                │               │ gered                 │
       ├────────────────────────────────┼───────────────┼───────────────────────┤
       │ const char*                    │ condition     │ the  assertion condi‐ │
       │                                │               │ tion to check         │
       ├────────────────────────────────┼───────────────┼───────────────────────┤
       │ const char*                    │ filename      │ theh file  containing │
       │                                │               │ the assertion         │
       ├────────────────────────────────┼───────────────┼───────────────────────┤
       │ int                            │ linenum       │ the  location  of the │
       │                                │               │ assertion in the file │
       ├────────────────────────────────┼───────────────┼───────────────────────┤
       │ const char*                    │ function      │ the function contain‐ │
       │                                │               │ ing the assertion     │
       ├────────────────────────────────┼───────────────┼───────────────────────┤
       │ const struct SDL_assert_data*  │ next          │ Pointer to next trig‐ │
       │                                │               │ gered     assertion's │
       │                                │               │ info                  │
       └────────────────────────────────┴───────────────┴───────────────────────┘

REMARKS
       This  structure  is filled in with information about the assertion and is used
       by the assertion handler then added to the assertion report. This is  returned
       as a linked list from SDL_GetAssertionReport().

RELATED FUNCTIONS
       SDL_assert
       SDL_assert_paranoid
       SDL_assert_release
       SDL_GetAssertionReport

===============================================================================
                                                          *SDL_assert_paranoid*


NAME
       SDL_assert_paranoid -- Macro

SYNOPSIS
       Use this macro to create an assertion for detailed checking.

SYNTAX
       ┌──────────────────────────────────────┐
       │ void SDL_assert_paranoid(condition)  │
       └──────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬─────────────────────────┐
       │ condition  │ the expression to check │
       └────────────┴─────────────────────────┘

REMARKS
       This  macro  is  disabled  by  default.  It is available for use only when the
       SDL_ASSERT_LEVEL  is  set   to   3.   See   the   Assertions   Category   page
       (https://wiki.libsdl.org/CategoryAssertions) for details.

RELATED FUNCTIONS
       SDL_assert
       SDL_assert_release

===============================================================================
                                                           *SDL_assert_release*


NAME
       SDL_assert_release -- Macro

SYNOPSIS
       Use this macro to create an assertion for detailed checking.

SYNTAX
       ┌─────────────────────────────────────┐
       │ void SDL_assert_release(condition)  │
       └─────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────┬─────────────────────────┐
       │ condition  │ the expression to check │
       └────────────┴─────────────────────────┘

REMARKS
       This  macro  is  enabled by default. It can be disabled by setting the SDL_AS‐
       SERT_LEVEL to 0. See the Assertions Category page(https://wiki.libsdl.org/Cat‐
       egoryAssertions).

RELATED FUNCTIONS
       SDL_assert
       SDL_assert_paranoid

===============================================================================
                                                                 *SDL_atomic_t*


NAME
       SDL_atomic_t -- Structure

SYNOPSIS
       A structure representing an atomic integer value.

DATA FIELDS
       ┌──────┬───────┬───────────────────────┐
       │ int  │ value │ the   atomic  integer │
       │      │       │ value                 │
       └──────┴───────┴───────────────────────┘

CODE EXAMPLES
       ┌──────────────────────────────────────────────────────────────────────────┐
       │ /* This is a simple fps counter program                                  │
       │  *                                                                       │
       │  * Timers in SDL are run in a separate thread                            │
       │  * so effort is needed to avoid data races                               │
       │  */                                                                      │
       │ SDL_atomic_t frames;                                                     │
       │                                                                          │
       │ /* Calculate and display the average framerate over the set interval */  │
       │ Uint32 fps_timer_callback(Uint32 interval, void *data)                   │
       │ {                                                                        │
       │   const float f = SDL_AtomicGet(&frames);                                │
       │   const float iv = (float)interval / 1000.0f;                            │
       │   printf("%.2f\tfps\n", f / iv);                                         │
       │                                                                          │
       │   /* Reset frame counter */                                              │
       │   SDL_AtomicSet(&frames, 0);                                             │
       │                                                                          │
       │   return interval;                                                       │
       │ }                                                                        │
       │                                                                          │
       │ int main(int argc, char **argv)                                          │
       │ {                                                                        │
       │   SDL_Init(SDL_INIT_EVERYTHING);                                         │
       │   SDL_Window *win = SDL_CreateWindow("Counter",                          │
       │                       SDL_WINDOWPOS_CENTERED,                            │
       │                       SDL_WINDOWPOS_CENTERED,                            │
       │                       640,                                               │
       │                       480,                                               │
       │                       0                                                  │
       │                       );                                                 │
       │                                                                          │
       │   SDL_Surface *screen = SDL_GetWindowSurface(win);                       │
       │                                                                          │
       │   /* Our timer will be run every five seconds in a separate thread */    │
       │   SDL_AddTimer(5000, fps_timer_callback, NULL);                          │
       │                                                                          │
       │   SDL_Event e;                                                           │
       │   while(1) {                                                             │
       │     while (SDL_PollEvent(&e) {                                           │
       │       if (e.type == SDL_QUIT) {                                          │
       │         goto quit;                                                       │
       │       }                                                                  │
       │     }                                                                    │
       │     SDL_FillRect(screen, NULL, 0xffffffff);                              │
       │     SDL_UpdateWindowSurface(win);                                        │
       │                                                                          │
       │     /* Add one frame */                                                  │
       │     SDL_AtomicAdd(&frames, 1);                                           │
       │   }                                                                      │
       │ quit:                                                                    │
       │   SDL_DestroyWindow(win);                                                │
       │   SDL_Quit();                                                            │
       │   return 0;                                                              │
       │ }                                                                        │
       └──────────────────────────────────────────────────────────────────────────┘

REMARKS
       SDL_atomic is a structure so people don't accidentally use  numeric  operation
       on it. Instead, you should use the atomic operation functions to work with the
       integer value.

RELATED FUNCTIONS
       SDL_AtomicAdd
       SDL_AtomicCAS
       SDL_AtomicDecRef
       SDL_AtomicGet
       SDL_AtomicIncRef
       SDL_AtomicSet

===============================================================================
                                                                     *SDL_bool*


NAME
       SDL_bool -- Enumerations

SYNOPSIS
       An enumeration of boolean values.

DESCRIPTION
       Values

       ┌────────────┬──────────────────────────────┐
       │ SDL_FALSE  │ value which is equal to 0 or │
       │            │ false                        │
       ├────────────┼──────────────────────────────┤
       │ SDL_TRUE   │ value which is equal to 1 or │
       │            │ true                         │
       └────────────┴──────────────────────────────┘

REMARKS
       Every function, structure, class etc. will work with SDL_bool.

===============================================================================
                                               *SDL_iPhoneSetAnimationCallback*


NAME
       SDL_iPhoneSetAnimationCallback -- Function

SYNOPSIS
       Use this function to set the animation callback on Apple iOS.

SYNTAX
       ┌─────────────────────────────────────────────────────────────────────┐
       │ int SDL_iPhoneSetAnimationCallback(SDL_Window*      window,         │
       │                                    int              interval,       │
       │                                    void (*callback)(void*),         │
       │                                    void*            callbackParam)  │
       └─────────────────────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌────────────────┬──────────────────────────────┐
       │ window         │ the window for which the an‐ │
       │                │ imation callback  should  be │
       │                │ set                          │
       ├────────────────┼──────────────────────────────┤
       │ interval       │ the  number  of frames after │
       │                │ which   callback   will   be │
       │                │ called                       │
       ├────────────────┼──────────────────────────────┤
       │ callback       │ the function to call for ev‐ │
       │                │ ery frame; see  Remarks  for │
       │                │ details                      │
       ├────────────────┼──────────────────────────────┤
       │ callbackParam  │ a  pointer that is passed to │
       │                │ callback                     │
       └────────────────┴──────────────────────────────┘

RETURN VALUE
       Returns 0 on success or a negative error code on failure; call  SDL_GetError()
       for more information.

REMARKS
       The function prototype for callback is:

       ┌─────────────────────────────────────────┐
       │ void callback(void*     callbackParam)  │
       └─────────────────────────────────────────┘
       where its parameters are:

       ┌────────────────┬──────────────────────────────┐
       │ callbackParam  │ what was passed as callback‐ │
       │                │ Param to SDL_iPhoneSetAnima‐ │
       │                │ tionCallback()               │
       └────────────────┴──────────────────────────────┘
       This function is only available on Apple iOS.

       For  more  information  see: README-ios.md (https://hg.libsdl.org/SDL/file/de‐
       fault/docs/README-ios.md).

       This function is also accessible using the macro SDL_iOSSetAnimationCallback()
       since SDL 2.0.4.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_iPhoneSetEventPump

===============================================================================
                                                       *SDL_iPhoneSetEventPump*


NAME
       SDL_iPhoneSetEventPump -- Function

SYNOPSIS
       Use this function to enable or disable the SDL event pump on Apple iOS.

SYNTAX
       ┌───────────────────────────────────────────────────────┐
       │ void SDL_iPhoneSetEventPump(SDL_bool        enabled)  │
       └───────────────────────────────────────────────────────┘

FUNCTION PARAMETERS
       ┌──────────┬──────────────────────────────┐
       │ enabled  │ SDL_TRUE to enable the event │
       │          │ pump, SDL_FALSE  to  disable │
       │          │ it                           │
       └──────────┴──────────────────────────────┘

REMARKS
       This function is only available on Apple iOS.

       This  function  is also accessible using the macro SDL_iOSSetEventPump() since
       SDL 2.0.4.

VERSION
       This function is available since SDL 2.0.0.

RELATED FUNCTIONS
       SDL_iPhoneSetAnimationCallback

===============================================================================
                                                                   *SDL_keysym*


NAME
       SDL_keysym - Keysym structure

STRUCTURE DEFINITION
       typedef struct{
         Uint8 scancode;
         SDLKey sym;
         SDLMod mod;
         Uint16 unicode;
       } SDL_keysym;

STRUCTURE DATA
       scancode            Hardware specific scancode

       sym                 SDL virtual keysym

       mod                 Current key modifiers

       unicode             Translated character

DESCRIPTION
       The  SDL_keysym  structure is used by reporting key presses and releases since
       it is a part of the SDL_KeyboardEvent.

       The scancode field should generally be left alone, it is the  hardware  depen‐
       dent  scancode returned by the keyboard. The sym field is extremely useful. It
       is the SDL-defined value of the key (see SDL Key Syms. This field is very use‐
       ful when you are checking for certain key presses, like so:

       .
       .
       while(SDL_PollEvent(&event)){
         switch(event.type){
           case SDL_KEYDOWN:
             if(event.key.keysym.sym==SDLK_LEFT)
               move_left();
             break;
           .
           .
           .
         }
       }
       .
       .

        mod  stores  the  current  state  of  the  keyboard modifiers as explained in
       SDL_GetModState. The unicode is only used when UNICODE translation is  enabled
       with SDL_EnableUNICODE. If unicode is non-zero then this a the UNICODE charac‐
       ter corresponding to the keypress. If the high 9 bits of the character are  0,
       then this maps to the equivalent ASCII character:

       char ch;
       if ( (keysym.unicode & 0xFF80) == 0 ) {
         ch = keysym.unicode & 0x7F;
       }
       else {
         printf("An International Character.
       ");
       }

        UNICODE translation does have a slight overhead so don't enable it unless its
       needed.

SEE ALSO
       SDLKey

===============================================================================
                                                                   *SDL_mutexP*


NAME
       SDL_mutexP - Lock a mutex

SYNOPSIS
       #include "SDL.h" #include "SDL_thread.h"

       int SDL_mutexP(SDL_mutex *mutex);

DESCRIPTION
       Locks the mutex, which was previously created with SDL_CreateMutex. If the mu‐
       tex is already locked then SDL_mutexP will not return until  it  is  unlocked.
       Returns 0 on success, or -1 on an error.

       SDL also defines a macro #define SDL_LockMutex(m) SDL_mutexP(m).

SEE ALSO
       SDL_CreateMutex, SDL_mutexV

===============================================================================
                                                                   *SDL_mutexV*


NAME
       SDL_mutexV - Unlock a mutex

SYNOPSIS
       #include "SDL.h" #include "SDL_thread.h"

       int SDL_mutexV(SDL_mutex *mutex);

DESCRIPTION
       Unlocks  the mutex, which was previously created with SDL_CreateMutex. Returns
       0 on success, or -1 on an error.

       SDL also defines a macro #define SDL_UnlockMutex(m) SDL_mutexV(m).

SEE ALSO
       SDL_CreateMutex, SDL_mutexP

===============================================================================
                                                                  *SDL_version*


NAME
       SDL_version -- Structure

SYNOPSIS
       A structure that contains information about the version of SDL in use.

DATA FIELDS
       ┌────────┬───────┬───────────────────────┐
       │ Uint8  │ major │ major version         │
       ├────────┼───────┼───────────────────────┤
       │ Uint8  │ minor │ minor version         │
       ├────────┼───────┼───────────────────────┤
       │ Uint8  │ patch │ update        version │
       │        │       │ (patchlevel)          │
       └────────┴───────┴───────────────────────┘

CODE EXAMPLES
       ┌─────────────────────────────────────────────────────────────┐
       │ SDL_version compiled;                                       │
       │ SDL_version linked;                                         │
       │                                                             │
       │ SDL_VERSION(&compiled);                                     │
       │ SDL_GetVersion(&linked);                                    │
       │ printf("We compiled against SDL version %d.%d.%d ...0,      │
       │   compiled.major, compiled.minor, compiled.patch);          │
       │ printf("But we are linking against SDL version %d.%d.%d.0,  │
       │   linked.major, linked.minor, linked.patch);                │
       └─────────────────────────────────────────────────────────────┘

REMARKS
       Represents the library's version as three levels:

       major revision
            (increments with massive changes, additions, and enhancements)

       minor revision
            (increments with backwards-compatible changes to the major revision), and

       patchlevel
            (increments with fixes to the minor revision)

       The macro SDL_VERSION can be used to populate this structure with information.

RELATED MACROS
       SDL_COMPILEDVERSION
       SDL_VERSION
       SDL_VERSIONNUM
       SDL_VERSION_ATLEAST

RELATED FUNCTIONS
       SDL_GetVersion

===============================================================================
*SLDNet*
===============================================================================
                                                        *SDLNet_Linked_Version*

const SDLNet_version * SDLNet_Linked_Version(void);

const SDL_version *SDLNet_Linked_Version()
void SDL_NET_VERSION(SDL_version *compile_version)

This works similar to SDL_Linked_Version and SDL_VERSION.
Using these you can compare the runtime version to the version that you compiled with.
No prior library initialization is needed to call these functions/macros.

>
	SDL_version compile_version;
	const SDL_version *link_version=SDLNet_Linked_Version();
	SDL_NET_VERSION(&compile_version);
	printf("compiled with SDL_net version: %d.%d.%d\n", 
					compile_version.major,
					compile_version.minor,
					compile_version.patch);
	printf("running with SDL_net version: %d.%d.%d\n", 
					link_version->major,
					link_version->minor,
					link_version->patch);
<
See Also:
|SDLNet_Init|
===============================================================================
                                                                  *SDLNet_Init*
int SDLNet_Init(void);

SDLNet_Init - Initialize the network API.
This must be called before using other functions in this library.
Returns 0 on success, -1 on errors.
Note: SDL must be initialized before this call.
>
	if(SDL_Init(0)==-1)
	{
		printf("SDL_Init: %s\n",SDL_GetError());
		exit(1);
	}
	if(SDLNet_Init()==-1)
	{
		printf("SDLNet_Init: %s\n",SDL_GetError());
		exit(2);
	}
<

See Also
|SDLNet_Quit|
===============================================================================
                                                                  *SDLNet_Quit*
void SDLNet_Quit(void);

SDLNet_Quit - Shut down and cleanup the network API.
After calling this all sockets are closed,and the 
SDL_net functions should not be used. You may, of course,
use SDLNet_Init to use the functionality again.

See Also
|SDLNet_Init|
===============================================================================
                                                           *SDLNet_ResolveHost*

int SDLNet_ResolveHost(IPaddress *address,const char *host,Uint16 port);

SDLNet_ResolveHost resolve the string host, and fill in the IPaddress 
pointed to by address with the resolved IP and the port number passed 
in through port. This is the best way to fill in the IPaddress struct 
for later use. This function does not actually open any sockets, it 
is used to prepare the arguments for the socket opening functions.

Warning: this function will put the host and port into Network Byte Order 
into the address fields, so make sure you pass in the data in your 
hosts byte order. (normally not an issue)

Returns 0 on success. -1 on errors, plus address.host will be INADDR_NONE. 
An error would likely be that the address could not be resolved.

Example >
	For a server listening on all interfaces, on port 1234:
	
	// create a server type IPaddress on port 1234
	IPaddress ipaddress;
	SDLNet_ResolveHost(&ipaddress, NULL, 1234);
	For a client connecting to "host.domain.ext", at port 1234:
	
	// create an IPaddress for host name "host.domain.ext" on port 1234
	// this is used by a client
	IPaddress ipaddress;
	SDLNet_ResolveHost(&ipaddress, "host.domain.ext", 1234);
<
See Also
|SDLNet_ResolveIP|, |IPaddress|
===============================================================================
                                                             *SDLNet_ResolveIP*

const char * SDLNet_ResolveIP(const IPaddress *ip);

Returns a valid char pointer (string) on success. The returned hostname will
have host and domain, as in "host.domain.ext". NULL is returned on errors,
such as when it's not able to resolve the host name. The returned pointer is
not to be freed. Each time you call this function the previous pointer's data
will change to the new value, so you may have to copy it into a local buffer
to keep it around longer.

Example >
	/* Resolve the host name of the address in ipaddress
	IPaddress ipaddress;
	const char *host;
	if(!host = SDLNet_ResolveIP(&ipaddress)))
	{
		printf("SDLNet_ResolveIP: %s\n",SDLNet_GetError());
		exit(1);
	}
<
See Also
|SLDNet_ResolveHost|,|IPaddress|
===============================================================================
                                                     *SDLNet_GetLocalAddresses*

int SDLNet_GetLocalAddresses(IPaddress *addresses,int maxcount);
===============================================================================
                                                              *SDLNet_TCP_Open*

TCPsocket SDLNet_TCP_Open(IPaddress *ip);

Connect ot the host and port contained in ip using a TCP connection.
If the host is INADDR_ANY, then only the port number is used, and the socket
is created that can be used to later accept incoming TCP connections.

Returns a valid TCPsocket on success,which indicates a successful connection
has been established, or a socket has been created that is valid to accept
incoming TCP connections. NULL is returned on errors, such as when its not
able to create a socket, or it cannot connect to host and/or port contained
int ip

Example >
	/* To connect to localhost at port 9999 using TCP (client): */
	IPaddress ip;
	TCPsocket tcpsock;
	if(SDLNet_ResolveHost(&ip,"localhost",9999 == -1)
	{
		printf("SDLNet_ResolveHost: %s\n",SDLNet_GetError());
		exit(1);
	}
	tcpsock = SDLNet_TCP_Open(&ip);
	if(!tcpsock)
	{
		printf("SDLNet_TCP_Open: %s\n",SDLNet_GetError());
		exit(2);
	}

	/* To create a listening TCP socket on port 9999 (server): */
	IPaddress ip;
	TCPsocket tcpsock;
	if(SDLNet_ResolveHost(&ip,NULL,9999) == -1)
	{
		printf("SDLNet_ResolveHost: %s\n",SDLNet_GetError());
		exit(1);
	}
	tcpsock = SDLNet_TCP_Open(&ip);
	if(!tcpsock)
	{
		printf("SDLNet_TCP_Open: %s\n",SDLNet_GetError());
		exit(2);
	}
<
See Also
|SDLNet_TCP_Accept|,|SDLNet_TCP_Close|,|IPaddress|,|TCPsocket|
===============================================================================
                                                            *SDLNet_TCP_Accept*

TCPsocket SDLNet_TCP_Accept(TCPsocket server);

Accept an incoming connection on the server TCPsocket. Do not use this
function on a connected socket. Server sockets are never connected to a 
remote host. What you get back is a new TCPsocket that is connected to the
remote host. This is a non-blocking call, so if no connections are there to
be accepted, you will get a NULL TCPsocket and the program will continue going.

Returns a valid TCPsocket on success, which indicates a successful connection
has been established. NULL is returned on errors, such as when it's not able
to create a socket, or it cannot finish connecting to the originating host
and port. There also may not be a connection attempt in progress, so of
course you cannot accept nothing, and you get a NULL in this case as well.

Example >
	TCPsocket new_tcpsock;
	new_tcpsock = SDLNet_TCP_Accept(server_tcpsock);
	if(!new_tcpsock)
	{
		printf("SDLNet_TCP_Accept: %s\n",SDLNet_GetError()):
	}
	else
	{
		/* communicate over new_tcpsock */
	}
<
See Also
|SDLNet_TCP_Open|,|SDLNet_TCP_GetPeerAddress|,|SDLNet_TCP_Close|,|TCPsocket|
===============================================================================
                                                    *SDLNet_TCP_GetPeerAddress*

IPaddress * SDLNet_TCP_GetPeerAddress(TCPsocket sock);

SDLNet_TCP_GetPeerAddress returns the address of the peer's end of the socket.
This contains the peer's IP address and the TCP port number of that end of 
the connection. This function is commonly used in servers after a call to 
|SDLNet_TCP_Accept|. A server would use this function to get the address
of a new client who just connected.

Returns a pointer to an IPaddress structure which contains the host and port
fields, in network byte order. This pointer is valid until the socket is
closed with |SDLNet_TCP_Close|.

Returns NULL if the socket is a server socket (used for listening).

Example >
	TCPsocket new_tcpsock;
	IPaddress *remote_ip;
	remote_ip = SDLNet_TCP_GetPeerAddress(new_tcpsock);
	if(!remote_ip)
	{
		printf("SDLNet_TCP_GetPeerAddress: %s\n",SDLNet_GetError());
	}
	else
	{
		/* print the info in IPaddress or something else */
	}
<
See Also
|SDLNet_TCP_Open|,|SDLNet_TCP_Accept|,|IPaddress|,|TCPsocket|
===============================================================================
                                                              *SDLNet_TCP_Send*

int SDLNet_TCP_Send(TCPsocket sock,const void *data,int len);

SOCK is a valid, connected, TCPsocket.
DATA is a pointer to the data that will be sent.
LEN is the length(in bytes) of the data.

SDLNet_TCP_Send sends the data over the socket. If the data cannot be sent
immediatly, the routine waits until all of the data may be delivered
properly (it is a blocking operation). This routine is not used for server
sockets.

Returns the number of bytes sent. If the number returned is less than len,
an error occured, such as the client disconnecting.

Example >
	TCPsocket sock;
	int len,result;
	char *msg = "Hello!";
	len = strlen(msg) + 1;
	result = SDLNet_TCP_Send(sock,msg,len);
	if(result < len)
	{
		printf("SDLNet_TCP_Send: %s\n",SDLNet_GetError());
	}
<
See Also
|SDLNet_TCP_Recv|,|SDLNet_TCP_Accept|,|SDLNet_TCP_Open|,
|SDLNet_TCP_GetPeerAddress|,|SDLNet_TCP_Close|,|TCPsocket|
===============================================================================
                                                              *SDLNet_TCP_Recv*

int SDLNet_TCP_Recv(TCPsocket sock,void *data,int maxlen);

SOCK is a valid, connected TCPsocket.
DATA is a pointer to the buffer that receives the data from SOCK.
MAXLEN is the maximum length (in bytes) that will be read.


SDLNet_TCP_Recv gets available data that has been received on the socket. 
Up to maxlen bytes of data is read and stored in the location referenced 
by data. If no data has been received on the socket, this routine 
waits (blocks) until some comes in. The actual number of bytes copied into 
the location may be less than maxlen bytes.

A non-blocking way of using this function is to check the socket with 
|SDLNet_CheckSockets| and |SDLNet_SocketReady| and call SDLNet_TCP_Recv 
only if the socket is active.

Because of the behavior of TCP, a block of data sent by the peer will 
usually not be read at one time with SDLNet_TCP_Recv. TCP is a streaming 
protocol. This means that data will always be delivered in order, 
but not necessarily in the same chunks that it was sent. Applications that 
communicate with lines of text may need to call this routine several times 
and check for a newline character.

This routine is not used for server listening sockets.

Returns the number of bytes received. A return value of -1 indicates an error. 
A return value of 0 indicates that the connection was closed by the peer.

Example >

	// receive some text from sock
	//TCPsocket sock;
	#define MAXLEN 1024
	int result;
	char msg[MAXLEN];
	
	result = SDLNet_TCP_Recv(sock,msg,MAXLEN-1);
	if(result <= 0) {
	    // TCP Connection is broken. (because of error or closure)
	    SDLNet_TCP_Close(sock);
	    exit(1);
	}
	else {
	    msg[result] = 0;
	    printf("Received: \"%s\"\n",msg);
	}
<
See Also
|SDLNet_TCP_Send|,|SDLNet_TCP_Accept|,|SDLNet_TCP_Open|,
|SDLNet_TCP_GetPeerAddress|,|SDLNet_TCP_Close|,|TCPsocket|
===============================================================================
                                                             *SDLNet_TCP_Close*

void SDLNet_TCP_Close(TCPsocket sock);

This shuts down, disconnects, and closes the TCPsocket sock. After this,
you can be assured that this socket is not in use anymore. Your can reuse the
sock variable after this to open a new connection with |SDLNet_TCP_Open|.
Do not try to use any other functions on a closed socket, as it is now invalid.

See Also
|SDLNet_TCP_Open|,|TCPsocket|
===============================================================================
                                                           *SDLNet_AllocPacket*

UDPpacket * SDLNet_AllocPacket(int size);

SIZE in bytes of the new data packet to be allocated.
Create (via malloc) a new UDPpacket with a data buffer of SIZE bytes.
The new packet should be freed using |SDLNet_FreePacket| when you are
done using it.
Returns a pointer to a new UDPpacket. Null is returned on errors.

Example >
	UDPpacket *packet;
	packet = SDLNet_AllocPacket(1024);
	if(!packet)
	{
		printf("SDLNet_AllocPacket: %s\n",SDLNet_GetError());
	}
	else
	{
		/* Free packet when finished with it. */
	}
<
See Also
|SDLNet_AllocPacketV|,|SDLNet_ResizePacket|,|SDLNet_FreePacket|
|SDLNet_UDP_Send|,|SDLNet_UDP_SendV|,|UDPpacket|
===============================================================================
                                                          *SDLNet_ResizePacket*

int SDLNet_ResizePacket(UDPpacket *packet,int newsize);

PACKET: A pointer to the packet to be resized.
NEWSIZE: The new desired size in bytes. Zero is invalid.
Returns the new size of the data in the packet. If the number returned is
less than what was requested, an error occurs.

Example >
	UDPpacket *packet;
	int newsize;
	newsize = SDLNet_ResizePacket(packet,2048);
	if(newsize < 2048)
	{
		printf("SDLNet_ResizePacket: %s\n",SDLNet_GetError());
	}
	else
	{
		/* Use the packet. */
	}
<
See Also
|SDLNet_AllocPacket|,|SDLNet_AllocPacketV|,|SDLNet_FreePacket|,|UDPpacket|
===============================================================================
                                                            *SDLNet_FreePacket*

void SDLNet_FreePacket(UDPpacket *packet);

PACKET: A pointer to the data to be freed from memory.
Free a UDPpacket. Do not use this UDPpacket after this function has
been called on it.
Returns nothing. This always succeeds.

Example >
	UDPpacket *packet;
	SDLNet_FreePacket(packet);
<
See Also
|SDLNet_AllocPacket|,|SDLNet_AllocPacketV|,|SDLNet_FreePacketV|
|SDLNet_ResizePacket|,|UDPpacket|
===============================================================================
                                                          *SDLNet_AllocPacketV*

UDPpacket ** SDLNet_AllocPacketV(int howmany,int size);

HOWMANY: The number of UDPpackets to allocate.
SIZE: The size, in bytes, of the data buffers to be allocated
in the new UDPpackets.
Create (via malloc) a vector of new UDPpackets, each with data buffers
in SIZE bytes. The new packet vector should be freed using 
|SDLNet_FreePacketV| when you are done with it. The returned vector
is one entry longer than requested for a terminating NULL.
Returns a pointer to a new empty UDPpacket vector. NULL is returned
on errors, such as out of memory.

Example >
	UDPpacket **packetV;
	packetV = SDLNet_AllocPacketV(10,1024);
	if(!packetV)
	{
		printf("SDLNet_AllocPacketV: %s\n",SDLNet_GetError());
	}
	else
	{
		/* SDLNet_FreePacketV this packed vector when finished with it. */
	}
<
See Also
|SDLNet_AllocPacket|,|SDLNet_FreePacket|,|SDLNet_FreePacketV|,
|SDLNet_ResizePacket|,|UDPpacket|
===============================================================================
                                                           *SDLNet_FreePacketV*

void SDLNet_FreePacketV(UDPpacket **packetV);

PACKETV: A pointer to a UDPpacket vector to be freed.
Free a UDPpacket vector from memory. Do not use this UDPpacket vector, or
any UDPpacket in it after this function is called on it.

Example >
	UDPpacket **packetV;
	SDLNet_FreePacketV(packetV);
<
See Also
|SDLNet_AllocPacketV|,|SDLNet_AllocPacket|,|SDLNet_FreePacket|,
|SDLNet_ResizePacket|,|UDPpacket|
===============================================================================
                                                              *SDLNet_UDP_Open*

UDPsocket SDLNet_UDP_Open(Uint16 port);

PORT: This is the port number (in native byte order) on which to receive
UDP packets. Most servers will want to use a known port number here so
that clients can easily communicate with the server. This can also be 
zero, which then opens up an anonymous unused port number, to most likely
to be used to send UDP packets from.
Open a socket to be used for UDP packet sending and/or receiving. If a
nonzero port is given it will be used, otherwise any port number will
be used automatically. Unlike TCP sockets, this socket does not require
a remote host IP to connect to. This is because UDP ports are never
actually connected like TCP ports are.

This socket is able to send and receive directly after this simple creation.

Returns: a valid UDPsocket on success. NULL is returned on errors, such 
as when it's not able to create a socket, or it cannot assign the 
non-zero port as requested.

Note that below It says server, but clients may also open a specific port,
though it is prefered that a client be more flexible, given that the 
port may be already allocated by another process, such as a server. 
In such a case you will not be able to open the socket, and your program 
will be stuck, so it is better to just use whatever port you are given by 
using a specified port of zero. Then the client will always work. The client 
can inform the server what port to talk back to, or the server can just 
look at the source of the packets it is receiving to know where to respond to. 
However, if you want to communicate with clients behind NAT you'd better 
look at the source of the packets, because NAT routers might change the 
client port number as the packet passes the gateway.

Examples >
	
	// create a UDPsocket on port 6666 (server)
	UDPsocket udpsock;
	
	udpsock=SDLNet_UDP_Open(6666);
	if(!udpsock) {
	    printf("SDLNet_UDP_Open: %s\n", SDLNet_GetError());
	    exit(2);
	}
	
	// create a UDPsocket on any available port (client)
	UDPsocket udpsock;
	
	udpsock=SDLNet_UDP_Open(0);
	if(!udpsock) {
	    printf("SDLNet_UDP_Open: %s\n", SDLNet_GetError());
	    exit(2);
	}
See Also
|SDLNet_UDP_Close|,|UDPsocket|
===============================================================================
                                                     *SDLNet_UDP_SetPacketLoss*

void SDLNet_UDP_SetPacketLoss(UDPsocket sock,int percent);


===============================================================================
                                                              *SDLNet_UDP_Bind*

int SDLNet_UDP_Bind(UDPsocket sock,int channel,const IPaddress *address);

SOCK: The UDPsocket on which to assign the address.

CHANNEL: The channel to assign address to. This should be less than

SDLNET_MAX_UDPCHANNELS. If -1 is used, then the first unbound channel will 
be used, this should only be used for incomming packet filtering, as it will 
find the first channel with less than SDLNET_MAX_UDPADDRESSES assigned
to it and use that one.

ADDRESS: The resolved IPaddress to assign to the socket's channel.
The host and port are both used. It is not helpful to bind 0.0.0.0 to a channel.

Bind an address to a channel on a socket.

Incoming packets are only allowed from bound addresses for the socket channel.

All outgoing packets on that channel, regardless of the packets internal address,
will attempt to send once on each bound address on that channel.

You may assign up to SDLNET_MAX_UDPADDRESSES to each channel.

Returns: The channel number that was bound. -1 is returned on errors,
such as no free channels, or this channel has SDLNET_MAX_UDPADDRESSES
already assigned to it, or you have used a channel higher or equal to
SDLNET_MAX_UDPCHANNELS, or lower than -1.

Example >

	// Bind address to the first free channel
	UDPsocket udpsock;
	IPaddress *address;
	int channel;

	channel=SDLNet_UDP_Bind(udpsock, -1, address);
	if(channel==-1)
	{
			printf("SDLNet_UDP_Bind: %s\n", SDLNet_GetError());
			// do something because we failed to bind
	}
See Also
|SDLNet_UDP_Unbind|,|SDLNet_UDP_GetPeerAddress|,
|SDLNet_UDP_Open|,|IPaddress|,|UDPsocket|
===============================================================================
                                                            *SDLNet_UDP_Unbind*

void SDLNet_UDP_Unbind(UDPsocket sock,int channel);

SOCK: A valid UDPsocket to unbind addresses from.
CHANNEL: The channel to unbind the addresses from in the UDPsocket.

This removes all previously assigned (bound) addresses from a socket channel.

After this you may bind new addresses to the socket channel.

Returns: nothing, this always succeeds.

Example >

	// unbind all addresses on the UDPsocket channel 0
	UDPsocket udpsock;
	SDLNet_UDP_Unbind(udpsock, 0);
<
See Also
|SDLNet_UDP_Bind|,|SDLNet_UDP_Close|,|UDPsocket|
===============================================================================
                                                    *SDLNet_UDP_GetPeerAddress*

IPaddress * SDLNet_UDP_GetPeerAddress(UDPsocket sock,int channel);

SOCK: A valid UDPsocket that probably has an address assigned to the channel.
CHANNEL: The channel to get the primary address from in the socket. This may
also be -1 to get the port which this socket is bound to on the local computer.
Get the primary address assigned to this channel. Only the first bound 
address is returned. When channel is -1, get the port that this socket is
bound to on the local computer, this only means something if you opened
the socket with a specific port number. Do not free the returned IPaddress pointer.

Returns a pointer to an IPaddress. NULL is returned for unbound channels and on any errors.

Example >
	// get the primary address bound to UDPsocket channel 0
	UDPsocket udpsock;
	IPaddress *address;

	address=SDLNet_UDP_GetPeerAddress(udpsock, 0);
	if(!address) {
			printf("SDLNet_UDP_GetPeerAddress: %s\n", SDLNet_GetError());
			// do something because we failed to get the address
	}
	else {
			// perhaps print out address->host and address->port
	}
<
See Also
|SDLNet_UDP_Bind|,|SDLNet_UDP_Unbind|,|IPaddress|,|UDPsocket|
===============================================================================
                                                             *SDLNet_UDP_SendV*

int SDLNet_UDP_SendV(UDPsocket sock,UDPpacket **packets,int npackets);
SOCK: A valid UDPsocket.
PACKETV: The vector of packets to send.
NPACKETS: The number of packets in the packetV vector to send.
Send npackets of packetV using the specified sock socket.
Each packet is sent in the same way as in SDLNet_UDP_Send
(see section 3.4.6 SDLNet_UDP_Send). Don't forget to set the length of
the packets in the len element of the packets you are sending!

Returns the number of destinations sent to that worked, for each packet in the vector, all summed up. 0 is returned on errors.

Example >
	// send a vector of 10 packets using UDPsocket
	UDPsocket udpsock;
	UDPpacket **packetV;
	int numsent;

	numsent=SDLNet_UDP_SendV(udpsock, packetV, 10);
	if(!numsent) {
			printf("SDLNet_UDP_SendV: %s\n", SDLNet_GetError());
			// do something because we failed to send
			// this may just be because no addresses are bound to the channels...
	}
<
See Also
|SDLNet_UDP_Bind|,|SDLNet_UDP_Send|,|SDLNet_UDP_Recv|,
|SDLNet_UDP_RecvV|,|UDPpacket|,|UDPsocket|
===============================================================================
                                                              *SDLNet_UDP_Send*

int SDLNet_UDP_Send(UDPsocket sock,int channel,UDPpacket *packet);
SOCK: A valid UDPsocket.
CHANNEL: What channel to send packet on.
PACKET: The packet to send.
Send packet using the specified socket sock, use ing the specified channel
or else the packet's address. If channel is not -1 then the packet is sent to
all the socket channels bound addresses. If socket sock's channel is not
bound to any destinations, then the packet is not sent at all!
If the channel is -1, then the packet's address is used as the destination.
Don't forget to set the length of the packet in the len element of the
packet you are sending! Note: the packet->channel will be set to the
channel passed in to this function. Note: The maximum size of the packet is
limited by the MTU (Maximum Transfer Unit) of the transport medium.
It can be as low as 250 bytes for some PPP links, and as high as 1500 bytes
for ethernet. Beyond that limit the packet will fragment, and make delivery
more and more unreliable as lost fragments cause the whole packet to be discarded.

Returns the number of destinations sent to that worked. 0 is returned on errors.
Note that since a channel can point to multiple destinations,
there should be just as many packets sent, so dont assume it will always
return 1 on success. Unfortunately there's no way to get the number of
destinations bound to a channel, so either you have to remember the number
bound, or just test for the zero return value indicating all channels failed.

Example >
	// send a packet using a UDPsocket, using the packet's channel as the channel
	UDPsocket udpsock;
	UDPpacket *packet;
	int numsent;

	numsent=SDLNet_UDP_Send(udpsock, packet->channel, packet);
	if(!numsent) {
			printf("SDLNet_UDP_Send: %s\n", SDLNet_GetError());
			// do something because we failed to send
			// this may just be because no addresses are bound to the channel...
	}

	Here's a way of sending one packet using it's internal channel setting.
	This is actually what SDLNet_UDP_Send ends up calling for you.

		
	// send a packet using a UDPsocket, using the packet's channel as the channel
	UDPsocket udpsock;
	UDPpacket *packet;
	int numsent;

	numsent=SDLNet_UDP_SendV(sock, &packet, 1);
	if(!numsent) {
			printf("SDLNet_UDP_SendV: %s\n", SDLNet_GetError());
			// do something because we failed to send
			// this may just be because no addresses are bound to the channel...
	}
<
See Also
|SDLNet_UDP_Bind|,|SDLNet_UDP_SendV|,|SDLNet_UDP_Recv|,
|SDLNet_UDP_RecvV|,|UDPpacket|,|UDPsocket|
===============================================================================
                                                             *SDLNet_UDP_RecvV*

int SDLNet_UDP_RecvV(UDPsocket sock,UDPpacket **packets);

SOCK: A valid UDPsocket.
PACKET: The packet to receive into.
Receive into a packet vector on the specified socket sock.
packetV is a NULL terminated array. Packets will be received until the NULL
is reached, or there are none ready to be received.
This call is otherwise the same as SDLNet_UDP_Recv (see section 3.4.7 SDLNet_UDP_Recv).

Returns the number of packets received. 0 is returned when no packets are
received. -1 is returned on errors.

Example >
	// try to receive some waiting udp packets
	UDPsocket udpsock;
	UDPpacket **packetV;
	int numrecv, i;

	numrecv=SDLNet_UDP_RecvV(udpsock, &packetV);
	if(numrecv==-1) {
			// handle error, perhaps just print out the SDL_GetError string.
	}
	for(i=0; i<numrecv; i++) {
			// do something with packetV[i]
	}
<
See Also:
|SDLNet_UDP_Bind|,|SDLNet_UDP_Send|,|SDLNet_UDP_SendV|,
|SDLNet_UDP_Recv|,|UDPpacket|,|UDPsocket|
===============================================================================
                                                              *SDLNet_UDP_Recv*

int SDLNet_UDP_Recv(UDPsocket sock,UDPpacket *packet);

SOCK: A valid UDPsocket.
PACKET: The packet to receive into.
Receive a packet on the specified sock socket.
The packet you pass in must have enough of a data size allocated for the
incoming packet data to fit into. This means you should have knowledge of your
size needs before trying to receive UDP packets. The packet will have it's
address set to the remote sender's address. The socket's channels are checked
in highest to lowest order, so if an address is bound to multiple channels,
the highest channel with the source address bound will be retreived before the
lower bound channels. So, the packets channel will also be set to the highest
numbered channel that has the remote address and port assigned to it.
Otherwise the channel will -1, which you can filter out easily if you want
to ignore unbound source address. Note that the local and remote channel
numbers do not have to, and probably won't, match, as they are only local
settings, they are not sent in the packet. This is a non-blocking call,
meaning if there's no data ready to be received the function will return.

Returns 1 is returned when a packet is received. 0 is returned when no
packets are received. -1 is returned on errors.

Example >
	/* try to receive a waiting udp packet */
	UDPsocket udpsock;
	UDPpacket packet;
	int numrecv;

	numrecv=SDLNet_UDP_Recv(udpsock, &packet);
	if(numrecv) {
			// do something with packet
	}
<
See Also
|SDLNet_UDP_Bind|,|SDLNet_UDP_Send|,|SDLNet_UDP_SendV|,|SDLNet_UDP_RecvV|,|UDPpacket|,|UDPsocket|
===============================================================================
                                                             *SDLNet_UDP_Close*

void SDLNet_UDP_Close(UDPsocket sock);

SOCK: A valid UDPsocket. This can be a server or client type socket.

This shutsdown, disconnects, and closes the UDPsocket sock. After this, you can be assured that this socket is not in use anymore. You can reuse the sock variable after this to open a new connection with SDLNet_UDP_Open. Do not try to use any other functions on a closed socket, as it is now invalid.

Returns: nothing, this always succeeds.

Example >

	/* unbind all addresses on the UDPsocket channel 0 */
	UDPsocket udpsock;
	SDLNet_UDP_Close(udpsock);
	udpsock=NULL; //this helps us know that this UDPsocket is not valid anymore
<
See Also
|SDLNet_UDP_Open|,|UDPsocket|
===============================================================================
                                                        *SDLNet_AllocSocketSet*

SDLNet_SocketSet SDLNet_AllocSocketSet(int maxsockets);

MAXSOCKETS: The maximum number of sockets you will want to watch.

SDLNet_AllocSocketSet creates a socket set that will be able to watch up to
maxsockets number of sockets. The same socket set can be used for both 
UDP and TCP sockets.

Returns a new, empty, SDLNet_SocketSet. NULL is returned on errors, such as out-of-memory.

Example >

	// Create a socket set to handle up to 16 sockets
	SDLNet_SocketSet set;

	set = SDLNet_AllocSocketSet(16);
	if (!set) {
			printf("SDLNet_AllocSocketSet: %s\n", SDLNet_GetError());
			exit(1); //most of the time this is a major error, but do what you want.
	}
<
See Also
|SDLNet_FreeSocketSet|,|SDLNet_AddSocket|,
|SDLNet_SocketSet|,|UDPsocket|,|TCPsocket|
===============================================================================
                                                             *SDLNet_AddSocket*

int SDLNet_AddSocket(SDLNet_SocketSet set,SDLNet_GenericSocket sock);


int SDLNet_AddSocket(SDLNet_SocketSet set, SDLNet_GenericSocket sock);
int SDLNet_TCP_AddSocket(SDLNet_SocketSet set, TCPsocket sock);
int SDLNet_UDP_AddSocket(SDLNet_SocketSet set, UDPsocket sock);
SET: The socket set to add this socket to.
SOCK: The socket to add to the socket set.

Returns the number of sockets used in the set on success. -1 is returned on errors.

Example >

	// add two sockets to a socket set
	SDLNet_SocketSet set;
	UDPsocket udpsock;
	TCPsocket tcpsock;
	int numused;

	numused = SDLNet_UDP_AddSocket(set, udpsock);
	if (numused == -1) {
			printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
			// perhaps you need to restart the set and make it bigger...
	}

	numused = SDLNet_TCP_AddSocket(set, tcpsock);
	if (numused == -1) {
			printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
			// perhaps you need to restart the set and make it bigger...
	}
See Also
|SDLNet_AllocSocketSet|,|SDLNet_DelSocket|,
|SDLNet_CheckSockets|,|SDLNet_SocketSet|,|UDPsocket|,|TCPsocket|
===============================================================================
                                                             *SDLNet_DelSocket*

int SDLNet_DelSocket(SDLNet_SocketSet set,SDLNet_GenericSocket sock);

int SDLNet_DelSocket(SDLNet_SocketSet set, SDLNet_GenericSocket sock);
int SDLNet_TCP_DelSocket(SDLNet_SocketSet set, TCPsocket sock);
int SDLNet_UDP_DelSocket(SDLNet_SocketSet set, UDPsocket sock);
set is the socket set to remove this socket from.

SOCK: The socket to remove from the socket set.
SDLNet_DelSocket removes a socket from a socket set. Use this before closing
a socket that you are watching with a socket set. This doesn't close the socket.

Returns the number of sockets used in the set on success. -1 is returned on errors.

Example >

	// remove two sockets from a socket set
	SDLNet_SocketSet set;
	UDPsocket udpsock;
	TCPsocket tcpsock;
	int numused;

	numused = SDLNet_UDP_DelSocket(set, udpsock);
	if (numused == -1) {
			printf("SDLNet_DelSocket: %s\n", SDLNet_GetError());
			// perhaps the socket is not in the set
	}
	numused = SDLNet_TCP_DelSocket(set,tcpsock);
	if (numused == -1) {
			printf("SDLNet_DelSocket: %s\n", SDLNet_GetError());
			// perhaps the socket is not in the set
	}
See Also
|SDLNet_AddSocket|,|SDLNet_FreeSocketSet|,|SDLNet_SocketSet|,|UDPsocket, TCPsocket|
===============================================================================
                                                          *SDLNet_CheckSockets*

int SDLNet_CheckSockets(SDLNet_SocketSet set,Uint32 timeout);

SET: The socket set to check.

TIMEOUT: The maximum amount of time to wait (in milliseconds). 0 means no waiting. 
-1 means to wait over 49 days! (think about it)

SDLNet_CheckSockets check all sockets in the socket set for activity. If a 
non-zero timeout is given then this function will wait for activity,
or else it will wait for timeout milliseconds.

NOTE: "activity" also includes disconnections and other errors,
which would be determined by a failed read/write attempt.

Returns the number of sockets with activity. -1 is returned on errors, 
and you may not get a meaningful error message. -1 is also returned for an 
empty set (nothing to check).

Example >
	/* Wait for up to 1 second for network activity */
	SDLNet_SocketSet set;
	int numready;

	numready = SDLNet_CheckSockets(set, 1000);
	if (numready == -1) {
			printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
			//most of the time this is a system error, where perror might help you.
			perror("SDLNet_CheckSockets");
	}
	else if (numready) {
			printf("There are %d sockets with activity!\n", numready);
			// check all sockets with SDLNet_SocketReady and handle the active ones.
	}
<
See Also
|SDLNet_SocketReady|,|SDLNet_AddSocket|,|SDLNet_DelSocket|,
|SDLNet_AllocSocketSet|,|SDLNet_SocketSet|,|UDPsocket|,|TCPsocket|
===============================================================================
                                                          *SDLNet_SocketReady*

int SDLNet_SocketReady(sock);
SOCK: The socket to check for activity. Both UDPsocket and TCPsockets
can be used with this function.

SDLNet_SocketReady check whether a socket has been marked as active.
This function should only be used on a socket in a socket set,
and that set has to have had SDLNet_CheckSockets called upon it.

Return Value
Returns non-zero for activity. zero is returned for no activity.

Example >
	Example using TCP and a 1000ms timeout waiting for activity:

	/* Wait forever for a connection attempt */
	SDLNet_SocketSet set;
	TCPsocket serversock, client;
	int numready;

	numready = SDLNet_CheckSockets(set, 1000);
	if (numready == -1) {
			printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
			// most of the time this is a system error, where perror might help you.
			perror("SDLNet_CheckSockets");
	}
	else if (numready) {
			printf("There are %d sockets with activity!\n", numready);
			// check all sockets with SDLNet_SocketReady and handle the active ones.
			if (SDLNet_SocketReady(serversock)) {
					client = SDLNet_TCP_Accept(serversock);
					if (client) {
							// play with the client.
					}
			}
	}
	Example using UDP with no waiting:

	/* Check for, and handle UDP data */
	SDLNet_SocketSet set;
	UDPsocket udpsock;
	UDPpacket *packet;
	int numready, numpkts;

	numready = SDLNet_CheckSockets(set, 0);
	if (numready == -1) {
			printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
			// most of the time this is a system error, where perror might help you.
			perror("SDLNet_CheckSockets");
	}
	else if (numready) {
			printf("There are %d sockets with activity!\n", numready);
			// check all sockets with SDLNet_SocketReady and handle the active ones.
			if (SDLNet_SocketReady(udpsock)) {
					numpkts = SDLNet_UDP_Recv(udpsock, &packet);
					if (numpkts) {
							// process the packet.
					}
			}
	}
<
See Also
|SDLNet_CheckSockets|,|SDLNet_AddSocket|,|SDLNet_DelSocket|,
|SDLNet_AllocSocketSet|,|SDLNet_SocketSet|,|UDPsocket|,|TCPsocket|
===============================================================================
                                                         *SDLNet_FreeSocketSet*

void SDLNet_FreeSocketSet(SDLNet_SocketSet set);

SDLNet_FreeSocketSet frees the given socket set from memory.
Do not reference the set after this call, except to allocate a new one.

Returns nothing, this call always succeeds.

Example >
	/* free a socket set */
	SDLNet_SocketSet set;
	SDLNet_FreeSocketSet(set);
	set = NULL; // this helps us remember that this set is not allocated
<
See Also
|SDLNet_AllocSocketSet|,|SDLNet_AddSocket|,
|SDLNet_SocketSet|,|UDPsocket|,|TCPsocket|
===============================================================================
                                                              *SDLNet_SetError*
void SDLNet_SetError(const char *fmt,...);
===============================================================================
                                                              *SDLNet_GetError*

const char * SDLNet_GetError(void);

SDLNet_GetError is the same as |SDL_GetError|, which returns the last error
set as a string which you may use to tell the user what happened when an 
error status has been returned from an SDLNet_function.

Returns a char pointer (string) containint a human readable version of the
reason for the last error that occured.

Example >
	printf("Oh my goodness, an error : %s has occured\n",SDLNet_GetError());
===============================================================================
                                                               *SDLNet_Read16*

Uint16 SLDNet_Read16(void *area);

Get a 16 bit value from the data buffer area which is in network byte order.
This helps avoid byte order differences between two systems that are talking
over the network. The returned value can be a signed number, the unsigned
parameter type doesn't affect the data. The area pointer need not be at the
beginning of a buffer,but must have at least 2 bytes of space left,including the
byte currently pointed at.

Example >
	/* get a number from a data buffer to use on this host */
	char *ptr;
	Sint16 number;
	number = (Sint16)SDLNet_Read16(ptr)
	
See Also
|SDLNet_Read32|,|SDLNet_Write16|,|SDLNet_Write32|

===============================================================================
                                                               *SDLNet_Write16*

SDLNet_Write16(Uint16 value,void *area);

Put the 16 bit value into the data buffer area in network byte order.
This helps avoid byte order differences between two system that are talking
over the network. The value can be a signed number, the unsigned parameter
type doesnt' affect the data. The area pointer need not be at the beginning
of a buffer,but must have at least 2 bytes of space left,including the
byte currently pointed at.

Example >
	/* Put a number into a data buffer to prepare for sending to a remote host */ 
	char data[1024];
	Sint16 number=12345;
	SDLNet_Write16((Uint16)number,data);
<	

See Also
|SDLNet_Read16|,|SDLNet_Read32|,SDLNet_Write32|
===============================================================================
                                                                *SDLNet_Read32*

Uint32 SDLNet_Read32(void *area);

Get a 32 bit value from the data buffer area which is in network byte order.
This helps avoid byte order differences between two systems that are talking
over the network. The returned value can be a signed number, the unsigned
parameter type doesn't affect the data. The area pointer need not be at the
beginning of a buffer,but must have at least 4 bytes of space left,including the
byte currently pointed at.

Example >
	/* get a number from a data buffer to use on this host */
	char *ptr;
	Uint32 number;
	number = SDLNet_Read32(ptr)
	/* number is now in your hosts byte order, ready to use.
	
See Also
|SDLNet_Read16|,|SDLNet_Write16|,|SDLNet_Write32|

===============================================================================
                                                                    *IPaddress*
>
	typedef struct 
	{
			Uint32 host;            /* 32-bit IPv4 host address */
			Uint16 port;            /* 16-bit protocol port */
	}IPaddress;
<
HOST: The IPv4 address of a host, encoded in Network Byte Order.
PORT: The IPv4 port number of a socket, encoded in Network Byte Order.

This type contains the information used to form network connections and sockets.

See Also
|NameResolution|,|SDLNet_TCP_Open|,|UDPpacket|
===============================================================================
                                                                    *UDPpacket*

>
	typedef struct {
			int channel;          /* The src/dst channel of the packet */
			Uint8 *data;          /* The packet data */
			int len;              /* The length of the packet data */
			int maxlen;           /* The size of the data buffer */
			int status;           /* packet status after sending */
			IPaddress address;    /* The source/dest address of an incoming/outgoing packet */
	} UDPpacket;
<
Structure Data
CHANNEL: The (software) channel number for this packet. This can also be used
as a priority value for the packet. If no channel is assigned, the value is -1.
DATA: The data contained in this packet, this is the meat.
LEN: This is the meaningful length of the data in bytes.
MAXLEN: This is size of the data buffer, which may be larger than the 
meaningful length. This is only used for packet creation on the senders side.
STATUS: This contains the number of bytes sent, or a -1 on errors, after sending.
This is useless for a received packet.
ADDRESS: This is the resolved IPaddress to be used when sending, or it is 
the remote source of a received packet.

This struct is used with UDPsockets to send and receive data. It also helps
keep track of a packet's sending/receiving settings and status. The channels 
concept helps prioritize, or segregate differing types of data packets.

See Also
|UDP Packets|,|UDPsocket|,|IPaddress|
===============================================================================
                                                      *SDLNet_GetGenericSocket*
>
	typedef struct {
			int ready;
	} *SDLNet_GenericSocket;
<
READY: Non-zero when data is ready to be read, or a server socket has a 
connection attempt ready to be accepted.

This data type is able to be used for both UDPsocket and TCPsocket types.

After calling SDLNet_CheckSockets, if this socket is in SDLNet_SocketSet used,
the ready will be set according to activity on the socket. This is the only
real use for this type, as it doesn't help you know what type of socket it is.

See Also
|TCPsocket|,|UDPsocket|

===============================================================================
                                                             *SDLNet_SocketSet*

>
	typedef struct _SDLNet_SocketSet *SDLNet_SocketSet;
<

This is an opaque data type used for socket sets. This is a pointer so it
could be NULL at times. NULL would indicate no socket was created.

See Also
|TCPsocket|,|UDPsocket|
===============================================================================
                                                                    *UDPsocket*
>
	typedef struct _UDPsocket *UDPsocket
<
This is an opaque data type used for UDP sockets. This is a pointer, and so 
it could be NULL at times. NULL would indicate no socket has been established.

See Also
|UDPpacket|,|TCPsocket|,|SDLNet_GenericSocket|
===============================================================================
                                                                    *TCPsocket*
>
  typedef struct _TCPsocket *TCPsocket;
<

This is an opaque data type used for TCP connections. This is a pointer, and so 
it could be NULL at times. NULL would indicate no socket has been established.

See Also
|UDPsocket|,|SDLNet_GenericSocket|
===============================================================================
                                                               *SDLNet_Write32*

SDLNet_Write32(Uint16 value,void *area);

Put the 32 bit value into the data buffer area in network byte order.
This helps avoid byte order differences between two system that are talking
over the network. The value can be a signed number, the unsigned parameter
type doesnt' affect the data. The area pointer need not be at the beginning
of a buffer,but must have at least 2 bytes of space left,including the
byte currently pointed at.

Example >
	/* Put a number into a data buffer to prepare for sending to a remote host */ 
	char data[1024];
	Sint16 number=12345;
	SDLNet_Write32(number,data);
<	

See Also
|SDLNet_Read16|,|SDLNet_Read32|,SDLNet_Write16|


===============================================================================
                                                           *TTF_Linked_Version*

const SDL_version *TTF_Linked_Version()

void TTF_VERSION(SDL_version *compile_version)
This works similar to SDL_Linked_Version and SDL_VERSION. Using these you can
compare the runtime version to the version that you compiled with.
>
	SDL_version compile_version, *link_version;
	TTF_VERSION(&compile_version);
	printf("compiled with SDL_ttf version: %d.%d.%d\n", 
					compile_version.major,
					compile_version.minor,
					compile_version.patch);
	link_version=TTF_Linked_Version();
	printf("running with SDL_ttf version: %d.%d.%d\n", 
					link_version->major,
					link_version->minor,
					link_version->patch);
<
See Also
|TTF_Init|
===============================================================================
                                                                     *TTF_Init*

int TTF_Init()
Initialize the truetype font API. This must be called before using other
functions in this library, excepting TTF_WasInit. SDL does not have to be
initialized before this call.

Returns: 0 on success, -1 on errors

>
	if(TTF_Init()==-1) {
			printf("TTF_Init: %s\n", TTF_GetError());
			exit(2);
	}
<
See Also
|TTF_Quit|,|TTF_WasInit|
===============================================================================
                                                                  *TTF_WasInit*

int TTF_WasInit()
Query the initialization status of the truetype font API. You may, of course,
use this before TTF_Init to avoid initializing twice in a row. Or use this to
determine if you need to call TTF_Quit.
>
	if(!TTF_WasInit() && TTF_Init()==-1) {
			printf("TTF_Init: %s\n", TTF_GetError());
			exit(1);
	}
<
See Also
|TTF_Init|,|TTF_Quit|
===============================================================================
                                                                     *TTF_Quit*

void TTF_Quit()
Shutdown and cleanup the truetype font API. After calling this the SDL_ttf
functions should not be used, excepting TTF_WasInit and TTF_Init. You may, of
course, use TTF_Init to use the functionality again.

>
	TTF_Quit();
	/* you could SDL_Quit(); here...or not. */
<
See Also
|TTF_Init|,|TTF_WasInit|
===============================================================================
                                                                 *TTF_SetError*

void TTF_SetError(const char *fmt, ...)
This is the same as SDL_SetError, which sets the error string which may be
fetched with TTF_GetError (or SDL_GetError). This functions acts like printf,
except that it is limited to SDL_ERRBUFIZE(1024) chars in length.
It only accepts the following format types: %s, %d, %f, %p. No variations are
supported, like %.2f would not work. For any more specifics read the SDL docs.
>
	int myfunc(int i) {
			TTF_SetError("myfunc is not implemented! %d was passed in.",i);
			return(-1);
	}
<
See Also
|TTF_GetError|
===============================================================================
                                                                 *TTF_GetError*

char *TTF_GetError()
This is the same as SDL_GetError, which returns the last error set as a string
which you may use to tell the user what happened when an error status has been
returned from an SDL_ttf function call.

Returns: a char pointer (string) containing a human readable version or
the reason for the last error that occured.
>
	printf("Oh My Goodness, an error : %s", TTF_GetError());
<
See Also
|TTF_SetError|
===============================================================================
                                                                 *TTF_OpenFont*

TTF_Font *TTF_OpenFont(const char *file, int ptsize)
FILE: File name to load font from.
PTSIZE: Point size (based on 72DPI) to load font as. This basically translates
to pixel height. Load file for use as a font, at ptsize size. This is actually
TTF_OpenFontIndex(file, ptsize, 0). This can load TTF and FON files.

Returns: a pointer to the font as a TTF_Font. NULL is returned on errors.
>
	/* load font.ttf at size 16 into font */
	TTF_Font *font;
	font=TTF_OpenFont("font.ttf", 16);
	if(!font) {
			printf("TTF_OpenFont: %s\n", TTF_GetError());
			/* handle error */
	}
<
See Also
|TTF_OpenFontIndex,|TTF_OpenFontRW|,|TTF_CloseFont|
===============================================================================
                                                               *TTF_OpenFontRW*

TTF_Font *TTF_OpenFontRW(SDL_RWops *src, int freesrc, int ptsize)

SRC: The source SDL_RWops as a pointer. The font is loaded from this.
FREESRC: A non-zero value mean is will automatically close/free the src for you.
PTSIZE: Point size (based on 72DPI) to load font as. This basically translates to pixel height.
Load src for use as a font, at ptsize size. This is actually
TTF_OpenFontIndexRW(src, freesrc, ptsize, 0). This can load TTF and FON formats.
Using SDL_RWops is not covered here, but they enable you to load from almost any source.

NOTE: src is not checked for NULL, so be careful.

Returns: a pointer to the font as a TTF_Font. NULL is returned on errors.
>
	/* load font.ttf at size 16 into font */
	TTF_Font *font;
	font=TTF_OpenFontRW(SDL_RWFromFile("font.ttf"), 1, 16);
	if(!font) {
			printf("TTF_OpenFontRW: %s\n", TTF_GetError());
			/* handle error */
	}
<
Note that this is unsafe because we don't check the validity of the SDL_RWFromFile's returned pointer.

See Also
|TTF_OpenFontIndexRW|,|TTF_OpenFont|,|TTF_CloseFont|
===============================================================================
                                                            *TTF_OpenFontIndex*

TTF_Font *TTF_OpenFontIndex(const char *file, int ptsize, long index)
FILE: File name to load font from.
PTSIZE: Point size (based on 72DPI) to load font as. This basically translates to pixel height.
INDEX: choose a font face from a multiple font face containing file.
The first face is always index 0. Load file, face index, for use as a font,
at ptsize size. This is actually TTF_OpenFontIndexRW(SDL_RWFromFile(file),
ptsize, index), but checks that the RWops it creates is not NULL.
This can load TTF and FON files.

Returns: a pointer to the font as a TTF_Font. NULL is returned on errors.
>
	/* load font.ttf, face 0, at size 16 into font */
	TTF_Font *font;
	font=TTF_OpenFontIndex("font.ttf", 16, 0);
	if(!font) {
			printf("TTF_OpenFontIndex: %s\n", TTF_GetError());
			/* handle error */
	}
<
See Also
|TTF_OpenFontIndexRW|,|TTF_OpenFont|,|TTF_CloseFont|
===============================================================================
                                                          *TTF_OpenFontIndexRW*

TTF_Font *TTF_OpenFontIndexRW(SDL_RWops *src, int freesrc, int ptsize, long index)
SRC: The source SDL_RWops as a pointer. The font is loaded from this.
FREESRC: A non-zero value mean is will automatically close/free the src for you.
PTSIZE: Point size (based on 72DPI) to load font as. This basically translates to pixel height.
INDEX: Choose a font face from a multiple font face containing file.
The first face is always index 0. Load src, face index, for use as a font,
at ptsize size. This can load TTF and FON formats. Using SDL_RWops is not
covered here, but they enable you to load from almost any source.

NOTE: src is not checked for NULL, so be careful.

Returns: a pointer to the font as a TTF_Font. NULL is returned on errors.
>
	/* load font.ttf, face 0, at size 16 into font */
	TTF_Font *font;
	font=TTF_OpenFontRW(SDL_RWFromFile("font.ttf"), 1, 16, 0);
	if(!font) {
			printf("TTF_OpenFontIndexRW: %s\n", TTF_GetError());
			/* handle error */
	}
<
Note that this is unsafe because we don't check the validity of the SDL_RWFromFile's returned pointer.

See Also
|TTF_OpenFontIndex|,|TTF_OpenFontRW|,|TTF_CloseFont|
===============================================================================
                                                                *TTF_CloseFont*

void TTF_CloseFont(TTF_Font *font)
FONT: Pointer to the TTF_Font to free.
Free the memory used by font, and free font itself as well.
Do not use font after this without loading a new font to it.
>
	/* free the font */
	/* TTF_Font *font; */
	TTF_CloseFont(font);
	font=NULL; // to be safe...
<
See Also
|TTF_OpenFont|,|TTF_OpenFontRW|,|TTF_OpenFontIndex|,|TTF_OpenFontIndexRW|
===============================================================================
                                                       *TTF_ByteSwapperUNICODE*

void TTF_ByteSwappedUNICODE(int swapped)
SWAPPED: if non-zero then UNICODE data is byte swapped relative to the CPU's
native endianess. if zero, then do not swap UNICODE data, use the CPU's native endianess.
This function tells SDL_ttf whether UNICODE (Uint16 per character) text is
generally byteswapped. A UNICODE_BOM_NATIVE or UNICODE_BOM_SWAPPED character
in a string will temporarily override this setting for the remainder
of that string; however, this setting will be restored for the next one.
The default mode is non-swapped (using the native endianness of the CPU).
>
	/* Turn on byte swapping for UNICODE text */
	TTF_ByteSwappedUNICODE(1);
<
See Also
|SDL_TTF_Defines|
===============================================================================
                                                             *TTF_GetFontStyle*

int TTF_GetFontStyle(TTF_Font *font)
FONT: The loaded font to get the style of. Get the rendering style of the loaded font.

NOTE: Passing a NULL font into this function will cause a segfault.

Returns: The style as a bitmask composed of the following masks:
TTF_STYLE_BOLD
TTF_STYLE_ITALIC
TTF_STYLE_UNDERLINE
If no style is set then TTF_STYLE_NORMAL is returned.
>
	/* get the loaded font's style */
	TTF_Font *font;
	int style;
	style=TTF_GetFontStyle(font);
	printf("The font style is:");
	if(style==TTF_STYLE_NORMAL)
			printf(" normal");
	else {
			if(style&TTF_STYLE_BOLD)
					printf(" bold");
			if(style&TTF_STYLE_ITALIC)
					printf(" italic");
			if(style&TTF_STYLE_UNDERLINE)
					printf(" underline");
	}
	printf("\n");
<
See Also
|TTF_SetFontStyle|,|SDL_TTF_Defines|
===============================================================================
                                                             *TTF_SetFontStyle*

void TTF_SetFontStyle(TTF_Font *font, int style)
FONT: The loaded font to set the style of.
STYLE: A bitmask of the desired style composed from the TTF_STYLE_* defined values.

Set the rendering style of the loaded font.

NOTE: SDL_ttf's "styles" are fake styles generated by artificially skewing or
emboldening the regular font. They will not make use of real italic and bold styles,
which are considered different fonts - for best results,
switch to a real italic or bold font rather than using this functionality.

NOTE: Passing a NULL font into this function will cause a segfault.

NOTE: This will flush the internal cache of previously rendered glyphs,
even if there is no change in style, so it may be best to check the current
style using TTF_GetFontStyle first.

NOTE: I've seen that combining TTF_STYLE_UNDERLINE with anything can cause a segfault,
other combinations may also do this. Some brave soul may find the cause of this and fix it...

NOTE: Rendered text formatted with TTF_STYLE_BOLD is hollow on the inside (wireframe like)
for some reason when you use TTF_RenderSolid. It displayed ok if you use TTF_RenderBlended.

>
	/* set the loaded font's style to fake bold italics */
	TTF_Font *font;
	TTF_SetFontStyle(font, TTF_STYLE_BOLD|TTF_STYLE_ITALIC);

	/* render some text in fake bold italics... */

	/* set the loaded font's style back to normal */
	TTF_SetFontStyle(font, TTF_STYLE_NORMAL);
<
See Also
|TTF_GetFontStyle|,|SDL_TTF_Defines|
===============================================================================
                                                               *TTF_FontHeight*

int TTF_FontHeight(TTF_Font *font)
FONT: The loaded font to get the max height of.
Get the maximum pixel height of all glyphs of the loaded font.
You may use this height for rendering text as close together vertically as possible,
though adding at least one pixel height to it will space it so they can't touch.
Remember that SDL_ttf doesn't handle multiline printing,
so you are responsible for line spacing, see the TTF_FontLineSkip as well.

NOTE: Passing a NULL font into this function will cause a segfault.

Returns: The maximum pixel height of all glyphs in the font.
>
	/* get the loaded font's max height */
	TTF_Font *font;
	printf("The font max height is: %d\n", TTF_FontHeight(font));
<
See Also
|TTF_FontAscent|,|TTF_FontDescent|,|TTF_FontLineSkip|
===============================================================================
                                                               *TTF_FontAscent*

int TTF_FontAscent(TTF_Font *font)
FONT: The loaded font to get the ascent (height above baseline) of.
Get the maximum pixel ascent of all glyphs of the loaded font.
This can also be interpreted as the distance from the top of the font to the baseline.
It could be used when drawing an individual glyph relative to a top point,
by combining it with the glyph's maxy metric to resolve the top of the
rectangle used when blitting the glyph on the screen.
>
	rect.y = top + TTF_FontAscent(font) - glyph_metric.maxy;
<
NOTE: Passing a NULL font into this function will cause a segfault.

Returns: The maximum pixel ascent of all glyphs in the font.
>
	/* get the loaded font's max ascent */
	TTF_Font *font;

	printf("The font ascent is: %d\n", TTF_FontAscent(font));
<
See Also
|TTF_FontHeight|,|TTF_FontDescent|,|TTF_FontLineSkip|
===============================================================================
                                                              *TTF_FontDescent*

int TTF_FontDescent(TTF_Font *font)
FONT: The loaded font to get the descent (height below baseline) of.
Get the maximum pixel descent of all glyphs of the loaded font. This can also
be interpreted as the distance from the baseline to the bottom of the font.
It could be used when drawing an individual glyph relative to a bottom point,
by combining it with the glyph's maxy metric to resolve the top of the
rectangle used when blitting the glyph on the screen.
>
	rect.y = bottom - TTF_FontDescent(font) - glyph_metric.maxy;
<
NOTE: Passing a NULL font into this function will cause a segfault.

Returns: The maximum pixel descent of all glyphs in the font.
>
	/* get the loaded font's max descent */
	TTF_Font *font;

	printf("The font descent is: %d\n", TTF_FontDescent(font));
<
See Also
|TTF_FontHeight|,|TTF_FontAscent|,|TTF_FontLineSkip|
===============================================================================
                                                             *TTF_FontLineSkip*

int TTF_FontLineSkip(TTF_Font *font)
FONT: The loaded font to get the line skip height of.
Get the reccomended pixel height of a rendered line of text of the loaded font.
This is usually larger than the TTF_FontHeight of the font.

NOTE: Passing a NULL font into this function will cause a segfault.

Returns: The maximum pixel height of all glyphs in the font.
>
	// get the loaded font's max descent
	TTF_Font *font;
	printf("The font descent is: %d\n", TTF_FontDescent(font));
<
See Also
|TTF_FontHeight|,|TTF_FontAscent|,|TTF_FontDescent|
===============================================================================
                                                             *TTF_GlyphMetrics*

int TTF_GlyphMetrics(TTF_Font *font, Uint16 ch, int *minx, int *maxx, int *miny, int *maxy, int *advance)
FONT: The loaded font to get the glyph metric from.
CH: The character to get the metrics from.
MINX: The left side of the glyph.
MAXX: The right side of the glyph.
MINY: The bottom of the glyph.
MAXY: The top of the glyph.
ADVANCE: The amount to advance the pen forward after drawing
(ie the width of the glyph with spacing on both sides).
Gets the glyph metrics from the font file.

NOTE: Passing a NULL font into this function will cause a segfault.
>
	/* get the character's metrics from the loaded font */
	TTF_Font *font;
	int error;
	int minx, maxx, miny, maxy, advance;
	char c = 'x';
	error=TTF_GlyphMetrics(font, c, &minx, &maxx, &miny, &maxy, &advance);
	if(error)
		printf("Error, could not find character %c.", c);
	else
  printf("x = %i to %i, y = %i to %i, advance = %i.", minx, maxx, miny, maxy, advance);
<
===============================================================================
                                                                 *TTF_SizeText*

int TTF_SizeText(TTF_Font *font, const char *text, int *w, int *h)
FONT: The loaded font to use to calculate the size of the string with.
TEXT: The LATIN1 null terminated string to size up.
W: Pointer to int in which to fill the text width, or NULL for no desired return value.
H: Pointer to int in which to fill the text height, or NULL for no desired return value.
Calculate the resulting surface size of the LATIN1 encoded text rendered using font.
No actual rendering is done, however correct kerning is done to get the actual width.
The height returned in h is the same as you can get using TTF_FontHeight.

Returns 0 on success with the ints pointed to by w and h set as appropriate,
if they are not NULL. -1 is returned on errors, such as a glyph in the string not being found.

Note: Passing a NULL font into this function will cause a segfault.
Passing a NULL text into this function will result in undefined behavior.
>
	/* get the width and height of a string as it would be rendered in a loaded font */
	TTF_Font *font;
	int w,h;
	if(TTF_SizeText(font,"Hello World!",&w,&h)) {
			/* perhaps print the current TTF_GetError(), the string can't be rendered... */
	} else {
			printf("width=%d height=%d\n",w,h);
	}
<
See Also
|TTF_SizeUTF8|,|TTF_SizeUNICODE|,|TTF_RenderText_Solid|,|TTF_RenderText_Shaded|,|TTF_RenderText_Blended|
===============================================================================
                                                                 *TTF_SizeUTF8*
int TTF_SizeUTF8(TTF_Font *font, const char *text, int *w, int *h)
FONT: The loaded font to use to calculate the size of the string with.
TEXT: The UTF8 null terminated string to size up.
W: Pointer to int in which to fill the text width, or NULL for no desired return value.
H: Pointer to int in which to fill the text height, or NULL for no desired return value.
Calculate the resulting surface size of the UTF8 encoded text rendered using font.
No actual rendering is done, however correct kerning is done to get the actual width.
The height returned in h is the same as you can get using TTF_FontHeight.

Returns 0 on success with the ints pointed to by w and h set as appropriate,
if they are not NULL. -1 is returned on errors, such as a glyph in the string not being found.

NOTE: Passing a NULL font into this function will cause a segfault.
Passing a NULL text into this function will result in undefined behavior.

Note that this example uses the same text as in the LATIN1 example,
that is because plain ASCII is UTF8 compatible.
>
	/* get the width and height of a string as it would be rendered in a loaded font */
	TTF_Font *font;
	int w,h;
	if(TTF_SizeUTF8(font,"Hello World!",&w,&h)) {
			/* perhaps print the current TTF_GetError(), the string can't be rendered... */
	} else {
    printf("width=%d height=%d\n",w,h);
	}
See Also
|TTF_SizeText|,|TTF_SizeUNICODE|,|TTF_RenderUTF8_Solid|,
|TTF_RenderUTF8_Shaded|,|TTF_RenderUTF8_Blended|,|TTF_RenderText_Solid|
===============================================================================
        *TTF_RenderText_Solid* *TTF_RenderUTF8_Solid* *TTF_RenderUNICODE_Solid*

SDL_Surface *TTF_RenderText_Solid(TTF_Font *font, const char *text, SDL_Color fg)
SDL_Surface *TTF_RenderUTF8_Solid(TTF_Font *font, const char *text, SDL_Color fg)
SDL_Surface *TTF_RenderUNICODE_Solid(TTF_Font *font, const Uint16 *text, SDL_Color fg);

FONT: Font to render the text with. Must be non-NULL.
TEXT: A NULL-terminated string in corresponding encoding.
FG: The color to render the text in. This becomes colormap index 1.
This family of functions will render the given text with the given font with fg
color onto a new surface. The Solid mode is used and this is the fastest.

Returns a pointer to a new SDL_Surface. NULL is returned on errors.
>
	/* This example draws the text in the upper left corner of the given surface. */
	int DrawText(SDL_Surface* screen, TTF_Font* font, const char* text)
	{
			SDL_Color color = {0,0,0};
			SDL_Surface *text_surface;

			text_surface = TTF_RenderText_Solid(font, text, color);
			if (text_surface != NULL)
			{
					SDL_BlitSurface(text_surface, NULL, screen, NULL);
					SDL_FreeSurface(text_surface);
					return 1;
			}
			else
			{
					// report error
					return 0;
			}
	}
<
See Also
|TTF_SizeText|,|TTF_RenderText_Shaded|,|TTF_RenderText_Blended|
===============================================================================
     *TTF_RenderText_Shaded* *TTF_RenderUTF8_Shaded* *TTF_RenderUNICODE_Shaded*

SDL_Surface *TTF_RenderText_Shaded(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg)
SDL_Surface *TTF_RenderUTF8_Shaded(TTF_Font *font, const char *text, SDL_Color fg, SDL_Color bg)
SDL_Surface *TTF_RenderUNICODE_Shaded(TTF_Font *font, const Uint16 *text, SDL_Color fg, SDL_Color bg);

FONT: Font to render the text with. Must be non-NULL.
TEXT: A NULL-terminated string in corresponding encoding.
FG: The color to render the text in. This becomes colormap index 1.
BG: The background color. This becomes colormap index 0.

This family of functions will render the given text with the given font with
fg color onto a new surface with background color bg. The Shaded mode is
used and this is the fastest.

Returns a pointer to a new SDL_Surface. NULL is returned on errors.
>
	/* This example draws the text in the upper let corner of the given surface. */
	int DrawText(SDL_Surface* screen, TTF_Font* font, const char* text)
	{
			SDL_Color black = {0,0,0};
			SDL_Color white = {1,1,1};
			SDL_Surface *text_surface;
			
			text_surface = TTF_RenderText_Shaded(font, text, black, white); 
			if (text_surface != NULL)
			{
					SDL_BlitSurface(text_surface, NULL, screen, NULL);
					SDL_FreeSurface(text_surface);
					return 1;
			}
			else
			{
					// report error
					return 0;
			}
	}
<

See Also
|TTF_SizeText|,|TTF_RenderText_Solid|,|TTF_RenderGlyph_Blended|
===============================================================================
  *TTF_RenderText_Blended* *TTF_RenderUTF8_Blended* *TTF_RenderUNICODE_Blended*

SDL_Surface *TTF_RenderText_Blended(TTF_Font *font, const char *text, SDL_Color fg)
SDL_Surface *TTF_RenderUTF8_Blended(TTF_Font *font, const char *text, SDL_Color fg)
SDL_Surface *TTF_RenderUNICODE_Blended(TTF_Font *font, const Uint16 *text, SDL_Color fg);

FONT: Font to render the text with. Must be non-NULL.
TEXT: A NULL-terminated string in corresponding encoding.
FG: The color to render the text in. This becomes colormap index 1.

This family of functions will render the given text with the given font with fg
color onto a new surface with transparent background. The Blended mode.
This is the slowest but most beautiful.

Returns a pointer to a new SDL_Surface. NULL is returned on errors.
>
	/* This example draws the text in the upper left corner of the given surface. */
	int DrawText(SDL_Surface* screen, TTF_Font* font, const char* text)
	{
			SDL_Color black = {0,0,0};
			SDL_Surface *text_surface;
			
			text_surface = TTF_RenderText_Blended(font, text, black); 
			if (text_surface != NULL)
			{
					SDL_BlitSurface(text_surface, NULL, screen, NULL);
					SDL_FreeSurface(text_surface);
					return 1;
			}
			else
			{
					// report error
					return 0;
			}
	}
<

See Also
|TTF_SizeText|,|TTF_RenderText_Solid|,|TTF_RenderText_Shaded|
===============================================================================
                                                              *SDL_TTF_Defines*
                                                            *TTF_MAJOR_VERSION*
TTF_MAJOR_VERSION
SDL_ttf library major number at compilation time
                                                            *TTF_MINOR_VERSION*
TTF_MINOR_VERSION
SDL_ttf library minor number at compilation time
                                                               *TTF_PATCHLEVEL*
TTF_PATCHLEVEL
SDL_ttf library patch level at compilation time
                                                           *UNICODE_BOM_NATIVE*
UNICODE_BOM_NATIVE 0xFEFF
This allows you to switch byte-order of UNICODE text data to native order,
meaning the mode of your CPU. This is meant to be used in a UNICODE string
that you are using with the SDL_ttf API.
                                                          *UNICODE_BOM_SWAPPED*
UNICODE_BOM_SWAPPED 0xFFFE
This allows you to switch byte-order of UNICODE text data to swapped order,
meaning the reversed mode of your CPU. So if your CPU is LSB, then the data
will be interpretted as MSB. This is meant to be used in a UNICODE string
that you are using with the SDL_ttf API.
                                                             *TTF_STYLE_NORMAL*
TTF_STYLE_NORMAL 0x00
Used to indicate regular, normal, plain rendering style.
                                                               *TTF_STYLE_BOLD*
TTF_STYLE_BOLD 0x01
Used to indicate bold rendering style. This is used a bitmask along with other styles.
                                                             *TTF_STYLE_ITALIC*
TTF_STYLE_ITALIC 0x02
Used to indicate italicized rendering style. This is used a bitmask along with other styles.
                                                          *TTF_STYLE_UNDERLINE*
TTF_STYLE_UNDERLINE 0x04
Used to indicate underlined rendering style. This is used a bitmask along with other styles.

vim:tw=78:ts=8:ft=help:norl:
