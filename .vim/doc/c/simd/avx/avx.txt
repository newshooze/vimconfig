*avx.txt*                

INTEL AVX REFERENCE


===============================================================================
                        *_mm256_abs_epi16* *vpabsw*
Synopsis
__m256i _mm256_abs_epi16 (__m256i a)
#include <immintrin.h>
Instruction: vpabsw ymm, ymm
CPUID Flags: AVX2
Description
Compute the absolute value of packed signed 16-bit integers in a,
and store the unsigned results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_abs_epi32* *vpabsd*
Synopsis
__m256i _mm256_abs_epi32 (__m256i a)
#include <immintrin.h>
Instruction: vpabsd ymm, ymm
CPUID Flags: AVX2
Description
Compute the absolute value of packed signed 32-bit integers in a,
and store the unsigned results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_abs_epi8* *vpabsb*
Synopsis
__m256i _mm256_abs_epi8 (__m256i a)
#include <immintrin.h>
Instruction: vpabsb ymm, ymm
CPUID Flags: AVX2
Description
Compute the absolute value of packed signed 8-bit integers in a,
and store the unsigned results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_epi16* *vpaddw*
Synopsis
__m256i _mm256_add_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 16-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_epi32* *vpaddd*
Synopsis
__m256i _mm256_add_epi32 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddd ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 32-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_epi64* *vpaddq*
 (__m256i a, __m256i b)
Synopsis
__m256i _mm256_add_epi64 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddq ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 64-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_epi8* *vpaddb*
Synopsis
__m256i _mm256_add_epi8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 8-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
dst[MAX:256] := 0



===============================================================================
                        *_mm256_add_pd* *vaddpd*
Synopsis
__m256d _mm256_add_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vaddpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Add packed double-precision (64-bit) floating-point elements in a and b,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_ps* *vaddps*
Synopsis
__m256 _mm256_add_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vaddps ymm, ymm, ymm
CPUID Flags: AVX
Description
Add packed single-precision (32-bit) floating-point elements in a and b,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_adds_epi16* *vpaddsw*
Synopsis
__m256i _mm256_adds_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddsw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 16-bit integers in a and b using saturation,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_adds_epi8* *vpaddsb*
Synopsis
__m256i _mm256_adds_epi8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddsb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 8-bit integers in a and b using saturation,
and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_adds_epu16* *vpaddusw*
Synopsis
__m256i _mm256_adds_epu16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddusw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed unsigned 16-bit integers in a and b using saturation,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_adds_epu8* *vpaddusb*
Synopsis
__m256i _mm256_adds_epu8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddusb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed unsigned 8-bit integers in a and b using saturation,
and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_addsub_pd* *vaddsubpd*
Synopsis
__m256d _mm256_addsub_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vaddsubpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Alternatively add and subtract packed double-precision (64-bit) floating-point
elements in a to/from packed elements in b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	IF ((j & 1) == 0)
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_addsub_ps* *vaddsubps*
Synopsis
__m256 _mm256_addsub_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vaddsubps ymm, ymm, ymm
CPUID Flags: AVX
Description
Alternatively add and subtract packed single-precision (32-bit) floating-point
elements in a to/from packed elements in b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF ((j & 1) == 0)
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_alignr_epi8* *vpalignr*
Synopsis
__m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int imm8)
#include <immintrin.h>
Instruction: vpalignr ymm, ymm, ymm, imm8
CPUID Flags: AVX2
Description
Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary
result, shift the result right by imm8 bytes, and store the low 16 bytes in dst.
Operation
FOR j := 0 to 1
	i := j*128
	tmp[255:0] := ((a[i+127:i] << 128)[255:0] OR b[i+127:i]) >> (imm8*8)
	dst[i+127:i] := tmp[127:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_and_pd* *vandpd*
Synopsis
#include <immintrin.h>
Instruction: vandpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Compute the bitwise AND of packed double-precision (64-bit)
floating-point elements in a and b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := (a[i+63:i] AND b[i+63:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_and_ps* *vandps*
Synopsis
#include <immintrin.h>
Instruction: vandps ymm, ymm, ymm
CPUID Flags: AVX
Description
Compute the bitwise AND of packed single-precision (32-bit)
floating-point elements in a and b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := (a[i+31:i] AND b[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_and_si256* *vpand*
Synopsis
__m256i _mm256_and_si256 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpand ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compute the bitwise AND of 256 bits (representing integer data) in a and b,
and store the result in dst.
Operation
dst[255:0] := (a[255:0] AND b[255:0])
dst[MAX:256] := 0

===============================================================================
                        *_mm256_andnot_pd* *vandnpd*
Synopsis
__m256d _mm256_andnot_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vandnpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Compute the bitwise NOT of packed double-precision (64-bit)
floating-point elements in a and then AND with b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_andnot_ps* *vandnps*
Synopsis
__m256 _mm256_andnot_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vandnps ymm, ymm, ymm
CPUID Flags: AVX
Description
Compute the bitwise NOT of packed single-precision (32-bit)
floating-point elements in a and then AND with b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_andnot_si256* *vpandn*
Synopsis
__m256i _mm256_andnot_si256 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpandn ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compute the bitwise NOT of 256 bits (representing integer data) in a and
then AND with b, and store the result in dst.
Operation
dst[255:0] := ((NOT a[255:0]) AND b[255:0])
dst[MAX:256] := 0

===============================================================================
                        *_mm256_avg_epu16* *vpavgw*
Synopsis
__m256i _mm256_avg_epu16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpavgw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Average packed unsigned 16-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) >> 1
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_avg_epu8* *vpavgb*
Synopsis
__m256i _mm256_avg_epu8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpavgb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Average packed unsigned 8-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) >> 1
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_bcstnebf16_ps*
Synopsis
__m128 _mm_bcstnebf16_ps (const __bf16* __A)
#include <immintrin.h>
Instruction: vbcstnebf162ps xmm, m16
CPUID Flags: AVX_NE_CONVERT
Description
Convert scalar BF16 (16-bit) floating-point element stored at memory
locations starting at location __A to a single-precision (32-bit)
floating-point, broadcast it to packed single-precision (32-bit)
floating-point elements, and store the results in dst.
Operation
b := Convert_BF16_To_FP32(MEM[__A+15:__A])
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := b
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_bcstnebf16_ps*
Synopsis
__m256 _mm256_bcstnebf16_ps (const __bf16* __A)
#include <immintrin.h>
Instruction: vbcstnebf162ps ymm, m16
CPUID Flags: AVX_NE_CONVERT
Description
Convert scalar BF16 (16-bit) floating-point element stored at memory
locations starting at location __A to a single-precision (32-bit)
floating-point, broadcast it to packed single-precision (32-bit)
 floating-point elements, and store the results in dst.
Operation
b := Convert_BF16_To_FP32(MEM[__A+15:__A])
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := b
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_bcstnesh_ps*
Synopsis
__m128 _mm_bcstnesh_ps (const _Float16* __A)
#include <immintrin.h>
Instruction: vbcstnesh2ps xmm, m16
CPUID Flags: AVX_NE_CONVERT
Description
Convert scalar half-precision (16-bit) floating-point element stored
at memory locations starting at location __A to a single-precision (32-bit)
floating-point, broadcast it to packed single-precision (32-bit)
floating-point elements, and store the results in dst.
Operation
b := Convert_FP16_To_FP32(MEM[__A+15:__A])
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := b
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_bcstnesh_ps*
Synopsis
__m256 _mm256_bcstnesh_ps (const _Float16* __A)
#include <immintrin.h>
Instruction: vbcstnesh2ps ymm, m16
CPUID Flags: AVX_NE_CONVERT
Description
Convert scalar half-precision (16-bit) floating-point
element stored at memory locations starting at
location __A to a single-precision (32-bit)
floating-point, broadcast it to packed
single-precision (32-bit) floating-point elements,
and store the results in dst.
Operation
b := Convert_FP16_To_FP32(MEM[__A+15:__A])
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := b
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blend_epi16* *vpblendw*
Synopsis
__m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8)
#include <immintrin.h>
Instruction: vpblendw ymm, ymm, ymm, imm8
CPUID Flags: AVX2
Description
Blend packed 16-bit integers from a and b
within 128-bit lanes using control mask imm8,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	IF imm8[j%8]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_blend_epi32*
Synopsis
__m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8)
#include <immintrin.h>
Instruction: vpblendd xmm, xmm, xmm, imm8
CPUID Flags: AVX2
Description
Blend packed 32-bit integers from a and b using control mask imm8,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_blend_epi32*
Synopsis
__m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8)
#include <immintrin.h>
Instruction: vpblendd ymm, ymm, ymm, imm8
CPUID Flags: AVX2
Description
Blend packed 32-bit integers from a and b using control mask imm8,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blend_pd* *vblendpd*
(__m256d a, __m256d b, const int imm8)
Synopsis
__m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8)
#include <immintrin.h>
Instruction: vblendpd ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Blend packed double-precision (64-bit) floating-point elements
from a and b using control mask imm8, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	IF imm8[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blend_ps* *vblendps*
Synopsis
__m256 _mm256_blend_ps (__m256 a, __m256 b, const int imm8)
#include <immintrin.h>
Instruction: vblendps ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Blend packed single-precision (32-bit) floating-point elements from a and b using control mask imm8, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blendv_epi8* *vpblendvb*
Synopsis
__m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
#include <immintrin.h>
Instruction: vpblendvb ymm, ymm, ymm, ymm
CPUID Flags: AVX2
Description
Blend packed 8-bit integers from a and b using mask, and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blendv_pd* *vblendvpd*
Synopsis
__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)
#include <immintrin.h>
Instruction: vblendvpd ymm, ymm, ymm, ymm
CPUID Flags: AVX
Description
Blend packed double-precision (64-bit) floating-point elements from a and b using mask, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blendv_ps* *vblendvps*
Synopsis
__m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask)
#include <immintrin.h>
Instruction: vblendvps ymm, ymm, ymm, ymm
CPUID Flags: AVX
Description
Blend packed single-precision (32-bit) floating-point elements
from a and b using mask, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_broadcast_pd*
Synopsis
__m256d _mm256_broadcast_pd (__m128d const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastf128 ymm, m128
CPUID Flags: AVX
Description
Broadcast 128 bits from memory (composed of 2 packed double-precision (64-bit)
floating-point elements) to all elements of dst.
Operation
tmp[127:0] := MEM[mem_addr+127:mem_addr]
dst[127:0] := tmp[127:0]
dst[255:128] := tmp[127:0]
dst[MAX:256] := 0


===============================================================================
                        *_mm256_broadcast_ps*
Synopsis
__m256 _mm256_broadcast_ps (__m128 const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastf128 ymm, m128
CPUID Flags: AVX
Description
Broadcast 128 bits from memory (composed of 4 packed single-precision (32-bit)
floating-point elements) to all elements of dst.
Operation
tmp[127:0] := MEM[mem_addr+127:mem_addr]
dst[127:0] := tmp[127:0]
dst[255:128] := tmp[127:0]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_broadcast_sd*
Synopsis
__m256d _mm256_broadcast_sd (double const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastsd ymm, m64
CPUID Flags: AVX
Description
Broadcast a double-precision (64-bit) floating-point
element from memory to all elements of dst.
Operation
tmp[63:0] := MEM[mem_addr+63:mem_addr]
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := tmp[63:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcast_ss*
Synopsis
__m128 _mm_broadcast_ss (float const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastss xmm, m32
CPUID Flags: AVX
Description
Broadcast a single-precision (32-bit) floating-point element
from memory to all elements of dst.
Operation
tmp[31:0] := MEM[mem_addr+31:mem_addr]
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcast_ss*
Synopsis
__m256 _mm256_broadcast_ss (float const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastss ymm, m32
CPUID Flags: AVX
Description
Broadcast a single-precision (32-bit) floating-point element
from memory to all elements of dst.
Operation
tmp[31:0] := MEM[mem_addr+31:mem_addr]
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastb_epi8*
Synopsis
__m128i _mm_broadcastb_epi8 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastb xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 8-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastb_epi8*
Synopsis
__m256i _mm256_broadcastb_epi8 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastb ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 8-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR

dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastd_epi32*
Synopsis
__m128i _mm_broadcastd_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastd xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 32-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastd_epi32*
(__m128i a)
Synopsis
__m256i _mm256_broadcastd_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastd ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 32-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastq_epi64*
Synopsis
__m128i _mm_broadcastq_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastq xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 64-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastq_epi64*
Synopsis
__m256i _mm256_broadcastq_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastq ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 64-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastsd_pd* *movddup*
Synopsis
__m128d _mm_broadcastsd_pd (__m128d a)
#include <immintrin.h>
Instruction: movddup xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low double-precision (64-bit) floating-point
element from a to all elements of dst.
Operation
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastsd_pd* *vbroadcastsd*
Synopsis
__m256d _mm256_broadcastsd_pd (__m128d a)
#include <immintrin.h>
Instruction: vbroadcastsd ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low double-precision (64-bit) floating-point
element from a to all elements of dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastsi128_si256*
Synopsis
__m256i _mm_broadcastsi128_si256 (__m128i a)
#include <immintrin.h>
Instruction: vbroadcasti128 ymm, m128
CPUID Flags: AVX2
Description
Broadcast 128 bits of integer data from a to all 128-bit lanes in dst.
Operation
dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_broadcastsi128_si256*
Synopsis
__m256i _mm256_broadcastsi128_si256 (__m128i a)
#include <immintrin.h>
Instruction: vbroadcasti128 ymm, m128
CPUID Flags: AVX2
Description
Broadcast 128 bits of integer data from a to all 128-bit lanes in dst.
Operation
dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastss_ps*
Synopsis
__m128 _mm_broadcastss_ps (__m128 a)
#include <immintrin.h>
Instruction: vbroadcastss xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low single-precision (32-bit) floating-point
element from a to all elements of dst.
Operation
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastss_ps*
Synopsis
__m256 _mm256_broadcastss_ps (__m128 a)
#include <immintrin.h>
Instruction: vbroadcastss ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low single-precision (32-bit) floating-point
element from a to all elements of dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastw_epi16*
Synopsis
__m128i _mm_broadcastw_epi16 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastw xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 16-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastw_epi16*
Synopsis
__m256i _mm256_broadcastw_epi16 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastw ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 16-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_bslli_epi128*
Synopsis
__m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
#include <immintrin.h>
Instruction: vpslldq ymm, ymm, imm8
CPUID Flags: AVX2
Description
Shift 128-bit lanes in a left by imm8 bytes while shifting in zeros,
and store the results in dst.
Operation
tmp := imm8[7:0]
IF tmp > 15
	tmp := 16
FI
dst[127:0] := a[127:0] << (tmp*8)
dst[255:128] := a[255:128] << (tmp*8)
dst[MAX:256] := 0

===============================================================================
                        *_mm256_bsrli_epi128*
Synopsis
__m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
#include <immintrin.h>
Instruction: vpsrldq ymm, ymm, imm8
CPUID Flags: AVX2
Description
Shift 128-bit lanes in a right by imm8 bytes while shifting in zeros,
and store the results in dst.
Operation
tmp := imm8[7:0]
IF tmp > 15
	tmp := 16
FI
dst[127:0] := a[127:0] >> (tmp*8)
dst[255:128] := a[255:128] >> (tmp*8)
dst[MAX:256] := 0

===============================================================================
                        *_mm256_castpd_ps*
Synopsis
__m256 _mm256_castpd_ps (__m256d a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256d to type __m256. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castpd_si256*
Synopsis
__m256i _mm256_castpd_si256 (__m256d a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256d to type __m256i. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castpd128_pd256*
Synopsis
__m256d _mm256_castpd128_pd256 (__m128d a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m128d to type __m256d; the upper 128 bits of the result
are undefined. This intrinsic is only used for compilation and does not
generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castpd256_pd128*
Synopsis
__m128d _mm256_castpd256_pd128 (__m256d a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256d to type __m128d. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castps_pd*
Synopsis
__m256d _mm256_castps_pd (__m256 a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256 to type __m256d. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castps_si256*
Synopsis
__m256i _mm256_castps_si256 (__m256 a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256 to type __m256i. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castps128_ps256*
Synopsis
__m256 _mm256_castps128_ps256 (__m128 a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m128 to type __m256; the upper 128 bits of the result
are undefined. This intrinsic is only used for compilation and does not
generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castps256_ps128*
Synopsis
__m128 _mm256_castps256_ps128 (__m256 a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256 to type __m128. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castsi128_si256*
Synopsis
__m256i _mm256_castsi128_si256 (__m128i a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m128i to type __m256i; the upper 128 bits of the
result are undefined. This intrinsic is only used for compilation and
does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castsi256_pd*
Synopsis
__m256d _mm256_castsi256_pd (__m256i a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256i to type __m256d. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castsi256_ps*
Synopsis
__m256 _mm256_castsi256_ps (__m256i a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256i to type __m256. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castsi256_si128*
Synopsis
__m128i _mm256_castsi256_si128 (__m256i a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256i to type __m128i. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_ceil_pd* *vroundpd*
Synopsis
__m256d _mm256_ceil_pd (__m256d a)
#include <immintrin.h>
Instruction: vroundpd ymm, ymm, imm8
CPUID Flags: AVX
Description
Round the packed double-precision (64-bit) floating-point elements in a
up to an integer value, and store the results as packed double-precision
floating-point elements in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := CEIL(a[i+63:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_ceil_ps* *vroundps*
Synopsis
__m256 _mm256_ceil_ps (__m256 a)
#include <immintrin.h>
Instruction: vroundps ymm, ymm, imm8
CPUID Flags: AVX
Description
Round the packed single-precision (32-bit) floating-point elements in a up to an integer value, and store the results as packed single-precision floating-point elements in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := CEIL(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cmp_pd*
Synopsis
__m128d _mm_cmp_pd (__m128d a, __m128d b, const int imm8)
#include <immintrin.h>
Instruction: vcmppd xmm, xmm, xmm, imm8
CPUID Flags: AVX
Description
Compare packed double-precision (64-bit) floating-point elements
in a and b based on the comparison operand specified by imm8,
and store the results in dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cmp_pd*
Synopsis
__m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)
#include <immintrin.h>
Instruction: vcmppd ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Compare packed double-precision (64-bit) floating-point elements
in a and b based on the comparison operand specified by imm8,
and store the results in dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cmp_ps*
Synopsis
__m128 _mm_cmp_ps (__m128 a, __m128 b, const int imm8)
#include <immintrin.h>
Instruction: vcmpps xmm, xmm, xmm, imm8
CPUID Flags: AVX
Description
Compare packed single-precision (32-bit) floating-point elements
in a and b based on the comparison operand specified by imm8,
and store the results in dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] OP b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cmp_ps*
Synopsis
__m256 _mm256_cmp_ps (__m256 a, __m256 b, const int imm8)
#include <immintrin.h>
Instruction: vcmpps ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Compare packed single-precision (32-bit) floating-point elements
in a and b based on the comparison operand specified by imm8,
and store the results in dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] OP b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cmp_sd* *vcmpsd*
Synopsis
__m128d _mm_cmp_sd (__m128d a, __m128d b, const int imm8)
#include <immintrin.h>
Instruction: vcmpsd xmm, xmm, xmm, imm8
CPUID Flags: AVX
Description
Compare the lower double-precision (64-bit) floating-point element
in a and b based on the comparison operand specified by imm8,
store the result in the lower element of dst, and copy the upper
element from a to the upper element of dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
dst[63:0] := ( a[63:0] OP b[63:0] ) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]
dst[MAX:128] := 0

===============================================================================
                        *_mm_cmp_ss* *vcmpss*
Synopsis
__m128 _mm_cmp_ss (__m128 a, __m128 b, const int imm8)
#include <immintrin.h>
Instruction: vcmpss xmm, xmm, xmm, imm8
CPUID Flags: AVX
Description
Compare the lower single-precision (32-bit) floating-point element
in a and b based on the comparison operand specified by imm8,
store the result in the lower element of dst, and copy the upper
3 packed elements from a to the upper elements of dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
dst[31:0] := ( a[31:0] OP b[31:0] ) ? 0xFFFFFFFF : 0
dst[127:32] := a[127:32]
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cmpeq_epi16* *vpcmpeqw*
Synopsis
__m256i _mm256_cmpeq_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpeqw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed 16-bit integers in a and b for equality,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpeq_epi32* *vpcmpeqd*
Synopsis
__m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpeqd ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed 32-bit integers in a and b for equality,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpeq_epi64* *vpcmpeqq*
Synopsis
__m256i _mm256_cmpeq_epi64 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpeqq ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed 64-bit integers in a and b for equality,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] == b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpeq_epi8* *vpcmpeqb*
Synopsis
__m256i _mm256_cmpeq_epi8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpeqb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed 8-bit integers in a and b for equality,
and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpgt_epi16* *vpcmpgtw*
Synopsis
__m256i _mm256_cmpgt_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpgtw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed signed 16-bit integers in a and b for greater-than,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ( a[i+15:i] > b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpgt_epi32* *vpcmpgtd*
Synopsis
__m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpgtd ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed signed 32-bit integers in a and b for greater-than,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] > b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpgt_epi64* *vpcmpgtq*
Synopsis
__m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpgtq ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed signed 64-bit integers in a and b for greater-than,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] > b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpgt_epi8* *vpcmpgtb*
Synopsis
__m256i _mm256_cmpgt_epi8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpgtb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed signed 8-bit integers in a and b for greater-than,
and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ( a[i+7:i] > b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi16_epi32* *vpmovsxwd*
Synopsis
__m256i _mm256_cvtepi16_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxwd ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 16-bit integers in a to packed 32-bit integers,
and store the results in dst.
Operation
FOR j:= 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend32(a[k+15:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi16_epi64* *vpmovsxwq*
Synopsis
__m256i _mm256_cvtepi16_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxwq ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 16-bit integers in a to packed 64-bit integers,
and store the results in dst.
Operation
FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend64(a[k+15:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi32_epi64* *vpmovsxdq*
Synopsis
__m256i _mm256_cvtepi32_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxdq ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 32-bit integers in a to packed 64-bit integers,
and store the results in dst.
Operation
FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi32_pd* *vcvtdq2pd*
Synopsis
__m256d _mm256_cvtepi32_pd (__m128i a)
#include <immintrin.h>
Instruction: vcvtdq2pd ymm, xmm
CPUID Flags: AVX
Description
Convert packed signed 32-bit integers in a to packed double-precision (64-bit)
floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	m := j*64
	dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi32_ps* *vcvtdq2ps*
Synopsis
__m256 _mm256_cvtepi32_ps (__m256i a)
#include <immintrin.h>
Instruction: vcvtdq2ps ymm, ymm
CPUID Flags: AVX
Description
Convert packed signed 32-bit integers in a to packed single-precision (32-bit)
floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi8_epi16* *vpmovsxbw*
Synopsis
__m256i _mm256_cvtepi8_epi16 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxbw ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := SignExtend16(a[i+7:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi8_epi32* *vpmovsxbd*
Synopsis
__m256i _mm256_cvtepi8_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxbd ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 8-bit integers in a to packed 32-bit integers,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend32(a[k+7:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi8_epi64* *vpmovsxbq*
Synopsis
__m256i _mm256_cvtepi8_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxbq ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 8-bit integers in the low 8 bytes of a to packed
64-bit integers, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend64(a[k+7:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu16_epi32* *vpmovzxwd*
Synopsis
__m256i _mm256_cvtepu16_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxwd ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend32(a[k+15:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu16_epi64* *vpmovzxwq*
Synopsis
__m256i _mm256_cvtepu16_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxwq ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers,
and store the results in dst.
Operation
FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend64(a[k+15:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu32_epi64* *vpmovzxdq*
Synopsis
__m256i _mm256_cvtepu32_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxdq ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst.
Operation
FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu8_epi16* *vpmovzxbw*
Synopsis
__m256i _mm256_cvtepu8_epi16 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxbw ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := ZeroExtend16(a[i+7:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu8_epi32* *vpmovzxbd*
Synopsis
__m256i _mm256_cvtepu8_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxbd ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend32(a[k+7:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu8_epi64* *vpmovzxbq*
Synopsis
__m256i _mm256_cvtepu8_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxbq ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 8-bit integers in the low 8 byte sof a to
packed 64-bit integers, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend64(a[k+7:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cvtneebf16_ps* *vcvtneebf162ps*
Synopsis
__m128 _mm_cvtneebf16_ps (const __m128bh* __A)
#include <immintrin.h>
Instruction: vcvtneebf162ps xmm, m128
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed BF16 (16-bit) floating-point even-indexed elements stored
at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := Convert_BF16_To_FP32(MEM[__A+m+15:__A+m])
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cvtneebf16_ps* *vcvtneebf162ps*
Synopsis
__m256 _mm256_cvtneebf16_ps (const __m256bh* __A)
#include <immintrin.h>
Instruction: vcvtneebf162ps ymm, m256
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed BF16 (16-bit) floating-point even-indexed elements stored
at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := Convert_BF16_To_FP32(MEM[__A+m+15:__A+m])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cvtneeph_ps* *vcvtneeph2ps*
Synopsis
__m128 _mm_cvtneeph_ps (const __m128h* __A)
#include <immintrin.h>
Instruction: vcvtneeph2ps xmm, m128
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed half-precision (16-bit) floating-point even-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := Convert_FP16_To_FP32(MEM[__A+m+15:__A+m])
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cvtneeph_ps* *vcvtneeph2ps*
Synopsis
__m256 _mm256_cvtneeph_ps (const __m256h* __A)
#include <immintrin.h>
Instruction: vcvtneeph2ps ymm, m256
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed half-precision (16-bit) floating-point even-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := Convert_FP16_To_FP32(MEM[__A+m+15:__A+m])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cvtneobf16_ps* *vcvtneobf162ps*
Synopsis
__m128 _mm_cvtneobf16_ps (const __m128bh* __A)
#include <immintrin.h>
Instruction: vcvtneobf162ps xmm, m128
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed BF16 (16-bit) floating-point odd-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := Convert_BF16_To_FP32(MEM[__A+m+31:__A+m+16])
ENDFOR
dst[MAX:128] := 0
=============================================================================== 
                        *_mm256_cvtneobf16_ps* *vcvtneobf162ps*
Synopsis
__m256 _mm256_cvtneobf16_ps (const __m256bh* __A)
#include <immintrin.h>
Instruction: vcvtneobf162ps ymm, m256
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed BF16 (16-bit) floating-point odd-indexed elements stored at memory locations starting at location __A to packed single-precision (32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := Convert_BF16_To_FP32(MEM[__A+m+31:__A+m+16])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_cvtneoph_ps* *vcvtneoph2ps*
Synopsis
__m128 _mm_cvtneoph_ps (const __m128h* __A)
#include <immintrin.h>
Instruction: vcvtneoph2ps xmm, m128
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed half-precision (16-bit) floating-point odd-indexed elements stored at memory locations starting at location __A to packed single-precision (32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := Convert_FP16_To_FP32(MEM[__A+m+31:__A+m+16])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtneoph_ps* *vcvtneoph2ps*
Synopsis
__m256 _mm256_cvtneoph_ps (const __m256h* __A)
#include <immintrin.h>
Instruction: vcvtneoph2ps ymm, m256
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed half-precision (16-bit) floating-point odd-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := Convert_FP16_To_FP32(MEM[__A+m+31:__A+m+16])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_cvtneps_avx_pbh* *vcvtneps2bf16*
Synopsis
__m128bh _mm_cvtneps_avx_pbh (__m128 __A)
#include <immintrin.h>
Instruction: vcvtneps2bf16 xmm, xmm
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed single-precision (32-bit) floating-point elements in __A
to packed BF16 (16-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	dst.word[j] := Convert_FP32_To_BF16(__A.fp32[j])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtneps_avx_pbh* *vcvtneps2bf16*
Synopsis
__m128bh _mm256_cvtneps_avx_pbh (__m256 __A)
#include <immintrin.h>
Instruction: vcvtneps2bf16 xmm, ymm
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed single-precision (32-bit) floating-point elements in __A
to packed BF16 (16-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	dst.word[j] := Convert_FP32_To_BF16(__A.fp32[j])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm_cvtneps_pbh* *vcvtneps2bf16*
Synopsis
__m128bh _mm_cvtneps_pbh (__m128 __A)
#include <immintrin.h>
Instruction: vcvtneps2bf16 xmm, xmm
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed single-precision (32-bit) floating-point elements in __A
to packed BF16 (16-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	dst.word[j] := Convert_FP32_To_BF16(__A.fp32[j])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtneps_pbh* *vcvtneps2bf16*
Synopsis
__m128bh _mm256_cvtneps_pbh (__m256 __A)
#include <immintrin.h>
Instruction: vcvtneps2bf16 xmm, ymm
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed single-precision (32-bit) floating-point elements in __A
to packed BF16 (16-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	dst.word[j] := Convert_FP32_To_BF16(__A.fp32[j])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtpd_epi32* *vcvtpd2dq*
Synopsis
__m128i _mm256_cvtpd_epi32 (__m256d a)
#include <immintrin.h>
Instruction: vcvtpd2dq xmm, ymm
CPUID Flags: AVX
Description
Convert packed double-precision (64-bit) floating-point elements in a
to packed 32-bit integers, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtpd_ps* *vcvtpd2ps*
Synopsis
__m128 _mm256_cvtpd_ps (__m256d a)
#include <immintrin.h>
Instruction: vcvtpd2ps xmm, ymm
CPUID Flags: AVX
Description
Convert packed double-precision (64-bit) floating-point elements in a to packed
single-precision (32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_FP32(a[k+63:k])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtps_epi32* *vcvtps2dq*
Synopsis
__m256i _mm256_cvtps_epi32 (__m256 a)
#include <immintrin.h>
Instruction: vcvtps2dq ymm, ymm
CPUID Flags: AVX
Description
Convert packed single-precision (32-bit) floating-point elements in a
to packed 32-bit integers, and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_cvtps_pd* *vcvtps2pd*
Synopsis
__m256d _mm256_cvtps_pd (__m128 a)
#include <immintrin.h>
Instruction: vcvtps2pd ymm, xmm
CPUID Flags: AVX
Description
Convert packed single-precision (32-bit) floating-point elements in a to packed
double-precision (64-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := Convert_FP32_To_FP64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_cvtsd_f64* *vmovsd*
Synopsis
double _mm256_cvtsd_f64 (__m256d a)
#include <immintrin.h>
Instruction: vmovsd m64, xmm
CPUID Flags: AVX
Description
Copy the lower double-precision (64-bit) floating-point element of a to dst.
Operation
dst[63:0] := a[63:0]

=============================================================================== 
                        *_mm256_cvtsi256_si32* *vmovd*
Synopsis
int _mm256_cvtsi256_si32 (__m256i a)
#include <immintrin.h>
Instruction: vmovd r32, xmm
CPUID Flags: AVX
Description
Copy the lower 32-bit integer in a to dst.
Operation
dst[31:0] := a[31:0]

=============================================================================== 
                        *_mm256_cvtss_f32* *vmovss*
Synopsis
float _mm256_cvtss_f32 (__m256 a)
#include <immintrin.h>
Instruction: vmovss m32, xmm
CPUID Flags: AVX
Description
Copy the lower single-precision (32-bit) floating-point element of a to dst.
Operation
dst[31:0] := a[31:0]

=============================================================================== 
                        *_mm256_cvttpd_epi32* *vcvttpd2dq*
Synopsis
__m128i _mm256_cvttpd_epi32 (__m256d a)
#include <immintrin.h>
Instruction: vcvttpd2dq xmm, ymm
CPUID Flags: AVX
Description
Convert packed double-precision (64-bit) floating-point elements in a
to packed 32-bit integers with truncation, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[k+63:k])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvttps_epi32* *vcvttps2dq*
Synopsis
__m256i _mm256_cvttps_epi32 (__m256 a)
#include <immintrin.h>
Instruction: vcvttps2dq ymm, ymm
CPUID Flags: AVX
Description
Convert packed single-precision (32-bit) floating-point elements in a
to packed 32-bit integers with truncation, and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_div_pd* *vdivpd* 
Synopsis
__m256d _mm256_div_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vdivpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Divide packed double-precision (64-bit) floating-point elements in a by packed
elements in b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 64*j
	dst[i+63:i] := a[i+63:i] / b[i+63:i]
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_div_ps* *vdivps*
Synopsis
__m256 _mm256_div_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vdivps ymm, ymm, ymm
CPUID Flags: AVX
Description
Divide packed single-precision (32-bit) floating-point elements in a by packed
elements in b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := a[i+31:i] / b[i+31:i]
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_dp_ps* *vdpps*
Synopsis
__m256 _mm256_dp_ps (__m256 a, __m256 b, const int imm8)
#include <immintrin.h>
Instruction: vdpps ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Conditionally multiply the packed single-precision (32-bit) floating-point
elements in a and b using the high 4 bits in imm8, sum the four products,
and conditionally store the sum in dst using the low 4 bits of imm8.
Operation
>
	DEFINE DP(a[127:0], b[127:0], imm8[7:0]) {
		FOR j := 0 to 3
			i := j*32
			IF imm8[(4+j)%8]
				temp[i+31:i] := a[i+31:i] * b[i+31:i]
			ELSE
				temp[i+31:i] := FP32(0.0)
			FI
		ENDFOR
		
		sum[31:0] := (temp[127:96] + temp[95:64]) + (temp[63:32] + temp[31:0])
		
		FOR j := 0 to 3
			i := j*32
			IF imm8[j%8]
				tmpdst[i+31:i] := sum[31:0]
			ELSE
				tmpdst[i+31:i] := FP32(0.0)
			FI
		ENDFOR
		RETURN tmpdst[127:0]
	}
<
dst[127:0] := DP(a[127:0], b[127:0], imm8[7:0])
dst[255:128] := DP(a[255:128], b[255:128], imm8[7:0])
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbssd_epi32* *vpdpbssd*
Synopsis
__m128i _mm_dpbssd_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbssd xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding signed 8-bit integers in __B, producing 4 intermediate
signed 16-bit results. Sum these 4 results with the corresponding
32-bit integer in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := SignExtend16(__A.byte[4*j]) * SignExtend16(__B.byte[4*j])
	tmp2.word := SignExtend16(__A.byte[4*j+1]) * SignExtend16(__B.byte[4*j+1])
	tmp3.word := SignExtend16(__A.byte[4*j+2]) * SignExtend16(__B.byte[4*j+2])
	tmp4.word := SignExtend16(__A.byte[4*j+3]) * SignExtend16(__B.byte[4*j+3])
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbssd_epi32* *vpdpbssd*
Synopsis
__m256i _mm256_dpbssd_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbssd ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding signed 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := SignExtend16(__A.byte[4*j]) * SignExtend16(__B.byte[4*j])
	tmp2.word := SignExtend16(__A.byte[4*j+1]) * SignExtend16(__B.byte[4*j+1])
	tmp3.word := SignExtend16(__A.byte[4*j+2]) * SignExtend16(__B.byte[4*j+2])
	tmp4.word := SignExtend16(__A.byte[4*j+3]) * SignExtend16(__B.byte[4*j+3])
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
vpdpbssds
__m128i _mm_dpbssds_epi32 (__m128i __W, __m128i __A, __m128i __B)
Synopsis
__m128i _mm_dpbssds_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbssds xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with corresponding signed 8-bit integers in __B, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in __W with signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := SignExtend16(__A.byte[4*j]) * SignExtend16(__B.byte[4*j])
	tmp2.word := SignExtend16(__A.byte[4*j+1]) * SignExtend16(__B.byte[4*j+1])
	tmp3.word := SignExtend16(__A.byte[4*j+2]) * SignExtend16(__B.byte[4*j+2])
	tmp4.word := SignExtend16(__A.byte[4*j+3]) * SignExtend16(__B.byte[4*j+3])
	dst.dword[j] := SIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0
vpdpbssds
__m256i _mm256_dpbssds_epi32 (__m256i __W, __m256i __A, __m256i __B)
Synopsis
__m256i _mm256_dpbssds_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbssds ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with corresponding signed 8-bit integers in __B, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in __W with signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := SignExtend16(__A.byte[4*j]) * SignExtend16(__B.byte[4*j])
	tmp2.word := SignExtend16(__A.byte[4*j+1]) * SignExtend16(__B.byte[4*j+1])
	tmp3.word := SignExtend16(__A.byte[4*j+2]) * SignExtend16(__B.byte[4*j+2])
	tmp4.word := SignExtend16(__A.byte[4*j+3]) * SignExtend16(__B.byte[4*j+3])
	dst.dword[j] := SIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0
vpdpbsud
__m128i _mm_dpbsud_epi32 (__m128i __W, __m128i __A, __m128i __B)
Synopsis
__m128i _mm_dpbsud_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbsud xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(SignExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j]))
	tmp2.word := Signed(SignExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1]))
	tmp3.word := Signed(SignExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2]))
	tmp4.word := Signed(SignExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3]))
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0
vpdpbsud
__m256i _mm256_dpbsud_epi32 (__m256i __W, __m256i __A, __m256i __B)
Synopsis
__m256i _mm256_dpbsud_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbsud ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := Signed(SignExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j]))
	tmp2.word := Signed(SignExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1]))
	tmp3.word := Signed(SignExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2]))
	tmp4.word := Signed(SignExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3]))
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0
vpdpbsuds
__m128i _mm_dpbsuds_epi32 (__m128i __W, __m128i __A, __m128i __B)
Synopsis
__m128i _mm_dpbsuds_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbsuds xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in __W with signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(SignExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j]))
	tmp2.word := Signed(SignExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1]))
	tmp3.word := Signed(SignExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2]))
	tmp4.word := Signed(SignExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3]))
	dst.dword[j] := SIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0
vpdpbsuds
__m256i _mm256_dpbsuds_epi32 (__m256i __W, __m256i __A, __m256i __B)
Synopsis
__m256i _mm256_dpbsuds_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbsuds ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in __W with signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := Signed(SignExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j]))
	tmp2.word := Signed(SignExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1]))
	tmp3.word := Signed(SignExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2]))
	tmp4.word := Signed(SignExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3]))
	dst.dword[j] := SIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0
vpdpbusd
__m128i _mm_dpbusd_avx_epi32 (__m128i src, __m128i a, __m128i b)
Synopsis
__m128i _mm_dpbusd_avx_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpbusd xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0
vpdpbusd
__m256i _mm256_dpbusd_avx_epi32 (__m256i src, __m256i a, __m256i b)
Synopsis
__m256i _mm256_dpbusd_avx_epi32 (__m256i src, __m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpdpbusd ymm, ymm, ymm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0
vpdpbusd
__m128i _mm_dpbusd_epi32 (__m128i src, __m128i a, __m128i b)
Synopsis
__m128i _mm_dpbusd_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpbusd xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0
