*avx.txt*                

INTEL AVX REFERENCE


===============================================================================
                        *_mm256_abs_epi16* *vpabsw*
Synopsis
__m256i _mm256_abs_epi16 (__m256i a)
#include <immintrin.h>
Instruction: vpabsw ymm, ymm
CPUID Flags: AVX2
Description
Compute the absolute value of packed signed 16-bit integers in a,
and store the unsigned results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_abs_epi32* *vpabsd*
Synopsis
__m256i _mm256_abs_epi32 (__m256i a)
#include <immintrin.h>
Instruction: vpabsd ymm, ymm
CPUID Flags: AVX2
Description
Compute the absolute value of packed signed 32-bit integers in a,
and store the unsigned results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_abs_epi8* *vpabsb*
Synopsis
__m256i _mm256_abs_epi8 (__m256i a)
#include <immintrin.h>
Instruction: vpabsb ymm, ymm
CPUID Flags: AVX2
Description
Compute the absolute value of packed signed 8-bit integers in a,
and store the unsigned results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_epi16* *vpaddw*
Synopsis
__m256i _mm256_add_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 16-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_epi32* *vpaddd*
Synopsis
__m256i _mm256_add_epi32 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddd ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 32-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_epi64* *vpaddq*
 (__m256i a, __m256i b)
Synopsis
__m256i _mm256_add_epi64 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddq ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 64-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_epi8* *vpaddb*
Synopsis
__m256i _mm256_add_epi8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 8-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
dst[MAX:256] := 0



===============================================================================
                        *_mm256_add_pd* *vaddpd*
Synopsis
__m256d _mm256_add_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vaddpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Add packed double-precision (64-bit) floating-point elements in a and b,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_add_ps* *vaddps*
Synopsis
__m256 _mm256_add_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vaddps ymm, ymm, ymm
CPUID Flags: AVX
Description
Add packed single-precision (32-bit) floating-point elements in a and b,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_adds_epi16* *vpaddsw*
Synopsis
__m256i _mm256_adds_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddsw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 16-bit integers in a and b using saturation,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_adds_epi8* *vpaddsb*
Synopsis
__m256i _mm256_adds_epi8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddsb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed 8-bit integers in a and b using saturation,
and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_adds_epu16* *vpaddusw*
Synopsis
__m256i _mm256_adds_epu16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddusw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed unsigned 16-bit integers in a and b using saturation,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_adds_epu8* *vpaddusb*
Synopsis
__m256i _mm256_adds_epu8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpaddusb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Add packed unsigned 8-bit integers in a and b using saturation,
and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_addsub_pd* *vaddsubpd*
Synopsis
__m256d _mm256_addsub_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vaddsubpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Alternatively add and subtract packed double-precision (64-bit) floating-point
elements in a to/from packed elements in b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	IF ((j & 1) == 0)
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_addsub_ps* *vaddsubps*
Synopsis
__m256 _mm256_addsub_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vaddsubps ymm, ymm, ymm
CPUID Flags: AVX
Description
Alternatively add and subtract packed single-precision (32-bit) floating-point
elements in a to/from packed elements in b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF ((j & 1) == 0)
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0


===============================================================================
                        *_mm256_alignr_epi8* *vpalignr*
Synopsis
__m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int imm8)
#include <immintrin.h>
Instruction: vpalignr ymm, ymm, ymm, imm8
CPUID Flags: AVX2
Description
Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary
result, shift the result right by imm8 bytes, and store the low 16 bytes in dst.
Operation
FOR j := 0 to 1
	i := j*128
	tmp[255:0] := ((a[i+127:i] << 128)[255:0] OR b[i+127:i]) >> (imm8*8)
	dst[i+127:i] := tmp[127:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_and_pd* *vandpd*
Synopsis
#include <immintrin.h>
Instruction: vandpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Compute the bitwise AND of packed double-precision (64-bit)
floating-point elements in a and b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := (a[i+63:i] AND b[i+63:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_and_ps* *vandps*
Synopsis
#include <immintrin.h>
Instruction: vandps ymm, ymm, ymm
CPUID Flags: AVX
Description
Compute the bitwise AND of packed single-precision (32-bit)
floating-point elements in a and b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := (a[i+31:i] AND b[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_and_si256* *vpand*
Synopsis
__m256i _mm256_and_si256 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpand ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compute the bitwise AND of 256 bits (representing integer data) in a and b,
and store the result in dst.
Operation
dst[255:0] := (a[255:0] AND b[255:0])
dst[MAX:256] := 0

===============================================================================
                        *_mm256_andnot_pd* *vandnpd*
Synopsis
__m256d _mm256_andnot_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vandnpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Compute the bitwise NOT of packed double-precision (64-bit)
floating-point elements in a and then AND with b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_andnot_ps* *vandnps*
Synopsis
__m256 _mm256_andnot_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vandnps ymm, ymm, ymm
CPUID Flags: AVX
Description
Compute the bitwise NOT of packed single-precision (32-bit)
floating-point elements in a and then AND with b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_andnot_si256* *vpandn*
Synopsis
__m256i _mm256_andnot_si256 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpandn ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compute the bitwise NOT of 256 bits (representing integer data) in a and
then AND with b, and store the result in dst.
Operation
dst[255:0] := ((NOT a[255:0]) AND b[255:0])
dst[MAX:256] := 0

===============================================================================
                        *_mm256_avg_epu16* *vpavgw*
Synopsis
__m256i _mm256_avg_epu16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpavgw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Average packed unsigned 16-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) >> 1
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_avg_epu8* *vpavgb*
Synopsis
__m256i _mm256_avg_epu8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpavgb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Average packed unsigned 8-bit integers in a and b, and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) >> 1
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_bcstnebf16_ps*
Synopsis
__m128 _mm_bcstnebf16_ps (const __bf16* __A)
#include <immintrin.h>
Instruction: vbcstnebf162ps xmm, m16
CPUID Flags: AVX_NE_CONVERT
Description
Convert scalar BF16 (16-bit) floating-point element stored at memory
locations starting at location __A to a single-precision (32-bit)
floating-point, broadcast it to packed single-precision (32-bit)
floating-point elements, and store the results in dst.
Operation
b := Convert_BF16_To_FP32(MEM[__A+15:__A])
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := b
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_bcstnebf16_ps*
Synopsis
__m256 _mm256_bcstnebf16_ps (const __bf16* __A)
#include <immintrin.h>
Instruction: vbcstnebf162ps ymm, m16
CPUID Flags: AVX_NE_CONVERT
Description
Convert scalar BF16 (16-bit) floating-point element stored at memory
locations starting at location __A to a single-precision (32-bit)
floating-point, broadcast it to packed single-precision (32-bit)
 floating-point elements, and store the results in dst.
Operation
b := Convert_BF16_To_FP32(MEM[__A+15:__A])
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := b
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_bcstnesh_ps*
Synopsis
__m128 _mm_bcstnesh_ps (const _Float16* __A)
#include <immintrin.h>
Instruction: vbcstnesh2ps xmm, m16
CPUID Flags: AVX_NE_CONVERT
Description
Convert scalar half-precision (16-bit) floating-point element stored
at memory locations starting at location __A to a single-precision (32-bit)
floating-point, broadcast it to packed single-precision (32-bit)
floating-point elements, and store the results in dst.
Operation
b := Convert_FP16_To_FP32(MEM[__A+15:__A])
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := b
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_bcstnesh_ps*
Synopsis
__m256 _mm256_bcstnesh_ps (const _Float16* __A)
#include <immintrin.h>
Instruction: vbcstnesh2ps ymm, m16
CPUID Flags: AVX_NE_CONVERT
Description
Convert scalar half-precision (16-bit) floating-point
element stored at memory locations starting at
location __A to a single-precision (32-bit)
floating-point, broadcast it to packed
single-precision (32-bit) floating-point elements,
and store the results in dst.
Operation
b := Convert_FP16_To_FP32(MEM[__A+15:__A])
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := b
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blend_epi16* *vpblendw*
Synopsis
__m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8)
#include <immintrin.h>
Instruction: vpblendw ymm, ymm, ymm, imm8
CPUID Flags: AVX2
Description
Blend packed 16-bit integers from a and b
within 128-bit lanes using control mask imm8,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	IF imm8[j%8]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_blend_epi32*
Synopsis
__m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8)
#include <immintrin.h>
Instruction: vpblendd xmm, xmm, xmm, imm8
CPUID Flags: AVX2
Description
Blend packed 32-bit integers from a and b using control mask imm8,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_blend_epi32*
Synopsis
__m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8)
#include <immintrin.h>
Instruction: vpblendd ymm, ymm, ymm, imm8
CPUID Flags: AVX2
Description
Blend packed 32-bit integers from a and b using control mask imm8,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blend_pd* *vblendpd*
(__m256d a, __m256d b, const int imm8)
Synopsis
__m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8)
#include <immintrin.h>
Instruction: vblendpd ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Blend packed double-precision (64-bit) floating-point elements
from a and b using control mask imm8, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	IF imm8[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blend_ps* *vblendps*
Synopsis
__m256 _mm256_blend_ps (__m256 a, __m256 b, const int imm8)
#include <immintrin.h>
Instruction: vblendps ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Blend packed single-precision (32-bit) floating-point elements from a and b
using control mask imm8, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blendv_epi8* *vpblendvb*
Synopsis
__m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
#include <immintrin.h>
Instruction: vpblendvb ymm, ymm, ymm, ymm
CPUID Flags: AVX2
Description
Blend packed 8-bit integers from a and b using mask, and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blendv_pd* *vblendvpd*
Synopsis
__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)
#include <immintrin.h>
Instruction: vblendvpd ymm, ymm, ymm, ymm
CPUID Flags: AVX
Description
Blend packed double-precision (64-bit) floating-point elements from a and b using mask, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	IF mask[i+63]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_blendv_ps* *vblendvps*
Synopsis
__m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask)
#include <immintrin.h>
Instruction: vblendvps ymm, ymm, ymm, ymm
CPUID Flags: AVX
Description
Blend packed single-precision (32-bit) floating-point elements
from a and b using mask, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF mask[i+31]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_broadcast_pd*
Synopsis
__m256d _mm256_broadcast_pd (__m128d const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastf128 ymm, m128
CPUID Flags: AVX
Description
Broadcast 128 bits from memory (composed of 2 packed double-precision (64-bit)
floating-point elements) to all elements of dst.
Operation
tmp[127:0] := MEM[mem_addr+127:mem_addr]
dst[127:0] := tmp[127:0]
dst[255:128] := tmp[127:0]
dst[MAX:256] := 0


===============================================================================
                        *_mm256_broadcast_ps*
Synopsis
__m256 _mm256_broadcast_ps (__m128 const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastf128 ymm, m128
CPUID Flags: AVX
Description
Broadcast 128 bits from memory (composed of 4 packed single-precision (32-bit)
floating-point elements) to all elements of dst.
Operation
tmp[127:0] := MEM[mem_addr+127:mem_addr]
dst[127:0] := tmp[127:0]
dst[255:128] := tmp[127:0]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_broadcast_sd*
Synopsis
__m256d _mm256_broadcast_sd (double const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastsd ymm, m64
CPUID Flags: AVX
Description
Broadcast a double-precision (64-bit) floating-point
element from memory to all elements of dst.
Operation
tmp[63:0] := MEM[mem_addr+63:mem_addr]
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := tmp[63:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcast_ss*
Synopsis
__m128 _mm_broadcast_ss (float const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastss xmm, m32
CPUID Flags: AVX
Description
Broadcast a single-precision (32-bit) floating-point element
from memory to all elements of dst.
Operation
tmp[31:0] := MEM[mem_addr+31:mem_addr]
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcast_ss*
Synopsis
__m256 _mm256_broadcast_ss (float const * mem_addr)
#include <immintrin.h>
Instruction: vbroadcastss ymm, m32
CPUID Flags: AVX
Description
Broadcast a single-precision (32-bit) floating-point element
from memory to all elements of dst.
Operation
tmp[31:0] := MEM[mem_addr+31:mem_addr]
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastb_epi8*
Synopsis
__m128i _mm_broadcastb_epi8 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastb xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 8-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastb_epi8*
Synopsis
__m256i _mm256_broadcastb_epi8 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastb ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 8-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR

dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastd_epi32*
Synopsis
__m128i _mm_broadcastd_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastd xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 32-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastd_epi32*
(__m128i a)
Synopsis
__m256i _mm256_broadcastd_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastd ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 32-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastq_epi64*
Synopsis
__m128i _mm_broadcastq_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastq xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 64-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastq_epi64*
Synopsis
__m256i _mm256_broadcastq_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastq ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 64-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastsd_pd* *movddup*
Synopsis
__m128d _mm_broadcastsd_pd (__m128d a)
#include <immintrin.h>
Instruction: movddup xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low double-precision (64-bit) floating-point
element from a to all elements of dst.
Operation
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastsd_pd* *vbroadcastsd*
Synopsis
__m256d _mm256_broadcastsd_pd (__m128d a)
#include <immintrin.h>
Instruction: vbroadcastsd ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low double-precision (64-bit) floating-point
element from a to all elements of dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastsi128_si256*
Synopsis
__m256i _mm_broadcastsi128_si256 (__m128i a)
#include <immintrin.h>
Instruction: vbroadcasti128 ymm, m128
CPUID Flags: AVX2
Description
Broadcast 128 bits of integer data from a to all 128-bit lanes in dst.
Operation
dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_broadcastsi128_si256*
Synopsis
__m256i _mm256_broadcastsi128_si256 (__m128i a)
#include <immintrin.h>
Instruction: vbroadcasti128 ymm, m128
CPUID Flags: AVX2
Description
Broadcast 128 bits of integer data from a to all 128-bit lanes in dst.
Operation
dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastss_ps*
Synopsis
__m128 _mm_broadcastss_ps (__m128 a)
#include <immintrin.h>
Instruction: vbroadcastss xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low single-precision (32-bit) floating-point
element from a to all elements of dst.
Operation
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastss_ps*
Synopsis
__m256 _mm256_broadcastss_ps (__m128 a)
#include <immintrin.h>
Instruction: vbroadcastss ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low single-precision (32-bit) floating-point
element from a to all elements of dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_broadcastw_epi16*
Synopsis
__m128i _mm_broadcastw_epi16 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastw xmm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 16-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_broadcastw_epi16*
Synopsis
__m256i _mm256_broadcastw_epi16 (__m128i a)
#include <immintrin.h>
Instruction: vpbroadcastw ymm, xmm
CPUID Flags: AVX2
Description
Broadcast the low packed 16-bit integer from a to all elements of dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_bslli_epi128*
Synopsis
__m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
#include <immintrin.h>
Instruction: vpslldq ymm, ymm, imm8
CPUID Flags: AVX2
Description
Shift 128-bit lanes in a left by imm8 bytes while shifting in zeros,
and store the results in dst.
Operation
tmp := imm8[7:0]
IF tmp > 15
	tmp := 16
FI
dst[127:0] := a[127:0] << (tmp*8)
dst[255:128] := a[255:128] << (tmp*8)
dst[MAX:256] := 0

===============================================================================
                        *_mm256_bsrli_epi128*
Synopsis
__m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
#include <immintrin.h>
Instruction: vpsrldq ymm, ymm, imm8
CPUID Flags: AVX2
Description
Shift 128-bit lanes in a right by imm8 bytes while shifting in zeros,
and store the results in dst.
Operation
tmp := imm8[7:0]
IF tmp > 15
	tmp := 16
FI
dst[127:0] := a[127:0] >> (tmp*8)
dst[255:128] := a[255:128] >> (tmp*8)
dst[MAX:256] := 0

===============================================================================
                        *_mm256_castpd_ps*
Synopsis
__m256 _mm256_castpd_ps (__m256d a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256d to type __m256. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castpd_si256*
Synopsis
__m256i _mm256_castpd_si256 (__m256d a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256d to type __m256i. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castpd128_pd256*
Synopsis
__m256d _mm256_castpd128_pd256 (__m128d a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m128d to type __m256d; the upper 128 bits of the result
are undefined. This intrinsic is only used for compilation and does not
generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castpd256_pd128*
Synopsis
__m128d _mm256_castpd256_pd128 (__m256d a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256d to type __m128d. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castps_pd*
Synopsis
__m256d _mm256_castps_pd (__m256 a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256 to type __m256d. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castps_si256*
Synopsis
__m256i _mm256_castps_si256 (__m256 a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256 to type __m256i. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castps128_ps256*
Synopsis
__m256 _mm256_castps128_ps256 (__m128 a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m128 to type __m256; the upper 128 bits of the result
are undefined. This intrinsic is only used for compilation and does not
generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castps256_ps128*
Synopsis
__m128 _mm256_castps256_ps128 (__m256 a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256 to type __m128. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castsi128_si256*
Synopsis
__m256i _mm256_castsi128_si256 (__m128i a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m128i to type __m256i; the upper 128 bits of the
result are undefined. This intrinsic is only used for compilation and
does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castsi256_pd*
Synopsis
__m256d _mm256_castsi256_pd (__m256i a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256i to type __m256d. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castsi256_ps*
Synopsis
__m256 _mm256_castsi256_ps (__m256i a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256i to type __m256. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_castsi256_si128*
Synopsis
__m128i _mm256_castsi256_si128 (__m256i a)
#include <immintrin.h>
CPUID Flags: AVX
Description
Cast vector of type __m256i to type __m128i. This intrinsic is only used for
compilation and does not generate any instructions, thus it has zero latency.

===============================================================================
                        *_mm256_ceil_pd*
Synopsis
__m256d _mm256_ceil_pd (__m256d a)
#include <immintrin.h>
Instruction: vroundpd ymm, ymm, imm8
CPUID Flags: AVX
Description
Round the packed double-precision (64-bit) floating-point elements in a
up to an integer value, and store the results as packed double-precision
floating-point elements in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := CEIL(a[i+63:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_ceil_ps*
Synopsis
__m256 _mm256_ceil_ps (__m256 a)
#include <immintrin.h>
Instruction: vroundps ymm, ymm, imm8
CPUID Flags: AVX
Description
Round the packed single-precision (32-bit) floating-point elements in a up to an integer value, and store the results as packed single-precision floating-point elements in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := CEIL(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cmp_pd*
Synopsis
__m128d _mm_cmp_pd (__m128d a, __m128d b, const int imm8)
#include <immintrin.h>
Instruction: vcmppd xmm, xmm, xmm, imm8
CPUID Flags: AVX
Description
Compare packed double-precision (64-bit) floating-point elements
in a and b based on the comparison operand specified by imm8,
and store the results in dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cmp_pd*
Synopsis
__m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)
#include <immintrin.h>
Instruction: vcmppd ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Compare packed double-precision (64-bit) floating-point elements
in a and b based on the comparison operand specified by imm8,
and store the results in dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cmp_ps*
Synopsis
__m128 _mm_cmp_ps (__m128 a, __m128 b, const int imm8)
#include <immintrin.h>
Instruction: vcmpps xmm, xmm, xmm, imm8
CPUID Flags: AVX
Description
Compare packed single-precision (32-bit) floating-point elements
in a and b based on the comparison operand specified by imm8,
and store the results in dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] OP b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cmp_ps*
Synopsis
__m256 _mm256_cmp_ps (__m256 a, __m256 b, const int imm8)
#include <immintrin.h>
Instruction: vcmpps ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Compare packed single-precision (32-bit) floating-point elements
in a and b based on the comparison operand specified by imm8,
and store the results in dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] OP b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cmp_sd* *vcmpsd*
Synopsis
__m128d _mm_cmp_sd (__m128d a, __m128d b, const int imm8)
#include <immintrin.h>
Instruction: vcmpsd xmm, xmm, xmm, imm8
CPUID Flags: AVX
Description
Compare the lower double-precision (64-bit) floating-point element
in a and b based on the comparison operand specified by imm8,
store the result in the lower element of dst, and copy the upper
element from a to the upper element of dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
dst[63:0] := ( a[63:0] OP b[63:0] ) ? 0xFFFFFFFFFFFFFFFF : 0
dst[127:64] := a[127:64]
dst[MAX:128] := 0

===============================================================================
                        *_mm_cmp_ss* *vcmpss*
Synopsis
__m128 _mm_cmp_ss (__m128 a, __m128 b, const int imm8)
#include <immintrin.h>
Instruction: vcmpss xmm, xmm, xmm, imm8
CPUID Flags: AVX
Description
Compare the lower single-precision (32-bit) floating-point element
in a and b based on the comparison operand specified by imm8,
store the result in the lower element of dst, and copy the upper
3 packed elements from a to the upper elements of dst.
Operation
CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
dst[31:0] := ( a[31:0] OP b[31:0] ) ? 0xFFFFFFFF : 0
dst[127:32] := a[127:32]
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cmpeq_epi16* *vpcmpeqw*
Synopsis
__m256i _mm256_cmpeq_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpeqw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed 16-bit integers in a and b for equality,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpeq_epi32* *vpcmpeqd*
Synopsis
__m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpeqd ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed 32-bit integers in a and b for equality,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpeq_epi64* *vpcmpeqq*
Synopsis
__m256i _mm256_cmpeq_epi64 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpeqq ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed 64-bit integers in a and b for equality,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] == b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpeq_epi8* *vpcmpeqb*
Synopsis
__m256i _mm256_cmpeq_epi8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpeqb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed 8-bit integers in a and b for equality,
and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpgt_epi16* *vpcmpgtw*
Synopsis
__m256i _mm256_cmpgt_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpgtw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed signed 16-bit integers in a and b for greater-than,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ( a[i+15:i] > b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpgt_epi32* *vpcmpgtd*
Synopsis
__m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpgtd ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed signed 32-bit integers in a and b for greater-than,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] > b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpgt_epi64* *vpcmpgtq*
Synopsis
__m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpgtq ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed signed 64-bit integers in a and b for greater-than,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] > b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cmpgt_epi8* *vpcmpgtb*
Synopsis
__m256i _mm256_cmpgt_epi8 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpcmpgtb ymm, ymm, ymm
CPUID Flags: AVX2
Description
Compare packed signed 8-bit integers in a and b for greater-than,
and store the results in dst.
Operation
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ( a[i+7:i] > b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi16_epi32* *vpmovsxwd*
Synopsis
__m256i _mm256_cvtepi16_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxwd ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 16-bit integers in a to packed 32-bit integers,
and store the results in dst.
Operation
FOR j:= 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend32(a[k+15:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi16_epi64* *vpmovsxwq*
Synopsis
__m256i _mm256_cvtepi16_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxwq ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 16-bit integers in a to packed 64-bit integers,
and store the results in dst.
Operation
FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend64(a[k+15:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi32_epi64* *vpmovsxdq*
Synopsis
__m256i _mm256_cvtepi32_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxdq ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 32-bit integers in a to packed 64-bit integers,
and store the results in dst.
Operation
FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi32_pd* *vcvtdq2pd*
Synopsis
__m256d _mm256_cvtepi32_pd (__m128i a)
#include <immintrin.h>
Instruction: vcvtdq2pd ymm, xmm
CPUID Flags: AVX
Description
Convert packed signed 32-bit integers in a to packed double-precision (64-bit)
floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	m := j*64
	dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi32_ps* *vcvtdq2ps*
Synopsis
__m256 _mm256_cvtepi32_ps (__m256i a)
#include <immintrin.h>
Instruction: vcvtdq2ps ymm, ymm
CPUID Flags: AVX
Description
Convert packed signed 32-bit integers in a to packed single-precision (32-bit)
floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_Int32_To_FP32(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi8_epi16* *vpmovsxbw*
Synopsis
__m256i _mm256_cvtepi8_epi16 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxbw ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := SignExtend16(a[i+7:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi8_epi32* *vpmovsxbd*
Synopsis
__m256i _mm256_cvtepi8_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxbd ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 8-bit integers in a to packed 32-bit integers,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend32(a[k+7:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepi8_epi64* *vpmovsxbq*
Synopsis
__m256i _mm256_cvtepi8_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovsxbq ymm, xmm
CPUID Flags: AVX2
Description
Sign extend packed 8-bit integers in the low 8 bytes of a to packed
64-bit integers, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend64(a[k+7:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu16_epi32* *vpmovzxwd*
Synopsis
__m256i _mm256_cvtepu16_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxwd ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend32(a[k+15:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu16_epi64* *vpmovzxwq*
Synopsis
__m256i _mm256_cvtepu16_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxwq ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers,
and store the results in dst.
Operation
FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend64(a[k+15:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu32_epi64* *vpmovzxdq*
Synopsis
__m256i _mm256_cvtepu32_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxdq ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst.
Operation
FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu8_epi16* *vpmovzxbw*
Synopsis
__m256i _mm256_cvtepu8_epi16 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxbw ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers,
and store the results in dst.
Operation
FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := ZeroExtend16(a[i+7:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu8_epi32* *vpmovzxbd*
Synopsis
__m256i _mm256_cvtepu8_epi32 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxbd ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend32(a[k+7:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_cvtepu8_epi64* *vpmovzxbq*
Synopsis
__m256i _mm256_cvtepu8_epi64 (__m128i a)
#include <immintrin.h>
Instruction: vpmovzxbq ymm, xmm
CPUID Flags: AVX2
Description
Zero extend packed unsigned 8-bit integers in the low 8 byte sof a to
packed 64-bit integers, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend64(a[k+7:k])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cvtneebf16_ps*
Synopsis
__m128 _mm_cvtneebf16_ps (const __m128bh* __A)
#include <immintrin.h>
Instruction: vcvtneebf162ps xmm, m128
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed BF16 (16-bit) floating-point even-indexed elements stored
at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := Convert_BF16_To_FP32(MEM[__A+m+15:__A+m])
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cvtneebf16_ps*
Synopsis
__m256 _mm256_cvtneebf16_ps (const __m256bh* __A)
#include <immintrin.h>
Instruction: vcvtneebf162ps ymm, m256
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed BF16 (16-bit) floating-point even-indexed elements stored
at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := Convert_BF16_To_FP32(MEM[__A+m+15:__A+m])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cvtneeph_ps*
Synopsis
__m128 _mm_cvtneeph_ps (const __m128h* __A)
#include <immintrin.h>
Instruction: vcvtneeph2ps xmm, m128
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed half-precision (16-bit) floating-point even-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := Convert_FP16_To_FP32(MEM[__A+m+15:__A+m])
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_cvtneeph_ps*
Synopsis
__m256 _mm256_cvtneeph_ps (const __m256h* __A)
#include <immintrin.h>
Instruction: vcvtneeph2ps ymm, m256
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed half-precision (16-bit) floating-point even-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := Convert_FP16_To_FP32(MEM[__A+m+15:__A+m])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_cvtneobf16_ps*
Synopsis
__m128 _mm_cvtneobf16_ps (const __m128bh* __A)
#include <immintrin.h>
Instruction: vcvtneobf162ps xmm, m128
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed BF16 (16-bit) floating-point odd-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := Convert_BF16_To_FP32(MEM[__A+m+31:__A+m+16])
ENDFOR
dst[MAX:128] := 0
=============================================================================== 
                        *_mm256_cvtneobf16_ps*
Synopsis
__m256 _mm256_cvtneobf16_ps (const __m256bh* __A)
#include <immintrin.h>
Instruction: vcvtneobf162ps ymm, m256
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed BF16 (16-bit) floating-point odd-indexed elements stored at
memory locations starting at location __A to packed single-precision (32-bit)
floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := Convert_BF16_To_FP32(MEM[__A+m+31:__A+m+16])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_cvtneoph_ps*
Synopsis
__m128 _mm_cvtneoph_ps (const __m128h* __A)
#include <immintrin.h>
Instruction: vcvtneoph2ps xmm, m128
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed half-precision (16-bit) floating-point odd-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	m := j*32
	dst[m+31:m] := Convert_FP16_To_FP32(MEM[__A+m+31:__A+m+16])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtneoph_ps*
Synopsis
__m256 _mm256_cvtneoph_ps (const __m256h* __A)
#include <immintrin.h>
Instruction: vcvtneoph2ps ymm, m256
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed half-precision (16-bit) floating-point odd-indexed elements
stored at memory locations starting at location __A to packed single-precision
(32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	m := j*32
	dst[m+31:m] := Convert_FP16_To_FP32(MEM[__A+m+31:__A+m+16])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_cvtneps_avx_pbh*
Synopsis
__m128bh _mm_cvtneps_avx_pbh (__m128 __A)
#include <immintrin.h>
Instruction: vcvtneps2bf16 xmm, xmm
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed single-precision (32-bit) floating-point elements in __A
to packed BF16 (16-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	dst.word[j] := Convert_FP32_To_BF16(__A.fp32[j])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtneps_avx_pbh*
Synopsis
__m128bh _mm256_cvtneps_avx_pbh (__m256 __A)
#include <immintrin.h>
Instruction: vcvtneps2bf16 xmm, ymm
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed single-precision (32-bit) floating-point elements in __A
to packed BF16 (16-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	dst.word[j] := Convert_FP32_To_BF16(__A.fp32[j])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm_cvtneps_pbh*
Synopsis
__m128bh _mm_cvtneps_pbh (__m128 __A)
#include <immintrin.h>
Instruction: vcvtneps2bf16 xmm, xmm
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed single-precision (32-bit) floating-point elements in __A
to packed BF16 (16-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	dst.word[j] := Convert_FP32_To_BF16(__A.fp32[j])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtneps_pbh*
Synopsis
__m128bh _mm256_cvtneps_pbh (__m256 __A)
#include <immintrin.h>
Instruction: vcvtneps2bf16 xmm, ymm
CPUID Flags: AVX_NE_CONVERT
Description
Convert packed single-precision (32-bit) floating-point elements in __A
to packed BF16 (16-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 7
	dst.word[j] := Convert_FP32_To_BF16(__A.fp32[j])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtpd_epi32* *vcvtpd2dq*
Synopsis
__m128i _mm256_cvtpd_epi32 (__m256d a)
#include <immintrin.h>
Instruction: vcvtpd2dq xmm, ymm
CPUID Flags: AVX
Description
Convert packed double-precision (64-bit) floating-point elements in a
to packed 32-bit integers, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32(a[k+63:k])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtpd_ps* *vcvtpd2ps*
Synopsis
__m128 _mm256_cvtpd_ps (__m256d a)
#include <immintrin.h>
Instruction: vcvtpd2ps xmm, ymm
CPUID Flags: AVX
Description
Convert packed double-precision (64-bit) floating-point elements in a to packed
single-precision (32-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_FP32(a[k+63:k])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvtps_epi32* *vcvtps2dq*
Synopsis
__m256i _mm256_cvtps_epi32 (__m256 a)
#include <immintrin.h>
Instruction: vcvtps2dq ymm, ymm
CPUID Flags: AVX
Description
Convert packed single-precision (32-bit) floating-point elements in a
to packed 32-bit integers, and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_cvtps_pd* *vcvtps2pd*
Synopsis
__m256d _mm256_cvtps_pd (__m128 a)
#include <immintrin.h>
Instruction: vcvtps2pd ymm, xmm
CPUID Flags: AVX
Description
Convert packed single-precision (32-bit) floating-point elements in a to packed
double-precision (64-bit) floating-point elements, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := Convert_FP32_To_FP64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_cvtsd_f64* *vmovsd*
Synopsis
double _mm256_cvtsd_f64 (__m256d a)
#include <immintrin.h>
Instruction: vmovsd m64, xmm
CPUID Flags: AVX
Description
Copy the lower double-precision (64-bit) floating-point element of a to dst.
Operation
dst[63:0] := a[63:0]

=============================================================================== 
                        *_mm256_cvtsi256_si32* *vmovd*
Synopsis
int _mm256_cvtsi256_si32 (__m256i a)
#include <immintrin.h>
Instruction: vmovd r32, xmm
CPUID Flags: AVX
Description
Copy the lower 32-bit integer in a to dst.
Operation
dst[31:0] := a[31:0]

=============================================================================== 
                        *_mm256_cvtss_f32* *vmovss*
Synopsis
float _mm256_cvtss_f32 (__m256 a)
#include <immintrin.h>
Instruction: vmovss m32, xmm
CPUID Flags: AVX
Description
Copy the lower single-precision (32-bit) floating-point element of a to dst.
Operation
dst[31:0] := a[31:0]

=============================================================================== 
                        *_mm256_cvttpd_epi32* *vcvttpd2dq*
Synopsis
__m128i _mm256_cvttpd_epi32 (__m256d a)
#include <immintrin.h>
Instruction: vcvttpd2dq xmm, ymm
CPUID Flags: AVX
Description
Convert packed double-precision (64-bit) floating-point elements in a
to packed 32-bit integers with truncation, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 32*j
	k := 64*j
	dst[i+31:i] := Convert_FP64_To_Int32_Truncate(a[k+63:k])
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_cvttps_epi32* *vcvttps2dq*
Synopsis
__m256i _mm256_cvttps_epi32 (__m256 a)
#include <immintrin.h>
Instruction: vcvttps2dq ymm, ymm
CPUID Flags: AVX
Description
Convert packed single-precision (32-bit) floating-point elements in a
to packed 32-bit integers with truncation, and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := Convert_FP32_To_Int32_Truncate(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_div_pd* *vdivpd* 
Synopsis
__m256d _mm256_div_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vdivpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Divide packed double-precision (64-bit) floating-point elements in a by packed
elements in b, and store the results in dst.
Operation
FOR j := 0 to 3
	i := 64*j
	dst[i+63:i] := a[i+63:i] / b[i+63:i]
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_div_ps* *vdivps*
Synopsis
__m256 _mm256_div_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vdivps ymm, ymm, ymm
CPUID Flags: AVX
Description
Divide packed single-precision (32-bit) floating-point elements in a by packed
elements in b, and store the results in dst.
Operation
FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := a[i+31:i] / b[i+31:i]
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_dp_ps* *vdpps*
Synopsis
__m256 _mm256_dp_ps (__m256 a, __m256 b, const int imm8)
#include <immintrin.h>
Instruction: vdpps ymm, ymm, ymm, imm8
CPUID Flags: AVX
Description
Conditionally multiply the packed single-precision (32-bit) floating-point
elements in a and b using the high 4 bits in imm8, sum the four products,
and conditionally store the sum in dst using the low 4 bits of imm8.
Operation
>
	DEFINE DP(a[127:0], b[127:0], imm8[7:0]) {
		FOR j := 0 to 3
			i := j*32
			IF imm8[(4+j)%8]
				temp[i+31:i] := a[i+31:i] * b[i+31:i]
			ELSE
				temp[i+31:i] := FP32(0.0)
			FI
		ENDFOR
		
		sum[31:0] := (temp[127:96] + temp[95:64]) + (temp[63:32] + temp[31:0])
		
		FOR j := 0 to 3
			i := j*32
			IF imm8[j%8]
				tmpdst[i+31:i] := sum[31:0]
			ELSE
				tmpdst[i+31:i] := FP32(0.0)
			FI
		ENDFOR
		RETURN tmpdst[127:0]
	}
<
dst[127:0] := DP(a[127:0], b[127:0], imm8[7:0])
dst[255:128] := DP(a[255:128], b[255:128], imm8[7:0])
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbssd_epi32*
Synopsis
__m128i _mm_dpbssd_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbssd xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding signed 8-bit integers in __B, producing 4 intermediate
signed 16-bit results. Sum these 4 results with the corresponding
32-bit integer in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := SignExtend16(__A.byte[4*j]) * SignExtend16(__B.byte[4*j])
	tmp2.word := SignExtend16(__A.byte[4*j+1]) * SignExtend16(__B.byte[4*j+1])
	tmp3.word := SignExtend16(__A.byte[4*j+2]) * SignExtend16(__B.byte[4*j+2])
	tmp4.word := SignExtend16(__A.byte[4*j+3]) * SignExtend16(__B.byte[4*j+3])
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbssd_epi32*
Synopsis
__m256i _mm256_dpbssd_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbssd ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding signed 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := SignExtend16(__A.byte[4*j]) * SignExtend16(__B.byte[4*j])
	tmp2.word := SignExtend16(__A.byte[4*j+1]) * SignExtend16(__B.byte[4*j+1])
	tmp3.word := SignExtend16(__A.byte[4*j+2]) * SignExtend16(__B.byte[4*j+2])
	tmp4.word := SignExtend16(__A.byte[4*j+3]) * SignExtend16(__B.byte[4*j+3])
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbssds_epi32*
Synopsis
__m128i _mm_dpbssds_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbssds xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding signed 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W with signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := SignExtend16(__A.byte[4*j]) * SignExtend16(__B.byte[4*j])
	tmp2.word := SignExtend16(__A.byte[4*j+1]) * SignExtend16(__B.byte[4*j+1])
	tmp3.word := SignExtend16(__A.byte[4*j+2]) * SignExtend16(__B.byte[4*j+2])
	tmp4.word := SignExtend16(__A.byte[4*j+3]) * SignExtend16(__B.byte[4*j+3])
	dst.dword[j] := SIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbssds_epi32*
Synopsis
__m256i _mm256_dpbssds_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbssds ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding signed 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W with signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := SignExtend16(__A.byte[4*j]) * SignExtend16(__B.byte[4*j])
	tmp2.word := SignExtend16(__A.byte[4*j+1]) * SignExtend16(__B.byte[4*j+1])
	tmp3.word := SignExtend16(__A.byte[4*j+2]) * SignExtend16(__B.byte[4*j+2])
	tmp4.word := SignExtend16(__A.byte[4*j+3]) * SignExtend16(__B.byte[4*j+3])
	dst.dword[j] := SIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbsud_epi32*
Synopsis
__m128i _mm_dpbsud_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbsud xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding unsigned 8-bit integers in __B, producing 4 intermediate
signed 16-bit results. Sum these 4 results with the corresponding 32-bit
integer in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(SignExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j]))
	tmp2.word := Signed(SignExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1]))
	tmp3.word := Signed(SignExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2]))
	tmp4.word := Signed(SignExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3]))
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbsud_epi32*
Synopsis
__m256i _mm256_dpbsud_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbsud ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := Signed(SignExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j]))
	tmp2.word := Signed(SignExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1]))
	tmp3.word := Signed(SignExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2]))
	tmp4.word := Signed(SignExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3]))
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0
===============================================================================
                        *_mm_dpbsuds_epi32*
Synopsis
__m128i _mm_dpbsuds_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbsuds xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding unsigned 8-bit integers in __B, producing 4 intermediate
signed 16-bit results. Sum these 4 results with the corresponding 32-bit
integer in __W with signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(SignExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j]))
	tmp2.word := Signed(SignExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1]))
	tmp3.word := Signed(SignExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2]))
	tmp4.word := Signed(SignExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3]))
	dst.dword[j] := SIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbsuds_epi32*
Synopsis
__m256i _mm256_dpbsuds_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbsuds ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W with signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := Signed(SignExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j]))
	tmp2.word := Signed(SignExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1]))
	tmp3.word := Signed(SignExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2]))
	tmp4.word := Signed(SignExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3]))
	dst.dword[j] := SIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbusd_avx_epi32*
Synopsis
__m128i _mm_dpbusd_avx_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpbusd xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with
corresponding signed 8-bit integers in b, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in src, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbusd_avx_epi32*
Synopsis
__m256i _mm256_dpbusd_avx_epi32 (__m256i src, __m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpdpbusd ymm, ymm, ymm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with
corresponding signed 8-bit integers in b, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in src, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbusd_epi32*
Synopsis
__m128i _mm_dpbusd_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpbusd xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with
corresponding signed 8-bit integers in b, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in src, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm_dpbusds_avx_epi32*
Synopsis
__m128i _mm_dpbusds_avx_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpbusds xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with
corresponding signed 8-bit integers in b, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in src using signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbusds_avx_epi32*
Synopsis
__m256i _mm256_dpbusds_avx_epi32 (__m256i src, __m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpdpbusds ymm, ymm, ymm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with
corresponding signed 8-bit integers in b, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in src using signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbusds_epi32*
Synopsis
__m128i _mm_dpbusds_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpbusds xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with
corresponding signed 8-bit integers in b, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in src using signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbusds_epi32*
Synopsis
__m256i _mm256_dpbusds_epi32 (__m256i src, __m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpdpbusds ymm, ymm, ymm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with
corresponding signed 8-bit integers in b, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in src using signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbuud_epi32*
Synopsis
__m128i _mm_dpbuud_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbuud xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in __A with
corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := ZeroExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j])
	tmp2.word := ZeroExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1])
	tmp3.word := ZeroExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2])
	tmp4.word := ZeroExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3])
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbuud_epi32*
Synopsis
__m256i _mm256_dpbuud_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbuud ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in __A with
corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := ZeroExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j])
	tmp2.word := ZeroExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1])
	tmp3.word := ZeroExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2])
	tmp4.word := ZeroExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3])
	dst.dword[j] := __W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpbuuds_epi32*
Synopsis
__m128i _mm_dpbuuds_epi32 (__m128i __W, __m128i __A, __m128i __B)
#include <immintrin.h>
Instruction: vpdpbuuds xmm, xmm, xmm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in __A with
corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W with unsigned saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.word := ZeroExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j])
	tmp2.word := ZeroExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1])
	tmp3.word := ZeroExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2])
	tmp4.word := ZeroExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3])
	dst.dword[j] := UNSIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpbuuds_epi32*
Synopsis
__m256i _mm256_dpbuuds_epi32 (__m256i __W, __m256i __A, __m256i __B)
#include <immintrin.h>
Instruction: vpdpbuuds ymm, ymm, ymm
CPUID Flags: AVX_VNNI_INT8
Description
Multiply groups of 4 adjacent pairs of signed 8-bit integers in __A with
corresponding unsigned 8-bit integers in __B, producing 4 intermediate signed
16-bit results. Sum these 4 results with the corresponding 32-bit integer
in __W with unsigned saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.word := ZeroExtend16(__A.byte[4*j]) * ZeroExtend16(__B.byte[4*j])
	tmp2.word := ZeroExtend16(__A.byte[4*j+1]) * ZeroExtend16(__B.byte[4*j+1])
	tmp3.word := ZeroExtend16(__A.byte[4*j+2]) * ZeroExtend16(__B.byte[4*j+2])
	tmp4.word := ZeroExtend16(__A.byte[4*j+3]) * ZeroExtend16(__B.byte[4*j+3])
	dst.dword[j] := UNSIGNED_DWORD_SATURATE(__W.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpwssd_avx_epi32*
Synopsis
__m128i _mm_dpwssd_avx_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpwssd xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with
corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit
results. Sum these 2 results with the corresponding 32-bit integer in src,
and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpwssd_avx_epi32*
Synopsis
__m256i _mm256_dpwssd_avx_epi32 (__m256i src, __m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpdpwssd ymm, ymm, ymm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with
corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit
results. Sum these 2 results with the corresponding 32-bit integer in src,
and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpwssd_epi32*
Synopsis
__m128i _mm_dpwssd_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpwssd xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with
corresponding 16-bit integers in b, producing 2 intermediate signed
32-bit results. Sum these 2 results with the corresponding 32-bit integer
in src, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpwssd_epi32*
Synopsis
__m256i _mm256_dpwssd_epi32 (__m256i src, __m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpdpwssd ymm, ymm, ymm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with
corresponding 16-bit integers in b, producing 2 intermediate signed
32-bit results. Sum these 2 results with the corresponding 32-bit integer
in src, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpwssds_avx_epi32*
Synopsis
__m128i _mm_dpwssds_avx_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpwssds xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with
corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit
results. Sum these 2 results with the corresponding 32-bit integer in src
using signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpwssds_avx_epi32*
Synopsis
__m256i _mm256_dpwssds_avx_epi32 (__m256i src, __m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpdpwssds ymm, ymm, ymm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with
corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit
results. Sum these 2 results with the corresponding 32-bit integer in src
using signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm_dpwssds_epi32*
Synopsis
__m128i _mm_dpwssds_epi32 (__m128i src, __m128i a, __m128i b)
#include <immintrin.h>
Instruction: vpdpwssds xmm, xmm, xmm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with
corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit
results. Sum these 2 results with the corresponding 32-bit integer in src
using signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 3
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:128] := 0

=============================================================================== 
                        *_mm256_dpwssds_epi32*
Synopsis
__m256i _mm256_dpwssds_epi32 (__m256i src, __m256i a, __m256i b)
#include <immintrin.h>
Instruction: vpdpwssds ymm, ymm, ymm
CPUID Flags: AVX_VNNI
Description
Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with
corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit
results. Sum these 2 results with the corresponding 32-bit integer in src
using signed saturation, and store the packed 32-bit results in dst.
Operation
FOR j := 0 to 7
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:256] := 0

=============================================================================== 
                        *_mm256_extract_epi16*
Synopsis
int _mm256_extract_epi16 (__m256i a, const int index)
#include <immintrin.h>
Instruction: Sequence
CPUID Flags: AVX2
Description
Extract a 16-bit integer from a, selected with index, and store the result in dst.
Operation
dst[15:0] := (a[255:0] >> (index[3:0] * 16))[15:0]

=============================================================================== 
                        *_mm256_extract_epi32*
Synopsis
__int32 _mm256_extract_epi32 (__m256i a, const int index)
#include <immintrin.h>
Instruction: Sequence
CPUID Flags: AVX
Description
Extract a 32-bit integer from a, selected with index, and store the result in dst.
Operation
dst[31:0] := (a[255:0] >> (index[2:0] * 32))[31:0]

===============================================================================
                        *_mm256_extract_epi64*
Synopsis
__int64 _mm256_extract_epi64 (__m256i a, const int index)
#include <immintrin.h>
Instruction: Sequence
CPUID Flags: AVX
Description
Extract a 64-bit integer from a, selected with index, and store the result in dst.
Operation
dst[63:0] := (a[255:0] >> (index[1:0] * 64))[63:0]

===============================================================================
                        *_mm256_extract_epi8*
Synopsis
int _mm256_extract_epi8 (__m256i a, const int index)
#include <immintrin.h>
Instruction: Sequence
CPUID Flags: AVX2
Description
Extract an 8-bit integer from a, selected with index, and store the result in dst.
Operation
dst[7:0] := (a[255:0] >> (index[4:0] * 8))[7:0]

===============================================================================
                        *_mm256_extractf128_pd*
Synopsis
__m128d _mm256_extractf128_pd (__m256d a, const int imm8)
#include <immintrin.h>
Instruction: vextractf128 xmm, ymm, imm8
CPUID Flags: AVX
Description
Extract 128 bits (composed of 2 packed double-precision (64-bit)floating-point elements)
from a, selected with imm8, and store the result in dst.
Operation
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
vextractf128

===============================================================================
                        *_mm256_extractf128_ps*
Synopsis
__m128 _mm256_extractf128_ps (__m256 a, const int imm8)
#include <immintrin.h>
Instruction: vextractf128 xmm, ymm, imm8
CPUID Flags: AVX
Description
Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements)
from a, selected with imm8, and store the result in dst.
Operation
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
vextractf128

===============================================================================
                        *_mm256_extractf128_si256*
Synopsis
__m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
#include <immintrin.h>
Instruction: vextractf128 xmm, ymm, imm8
CPUID Flags: AVX
Description
Extract 128 bits (composed of integer data) from a, selected with imm8,
and store the result in dst.
Operation
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0

===============================================================================
                        *_mm256_extracti128_si256*
Synopsis
__m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
#include <immintrin.h>
Instruction: vextracti128 xmm, ymm, imm8
CPUID Flags: AVX2
Description
Extract 128 bits (composed of integer data) from a, selected with imm8,
and store the result in dst.
Operation
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0

===============================================================================
                        *_mm256_floor_pd*
Synopsis
__m256d _mm256_floor_pd (__m256d a)
#include <immintrin.h>
Instruction: vroundpd ymm, ymm, imm8
CPUID Flags: AVX
Description
Round the packed double-precision (64-bit) floating-point elements in
a down to an integer value, and store the results as packed double-precision
floating-point elements in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := FLOOR(a[i+63:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_floor_ps*
Synopsis
__m256 _mm256_floor_ps (__m256 a)
#include <immintrin.h>
Instruction: vroundps ymm, ymm, imm8
CPUID Flags: AVX
Description
Round the packed single-precision (32-bit) floating-point elements in a
down to an integer value, and store the results as packed single-precision
floating-point elements in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := FLOOR(a[i+31:i])
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fmadd_pd*
Synopsis
__m128d _mm_fmadd_pd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfmadd132pd xmm, xmm, xmm
             vfmadd213pd xmm, xmm, xmm
             vfmadd231pd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
add the intermediate result to packed elements in c, and store the results in dst.
Operation
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fmadd_pd*
Synopsis
__m256d _mm256_fmadd_pd (__m256d a, __m256d b, __m256d c)
#include <immintrin.h>
Instruction: vfmadd132pd ymm, ymm, ymm
             vfmadd213pd ymm, ymm, ymm
             vfmadd231pd ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
add the intermediate result to packed elements in c, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fmadd_ps*
Synopsis
__m128 _mm_fmadd_ps (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfmadd132ps xmm, xmm, xmm
             vfmadd213ps xmm, xmm, xmm
             vfmadd231ps xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
add the intermediate result to packed elements in c, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fmadd_ps*
Synopsis
__m256 _mm256_fmadd_ps (__m256 a, __m256 b, __m256 c)
#include <immintrin.h>
Instruction: vfmadd132ps ymm, ymm, ymm
             vfmadd213ps ymm, ymm, ymm
             vfmadd231ps ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
add the intermediate result to packed elements in c, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fmadd_sd*
Synopsis
__m128d _mm_fmadd_sd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfmadd132sd xmm, xmm, xmm
             vfmadd213sd xmm, xmm, xmm
             vfmadd231sd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply the lower double-precision (64-bit) floating-point elements in a and b,
and add the intermediate result to the lower element in c. Store the result in the
lower element of dst, and copy the upper element from a to the upper element of dst.
Operation
dst[63:0] := (a[63:0] * b[63:0]) + c[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0

===============================================================================
                        *_mm_fmadd_ss*
Synopsis
__m128 _mm_fmadd_ss (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfmadd132ss xmm, xmm, xmm
             vfmadd213ss xmm, xmm, xmm
             vfmadd231ss xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply the lower single-precision (32-bit) floating-point elements in a and b,
and add the intermediate result to the lower element in c. Store the result in the
lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.
Operation
dst[31:0] := (a[31:0] * b[31:0]) + c[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0

===============================================================================
                        *_mm_fmaddsub_pd*
Synopsis
__m128d _mm_fmaddsub_pd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfmaddsub132pd xmm, xmm, xmm
             vfmaddsub213pd xmm, xmm, xmm
             vfmaddsub231pd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
alternatively add and subtract packed elements in c to/from the intermediate
result, and store the results in dst.
Operation
FOR j := 0 to 1
	i := j*64
	IF ((j & 1) == 0) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fmaddsub_pd*
Synopsis
__m256d _mm256_fmaddsub_pd (__m256d a, __m256d b, __m256d c)
#include <immintrin.h>
Instruction: vfmaddsub132pd ymm, ymm, ymm
             vfmaddsub213pd ymm, ymm, ymm
             vfmaddsub231pd ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
alternatively add and subtract packed elements in c to/from the intermediate
result, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	IF ((j & 1) == 0) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fmaddsub_ps*
Synopsis
__m128 _mm_fmaddsub_ps (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfmaddsub132ps xmm, xmm, xmm
             vfmaddsub213ps xmm, xmm, xmm
             vfmaddsub231ps xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
alternatively add and subtract packed elements in c to/from the intermediate result,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	IF ((j & 1) == 0) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fmaddsub_ps*
Synopsis
__m256 _mm256_fmaddsub_ps (__m256 a, __m256 b, __m256 c)
#include <immintrin.h>
Instruction: vfmaddsub132ps ymm, ymm, ymm
             vfmaddsub213ps ymm, ymm, ymm
             vfmaddsub231ps ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
alternatively add and subtract packed elements in c to/from the intermediate result,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF ((j & 1) == 0) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fmsub_pd*
Synopsis
__m128d _mm_fmsub_pd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfmsub132pd xmm, xmm, xmm
             vfmsub213pd xmm, xmm, xmm
             vfmsub231pd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
subtract packed elements in c from the intermediate result, and store the results in dst.
Operation
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fmsub_pd*
Synopsis
__m256d _mm256_fmsub_pd (__m256d a, __m256d b, __m256d c)
#include <immintrin.h>
Instruction: vfmsub132pd ymm, ymm, ymm
             vfmsub213pd ymm, ymm, ymm
             vfmsub231pd ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
subtract packed elements in c from the intermediate result, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fmsub_ps*
Synopsis
__m128 _mm_fmsub_ps (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfmsub132ps xmm, xmm, xmm
             vfmsub213ps xmm, xmm, xmm
             vfmsub231ps xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
subtract packed elements in c from the intermediate result, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fmsub_ps*
Synopsis
__m256 _mm256_fmsub_ps (__m256 a, __m256 b, __m256 c)
#include <immintrin.h>
Instruction: vfmsub132ps ymm, ymm, ymm
             vfmsub213ps ymm, ymm, ymm
             vfmsub231ps ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
subtract packed elements in c from the intermediate result, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fmsub_sd*
(__m128d a, __m128d b, __m128d c)
Synopsis
__m128d _mm_fmsub_sd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfmsub132sd xmm, xmm, xmm
             vfmsub213sd xmm, xmm, xmm
             vfmsub231sd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply the lower double-precision (64-bit) floating-point elements
in a and b, and subtract the lower element in c from the intermediate result.
Store the result in the lower element of dst, and copy the upper element
from a to the upper element of dst.
Operation
dst[63:0] := (a[63:0] * b[63:0]) - c[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0

===============================================================================
                        *_mm_fmsub_ss*
Synopsis
__m128 _mm_fmsub_ss (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfmsub132ss xmm, xmm, xmm
             vfmsub213ss xmm, xmm, xmm
             vfmsub231ss xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply the lower single-precision (32-bit) floating-point elements
in a and b, and subtract the lower element in c from the intermediate result.
Store the result in the lower element of dst, and copy the upper 3 packed
elements from a to the upper elements of dst.
Operation
dst[31:0] := (a[31:0] * b[31:0]) - c[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0

===============================================================================
                        *_mm_fmsubadd_pd*
Synopsis
__m128d _mm_fmsubadd_pd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfmsubadd132pd xmm, xmm, xmm
             vfmsubadd213pd xmm, xmm, xmm
             vfmsubadd231pd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements
in a and b, alternatively subtract and add packed elements in c
from/to the intermediate result, and store the results in dst.
Operation
FOR j := 0 to 1
	i := j*64
	IF ((j & 1) == 0) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0

===============================================================================
*_mm256_fmsubadd_pd*
Synopsis
__m256d _mm256_fmsubadd_pd (__m256d a, __m256d b, __m256d c)
#include <immintrin.h>
Instruction: vfmsubadd132pd ymm, ymm, ymm
             vfmsubadd213pd ymm, ymm, ymm
             vfmsubadd231pd ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements
in a and b, alternatively subtract and add packed elements in
c from/to the intermediate result, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	IF ((j & 1) == 0) 
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) + c[i+63:i]
	ELSE
		dst[i+63:i] := (a[i+63:i] * b[i+63:i]) - c[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fmsubadd_ps*
Synopsis
__m128 _mm_fmsubadd_ps (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfmsubadd132ps xmm, xmm, xmm
             vfmsubadd213ps xmm, xmm, xmm
             vfmsubadd231ps xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements
in a and b, alternatively subtract and add packed elements in
c from/to the intermediate result, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	IF ((j & 1) == 0) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fmsubadd_ps* *vfmsubadd132ps*
Synopsis
__m256 _mm256_fmsubadd_ps (__m256 a, __m256 b, __m256 c)
#include <immintrin.h>
Instruction: vfmsubadd132ps ymm, ymm, ymm
             vfmsubadd213ps ymm, ymm, ymm
             vfmsubadd231ps ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
alternatively subtract and add packed elements in c from/to the intermediate
result, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	IF ((j & 1) == 0) 
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) - c[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm_fnmadd_pd* *vfnmadd132pd*
Synopsis
__m128d _mm_fnmadd_pd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfnmadd132pd xmm, xmm, xmm
             vfnmadd213pd xmm, xmm, xmm
             vfnmadd231pd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
add the negated intermediate result to packed elements in c, and store the results in dst.
Operation
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR	
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fnmadd_pd* *vfnmadd132ps*
Synopsis
__m256d _mm256_fnmadd_pd (__m256d a, __m256d b, __m256d c)
#include <immintrin.h>
Instruction: vfnmadd132pd ymm, ymm, ymm
             vfnmadd213pd ymm, ymm, ymm
             vfnmadd231pd ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
add the negated intermediate result to packed elements in c, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) + c[i+63:i]
ENDFOR	
dst[MAX:256] := 0

===============================================================================
                        *_mm_fnmadd_ps*
Synopsis
__m128 _mm_fnmadd_ps (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfnmadd132ps xmm, xmm, xmm
             vfnmadd213ps xmm, xmm, xmm
             vfnmadd231ps xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
add the negated intermediate result to packed elements in c, and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR	
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fnmadd_ps*
Synopsis
__m256 _mm256_fnmadd_ps (__m256 a, __m256 b, __m256 c)
#include <immintrin.h>
Instruction: vfnmadd132ps ymm, ymm, ymm
             vfnmadd213ps ymm, ymm, ymm
             vfnmadd231ps ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
add the negated intermediate result to packed elements in c, and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR	
dst[MAX:256] := 0

===============================================================================
                        *_mm_fnmadd_sd*
Synopsis
__m128d _mm_fnmadd_sd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfnmadd132sd xmm, xmm, xmm
             vfnmadd213sd xmm, xmm, xmm
             vfnmadd231sd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply the lower double-precision (64-bit) floating-point
elements in a and b, and add the negated intermediate result
to the lower element in c. Store the result in the lower element
of dst, and copy the upper element from a to the upper element of dst.
Operation
dst[63:0] := -(a[63:0] * b[63:0]) + c[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0

===============================================================================
                        *_mm_fnmadd_ss*
Synopsis
__m128 _mm_fnmadd_ss (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfnmadd132ss xmm, xmm, xmm
             vfnmadd213ss xmm, xmm, xmm
             vfnmadd231ss xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply the lower single-precision (32-bit) floating-point elements
in a and b, and add the negated intermediate result to the lower
element in c. Store the result in the lower element of dst, and
copy the upper 3 packed elements from a to the upper elements of dst.
Operation
dst[31:0] := -(a[31:0] * b[31:0]) + c[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0

===============================================================================
                        *_mm_fnmsub_pd*
Synopsis
__m128d _mm_fnmsub_pd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfnmsub132pd xmm, xmm, xmm
             vfnmsub213pd xmm, xmm, xmm
             vfnmsub231pd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
subtract packed elements in c from the negated intermediate result,
and store the results in dst.
Operation
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR	
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fnmsub_pd*
Synopsis
__m256d _mm256_fnmsub_pd (__m256d a, __m256d b, __m256d c)
#include <immintrin.h>
Instruction: vfnmsub132pd ymm, ymm, ymm
             vfnmsub213pd ymm, ymm, ymm
             vfnmsub231pd ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed double-precision (64-bit) floating-point elements in a and b,
subtract packed elements in c from the negated intermediate result,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := -(a[i+63:i] * b[i+63:i]) - c[i+63:i]
ENDFOR	
dst[MAX:256] := 0

===============================================================================
                        *_mm_fnmsub_ps*
Synopsis
__m128 _mm_fnmsub_ps (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfnmsub132ps xmm, xmm, xmm
             vfnmsub213ps xmm, xmm, xmm
             vfnmsub231ps xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
subtract packed elements in c from the negated intermediate result,
and store the results in dst.
Operation
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR	
dst[MAX:128] := 0

===============================================================================
                        *_mm256_fnmsub_ps*
Synopsis
__m256 _mm256_fnmsub_ps (__m256 a, __m256 b, __m256 c)
#include <immintrin.h>
Instruction: vfnmsub132ps ymm, ymm, ymm
             vfnmsub213ps ymm, ymm, ymm
             vfnmsub231ps ymm, ymm, ymm
CPUID Flags: FMA
Description
Multiply packed single-precision (32-bit) floating-point elements in a and b,
subtract packed elements in c from the negated intermediate result,
and store the results in dst.
Operation
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := -(a[i+31:i] * b[i+31:i]) - c[i+31:i]
ENDFOR	
dst[MAX:256] := 0

===============================================================================
                        *_mm_fnmsub_sd*
Synopsis
__m128d _mm_fnmsub_sd (__m128d a, __m128d b, __m128d c)
#include <immintrin.h>
Instruction: vfnmsub132sd xmm, xmm, xmm
             vfnmsub213sd xmm, xmm, xmm
             vfnmsub231sd xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply the lower double-precision (64-bit) floating-point elements in a and b,
and subtract the lower element in c from the negated intermediate result.
Store the result in the lower element of dst, and copy the upper element
from a to the upper element of dst.
Operation
dst[63:0] := -(a[63:0] * b[63:0]) - c[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0

===============================================================================
                        *_mm_fnmsub_ss*
Synopsis
__m128 _mm_fnmsub_ss (__m128 a, __m128 b, __m128 c)
#include <immintrin.h>
Instruction: vfnmsub132ss xmm, xmm, xmm
             vfnmsub213ss xmm, xmm, xmm
             vfnmsub231ss xmm, xmm, xmm
CPUID Flags: FMA
Description
Multiply the lower single-precision (32-bit) floating-point elements in a and b,
and subtract the lower element in c from the negated intermediate result.
Store the result in the lower element of dst, and copy the upper 3 packed
elements from a to the upper elements of dst.
Operation
dst[31:0] := -(a[31:0] * b[31:0]) - c[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0

===============================================================================
                        *_mm256_hadd_epi16* *vphaddw*
Synopsis
__m256i _mm256_hadd_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vphaddw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Horizontally add adjacent pairs of 16-bit integers in a and b,
and pack the signed 16-bit results in dst.
Operation
dst[15:0] := a[31:16] + a[15:0]
dst[31:16] := a[63:48] + a[47:32]
dst[47:32] := a[95:80] + a[79:64]
dst[63:48] := a[127:112] + a[111:96]
dst[79:64] := b[31:16] + b[15:0]
dst[95:80] := b[63:48] + b[47:32]
dst[111:96] := b[95:80] + b[79:64]
dst[127:112] := b[127:112] + b[111:96]
dst[143:128] := a[159:144] + a[143:128]
dst[159:144] := a[191:176] + a[175:160]
dst[175:160] := a[223:208] + a[207:192]
dst[191:176] := a[255:240] + a[239:224]
dst[207:192] := b[159:144] + b[143:128]
dst[223:208] := b[191:176] + b[175:160]
dst[239:224] := b[223:208] + b[207:192]
dst[255:240] := b[255:240] + b[239:224]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hadd_epi32* *vphaddd*
Synopsis
__m256i _mm256_hadd_epi32 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vphaddd ymm, ymm, ymm
CPUID Flags: AVX2
Description
Horizontally add adjacent pairs of 32-bit integers in a and b,
and pack the signed 32-bit results in dst.
Operation
dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]
dst[159:128] := a[191:160] + a[159:128]
dst[191:160] := a[255:224] + a[223:192]
dst[223:192] := b[191:160] + b[159:128]
dst[255:224] := b[255:224] + b[223:192]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hadd_pd* *vhaddpd*
Synopsis
__m256d _mm256_hadd_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vhaddpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Horizontally add adjacent pairs of double-precision (64-bit) floating-point
elements in a and b, and pack the results in dst.
Operation
dst[63:0] := a[127:64] + a[63:0]
dst[127:64] := b[127:64] + b[63:0]
dst[191:128] := a[255:192] + a[191:128]
dst[255:192] := b[255:192] + b[191:128]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hadd_ps* *vhaddps*
Synopsis
__m256 _mm256_hadd_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vhaddps ymm, ymm, ymm
CPUID Flags: AVX
Description
Horizontally add adjacent pairs of single-precision (32-bit) floating-point
elements in a and b, and pack the results in dst.
Operation
dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]
dst[159:128] := a[191:160] + a[159:128]
dst[191:160] := a[255:224] + a[223:192]
dst[223:192] := b[191:160] + b[159:128]
dst[255:224] := b[255:224] + b[223:192]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hadds_epi16* *vphaddsw*
Synopsis
__m256i _mm256_hadds_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vphaddsw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Horizontally add adjacent pairs of signed 16-bit integers in a and b
using saturation, and pack the signed 16-bit results in dst.
Operation
dst[15:0] := Saturate16(a[31:16] + a[15:0])
dst[31:16] := Saturate16(a[63:48] + a[47:32])
dst[47:32] := Saturate16(a[95:80] + a[79:64])
dst[63:48] := Saturate16(a[127:112] + a[111:96])
dst[79:64] := Saturate16(b[31:16] + b[15:0])
dst[95:80] := Saturate16(b[63:48] + b[47:32])
dst[111:96] := Saturate16(b[95:80] + b[79:64])
dst[127:112] := Saturate16(b[127:112] + b[111:96])
dst[143:128] := Saturate16(a[159:144] + a[143:128])
dst[159:144] := Saturate16(a[191:176] + a[175:160])
dst[175:160] := Saturate16(a[223:208] + a[207:192])
dst[191:176] := Saturate16(a[255:240] + a[239:224])
dst[207:192] := Saturate16(b[159:144] + b[143:128])
dst[223:208] := Saturate16(b[191:176] + b[175:160])
dst[239:224] := Saturate16(b[223:208] + b[207:192])
dst[255:240] := Saturate16(b[255:240] + b[239:224])
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hsub_epi16* *vphsubw*
Synopsis
__m256i _mm256_hsub_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vphsubw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Horizontally subtract adjacent pairs of 16-bit integers in a and b,
and pack the signed 16-bit results in dst.
Operation
dst[15:0] := a[15:0] - a[31:16]
dst[31:16] := a[47:32] - a[63:48]
dst[47:32] := a[79:64] - a[95:80]
dst[63:48] := a[111:96] - a[127:112]
dst[79:64] := b[15:0] - b[31:16]
dst[95:80] := b[47:32] - b[63:48]
dst[111:96] := b[79:64] - b[95:80]
dst[127:112] := b[111:96] - b[127:112]
dst[143:128] := a[143:128] - a[159:144]
dst[159:144] := a[175:160] - a[191:176]
dst[175:160] := a[207:192] - a[223:208]
dst[191:176] := a[239:224] - a[255:240]
dst[207:192] := b[143:128] - b[159:144]
dst[223:208] := b[175:160] - b[191:176]
dst[239:224] := b[207:192] - b[223:208]
dst[255:240] := b[239:224] - b[255:240]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hsub_epi32* *vphsubd*
Synopsis
__m256i _mm256_hsub_epi32 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vphsubd ymm, ymm, ymm
CPUID Flags: AVX2
Description
Horizontally subtract adjacent pairs of 32-bit integers in a and b,
and pack the signed 32-bit results in dst.
Operation
dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]
dst[159:128] := a[159:128] - a[191:160]
dst[191:160] := a[223:192] - a[255:224]
dst[223:192] := b[159:128] - b[191:160]
dst[255:224] := b[223:192] - b[255:224]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hsub_pd* *vhsubpd*
Synopsis
__m256d _mm256_hsub_pd (__m256d a, __m256d b)
#include <immintrin.h>
Instruction: vhsubpd ymm, ymm, ymm
CPUID Flags: AVX
Description
Horizontally subtract adjacent pairs of double-precision (64-bit)
floating-point elements in a and b, and pack the results in dst.
Operation
dst[63:0] := a[63:0] - a[127:64]
dst[127:64] := b[63:0] - b[127:64]
dst[191:128] := a[191:128] - a[255:192]
dst[255:192] := b[191:128] - b[255:192]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hsub_ps* *vhsubps*
Synopsis
__m256 _mm256_hsub_ps (__m256 a, __m256 b)
#include <immintrin.h>
Instruction: vhsubps ymm, ymm, ymm
CPUID Flags: AVX
Description
Horizontally subtract adjacent pairs of single-precision (32-bit)
floating-point elements in a and b, and pack the results in dst.
Operation
dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]
dst[159:128] := a[159:128] - a[191:160]
dst[191:160] := a[223:192] - a[255:224]
dst[223:192] := b[159:128] - b[191:160]
dst[255:224] := b[223:192] - b[255:224]
dst[MAX:256] := 0

===============================================================================
                        *_mm256_hsubs_epi16* *vphsubsw*
Synopsis
__m256i _mm256_hsubs_epi16 (__m256i a, __m256i b)
#include <immintrin.h>
Instruction: vphsubsw ymm, ymm, ymm
CPUID Flags: AVX2
Description
Horizontally subtract adjacent pairs of signed 16-bit integers in a and b
using saturation, and pack the signed 16-bit results in dst.
Operation
dst[15:0] := Saturate16(a[15:0] - a[31:16])
dst[31:16] := Saturate16(a[47:32] - a[63:48])
dst[47:32] := Saturate16(a[79:64] - a[95:80])
dst[63:48] := Saturate16(a[111:96] - a[127:112])
dst[79:64] := Saturate16(b[15:0] - b[31:16])
dst[95:80] := Saturate16(b[47:32] - b[63:48])
dst[111:96] := Saturate16(b[79:64] - b[95:80])
dst[127:112] := Saturate16(b[111:96] - b[127:112])
dst[143:128] := Saturate16(a[143:128] - a[159:144])
dst[159:144] := Saturate16(a[175:160] - a[191:176])
dst[175:160] := Saturate16(a[207:192] - a[223:208])
dst[191:176] := Saturate16(a[239:224] - a[255:240])
dst[207:192] := Saturate16(b[143:128] - b[159:144])
dst[223:208] := Saturate16(b[175:160] - b[191:176])
dst[239:224] := Saturate16(b[207:192] - b[223:208])
dst[255:240] := Saturate16(b[239:224] - b[255:240])
dst[MAX:256] := 0

===============================================================================
                        *_mm_i32gather_epi32*
Synopsis
__m128i _mm_i32gather_epi32 (int const* base_addr, __m128i vindex, const int scale)
#include <immintrin.h>
Instruction: vpgatherdd xmm, vm32x, xmm
CPUID Flags: AVX2
Description
Gather 32-bit integers from memory using 32-bit indices. 32-bit elements
are loaded from addresses starting at base_addr and offset by each 32-bit
element in vindex (each index is scaled by the factor in scale). Gathered
elements are merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*32
	m := j*32
	addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
	dst[i+31:i] := MEM[addr+31:addr]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm_mask_i32gather_epi32*
Synopsis
__m128i _mm_mask_i32gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale)
#include <immintrin.h>
Instruction: vpgatherdd xmm, vm32x, xmm
CPUID Flags: AVX2
Description
Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are
loaded from addresses starting at base_addr and offset by each 32-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements
are merged into dst using mask (elements are copied from src when the highest
bit is not set in the corresponding element). scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*32
	m := j*32
	IF mask[i+31]
		addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
		dst[i+31:i] := MEM[addr+31:addr]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0

===============================================================================
                        *_mm256_i32gather_epi32*
Synopsis
__m256i _mm256_i32gather_epi32 (int const* base_addr, __m256i vindex, const int scale)
#include <immintrin.h>
Instruction: vpgatherdd ymm, vm32x, ymm
CPUID Flags: AVX2
Description
Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are
loaded from addresses starting at base_addr and offset by each 32-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 7
	i := j*32
	m := j*32
	addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
	dst[i+31:i] := MEM[addr+31:addr]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_mask_i32gather_epi32*
Synopsis
__m256i _mm256_mask_i32gather_epi32 (__m256i src, int const* base_addr, __m256i vindex, __m256i mask, const int scale)
#include <immintrin.h>
Instruction: vpgatherdd ymm, vm32x, ymm
CPUID Flags: AVX2
Description
Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are
loaded from addresses starting at base_addr and offset by each 32-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst using mask (elements are copied from src when the highest bit
is not set in the corresponding element). scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 7
	i := j*32
	m := j*32
	IF mask[i+31]
		addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
		dst[i+31:i] := MEM[addr+31:addr]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0

===============================================================================
                        *_mm_i32gather_epi64*
Synopsis
__m128i _mm_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
#include <immintrin.h>
Instruction: vpgatherdq xmm, vm32x, xmm
CPUID Flags: AVX2
Description
Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are
loaded from addresses starting at base_addr and offset by each 32-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 1
	i := j*64
	m := j*32
	addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
	dst[i+63:i] := MEM[addr+63:addr]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm_mask_i32gather_epi64*
Synopsis
__m128i _mm_mask_i32gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale)
#include <immintrin.h>
Instruction: vpgatherdq xmm, vm32x, xmm
CPUID Flags: AVX2
Description
Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are
loaded from addresses starting at base_addr and offset by each 32-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst using mask (elements are copied from src when the highest bit
is not set in the corresponding element). scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 1
	i := j*64
	m := j*32
	IF mask[i+63]
		addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
		dst[i+63:i] := MEM[addr+63:addr]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0

===============================================================================
                        *_mm256_i32gather_epi64*
Synopsis
__m256i _mm256_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
#include <immintrin.h>
Instruction: vpgatherdq ymm, vm32x, ymm
CPUID Flags: AVX2
Description
Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are
loaded from addresses starting at base_addr and offset by each 32-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*64
	m := j*32
	addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
	dst[i+63:i] := MEM[addr+63:addr]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_mask_i32gather_epi64*
Synopsis
__m256i _mm256_mask_i32gather_epi64 (__m256i src, __int64 const* base_addr, __m128i vindex, __m256i mask, const int scale)
#include <immintrin.h>
Instruction: vpgatherdq ymm, vm32x, ymm
CPUID Flags: AVX2
Description
Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are
loaded from addresses starting at base_addr and offset by each 32-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst using mask (elements are copied from src when the highest bit
is not set in the corresponding element). scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*64
	m := j*32
	IF mask[i+63]
		addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
		dst[i+63:i] := MEM[addr+63:addr]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0

===============================================================================
                        *_mm_i32gather_pd*
Synopsis
__m128d _mm_i32gather_pd (double const* base_addr, __m128i vindex, const int scale)
#include <immintrin.h>
Instruction: vgatherdpd xmm, vm32x, xmm
CPUID Flags: AVX2
Description
Gather double-precision (64-bit) floating-point elements from memory using
32-bit indices. 64-bit elements are loaded from addresses starting at base_addr
and offset by each 32-bit element in vindex (each index is scaled by the factor
in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 1
	i := j*64
	m := j*32
	addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
	dst[i+63:i] := MEM[addr+63:addr]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm_mask_i32gather_pd*
Synopsis
__m128d _mm_mask_i32gather_pd (__m128d src, double const* base_addr, __m128i vindex, __m128d mask, const int scale)
#include <immintrin.h>
Instruction: vgatherdpd xmm, vm32x, xmm
CPUID Flags: AVX2
Description
Gather double-precision (64-bit) floating-point elements from memory using
32-bit indices. 64-bit elements are loaded from addresses starting at base_addr
and offset by each 32-bit element in vindex (each index is scaled by the factor
in scale). Gathered elements are merged into dst using mask (elements are copied
from src when the highest bit is not set in the corresponding element).
scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 1
	i := j*64
	m := j*32
	IF mask[i+63]
		addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
		dst[i+63:i] := MEM[addr+63:addr]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0

===============================================================================
                        *_mm256_i32gather_pd*
Synopsis
__m256d _mm256_i32gather_pd (double const* base_addr, __m128i vindex, const int scale)
#include <immintrin.h>
Instruction: vgatherdpd ymm, vm32x, ymm
CPUID Flags: AVX2
Description
Gather double-precision (64-bit) floating-point elements from memory using
32-bit indices. 64-bit elements are loaded from addresses starting at base_addr
and offset by each 32-bit element in vindex (each index is scaled by the factor
in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*64
	m := j*32
	addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
	dst[i+63:i] := MEM[addr+63:addr]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_mask_i32gather_pd*
Synopsis
__m256d _mm256_mask_i32gather_pd (__m256d src, double const* base_addr, __m128i vindex, __m256d mask, const int scale)
#include <immintrin.h>
Instruction: vgatherdpd ymm, vm32x, ymm
CPUID Flags: AVX2
Description
Gather double-precision (64-bit) floating-point elements from memory using
32-bit indices. 64-bit elements are loaded from addresses starting at base_addr
and offset by each 32-bit element in vindex (each index is scaled by the factor
in scale). Gathered elements are merged into dst using mask (elements are copied
from src when the highest bit is not set in the corresponding element).
scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*64
	m := j*32
	IF mask[i+63]
		addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
		dst[i+63:i] := MEM[addr+63:addr]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0

===============================================================================
                        *_mm_i32gather_ps*
Synopsis
__m128 _mm_i32gather_ps (float const* base_addr, __m128i vindex, const int scale)
#include <immintrin.h>
Instruction: vgatherdps xmm, vm32x, xmm
CPUID Flags: AVX2
Description
Gather single-precision (32-bit) floating-point elements from memory using
32-bit indices. 32-bit elements are loaded from addresses starting at base_addr
and offset by each 32-bit element in vindex (each index is scaled by the factor
in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*32
	m := j*32
	addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
	dst[i+31:i] := MEM[addr+31:addr]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm_mask_i32gather_ps*
Synopsis
__m128 _mm_mask_i32gather_ps (__m128 src, float const* base_addr, __m128i vindex, __m128 mask, const int scale)
#include <immintrin.h>
Instruction: vgatherdps xmm, vm32x, xmm
CPUID Flags: AVX2
Description
Gather single-precision (32-bit) floating-point elements from memory using
32-bit indices. 32-bit elements are loaded from addresses starting at base_addr
and offset by each 32-bit element in vindex (each index is scaled by the factor
in scale). Gathered elements are merged into dst using mask (elements are copied
from src when the highest bit is not set in the corresponding element).
scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*32
	m := j*32
	IF mask[i+31]
		addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
		dst[i+31:i] := MEM[addr+31:addr]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0

===============================================================================
                        *_mm256_i32gather_ps*
Synopsis
__m256 _mm256_i32gather_ps (float const* base_addr, __m256i vindex, const int scale)
#include <immintrin.h>
Instruction: vgatherdps ymm, vm32x, ymm
CPUID Flags: AVX2
Description
Gather single-precision (32-bit) floating-point elements from memory using
32-bit indices. 32-bit elements are loaded from addresses starting at base_addr
and offset by each 32-bit element in vindex (each index is scaled by the factor
in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 7
	i := j*32
	m := j*32
	addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
	dst[i+31:i] := MEM[addr+31:addr]
ENDFOR
dst[MAX:256] := 0

===============================================================================
                        *_mm256_mask_i32gather_ps*
Synopsis
__m256 _mm256_mask_i32gather_ps (__m256 src, float const* base_addr, __m256i vindex, __m256 mask, const int scale)
#include <immintrin.h>
Instruction: vgatherdps ymm, vm32x, ymm
CPUID Flags: AVX2
Description
Gather single-precision (32-bit) floating-point elements from memory using
32-bit indices. 32-bit elements are loaded from addresses starting at base_addr
and offset by each 32-bit element in vindex (each index is scaled by the factor
in scale). Gathered elements are merged into dst using mask (elements are copied
from src when the highest bit is not set in the corresponding element).
scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 7
	i := j*32
	m := j*32
	IF mask[i+31]
		addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8
		dst[i+31:i] := MEM[addr+31:addr]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:256] := 0
dst[MAX:256] := 0

===============================================================================
                        *_mm_i64gather_epi32*
Synopsis
__m128i _mm_i64gather_epi32 (int const* base_addr, __m128i vindex, const int scale)
#include <immintrin.h>
Instruction: vpgatherqd xmm, vm64x, xmm
CPUID Flags: AVX2
Description
Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are
loaded from addresses starting at base_addr and offset by each 64-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 1
	i := j*32
	m := j*64
	addr := base_addr + vindex[m+63:m] * ZeroExtend64(scale) * 8
	dst[i+31:i] := MEM[addr+31:addr]
ENDFOR
dst[MAX:64] := 0

===============================================================================
                        *_mm_mask_i64gather_epi32*
Synopsis
__m128i _mm_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale)
#include <immintrin.h>
Instruction: vpgatherqd xmm, vm64x, xmm
CPUID Flags: AVX2
Description
Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are
loaded from addresses starting at base_addr and offset by each 64-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements
are merged into dst using mask (elements are copied from src when the highest
bit is not set in the corresponding element). scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 1
	i := j*32
	m := j*64
	IF mask[i+31]
		addr := base_addr + vindex[m+63:m] * ZeroExtend64(scale) * 8
		dst[i+31:i] := MEM[addr+31:addr]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:64] := 0
dst[MAX:64] := 0

===============================================================================
                        *_mm256_i64gather_epi32*
Synopsis
__m128i _mm256_i64gather_epi32 (int const* base_addr, __m256i vindex, const int scale)
#include <immintrin.h>
Instruction: vpgatherqd xmm, vm64y, xmm
CPUID Flags: AVX2
Description
Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are
loaded from addresses starting at base_addr and offset by each 64-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements
are merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*32
	m := j*64
	addr := base_addr + vindex[m+63:m] * ZeroExtend64(scale) * 8
	dst[i+31:i] := MEM[addr+31:addr]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm256_mask_i64gather_epi32*
Synopsis
__m128i _mm256_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m256i vindex, __m128i mask, const int scale)
#include <immintrin.h>
Instruction: vpgatherqd xmm, vm64y, xmm
CPUID Flags: AVX2
Description
Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are
loaded from addresses starting at base_addr and offset by each 64-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements
are merged into dst using mask (elements are copied from src when the highest
bit is not set in the corresponding element). scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 3
	i := j*32
	m := j*64
	IF mask[i+31]
		addr := base_addr + vindex[m+63:m] * ZeroExtend64(scale) * 8
		dst[i+31:i] := MEM[addr+31:addr]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0

===============================================================================
                        *_mm_i64gather_epi64*
Synopsis
__m128i _mm_i64gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
#include <immintrin.h>
Instruction: vpgatherqq xmm, vm64x, xmm
CPUID Flags: AVX2
Description
Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are
loaded from addresses starting at base_addr and offset by each 64-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst. scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 1
	i := j*64
	m := j*64
	addr := base_addr + vindex[m+63:m] * ZeroExtend64(scale) * 8
	dst[i+63:i] := MEM[addr+63:addr]
ENDFOR
dst[MAX:128] := 0

===============================================================================
                        *_mm_mask_i64gather_epi64*
Synopsis
__m128i _mm_mask_i64gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale)
#include <immintrin.h>
Instruction: vpgatherqq xmm, vm64x, xmm
CPUID Flags: AVX2
Description
Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are
loaded from addresses starting at base_addr and offset by each 64-bit element
in vindex (each index is scaled by the factor in scale). Gathered elements are
merged into dst using mask (elements are copied from src when the highest bit
is not set in the corresponding element). scale should be 1, 2, 4 or 8.
Operation
FOR j := 0 to 1
	i := j*64
	m := j*64
	IF mask[i+63]
		addr := base_addr + vindex[m+63:m] * ZeroExtend64(scale) * 8
		dst[i+63:i] := MEM[addr+63:addr]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
mask[MAX:128] := 0
dst[MAX:128] := 0
